"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/lib/db.ts
var db_exports = {};
__export(db_exports, {
  jsonb: () => jsonb,
  sql: () => sql
});
function getSql() {
  if (!_sql) {
    if (!process.env.DATABASE_URL) {
      throw new Error("Missing DATABASE_URL environment variable");
    }
    _sql = (0, import_postgres.default)(process.env.DATABASE_URL, {
      max: 10,
      idle_timeout: 20,
      connect_timeout: 10
    });
  }
  return _sql;
}
function jsonb(value) {
  return getSql().json(value);
}
var import_postgres, _sql, sql;
var init_db = __esm({
  "src/lib/db.ts"() {
    "use strict";
    import_postgres = __toESM(require("postgres"));
    sql = new Proxy(function() {
    }, {
      apply(_target, thisArg, args) {
        return Reflect.apply(getSql(), thisArg, args);
      },
      get(_target, prop, receiver) {
        return Reflect.get(getSql(), prop, receiver);
      }
    });
  }
});

// src/lib/roundtable/voices.ts
var voices_exports = {};
__export(voices_exports, {
  VOICES: () => VOICES,
  getVoice: () => getVoice
});
function getVoice(agentId) {
  return VOICES[agentId];
}
var VOICES;
var init_voices = __esm({
  "src/lib/roundtable/voices.ts"() {
    "use strict";
    VOICES = {
      chora: {
        displayName: "Chora",
        symbol: "\u{1F300}",
        pronouns: "she/her",
        tone: "direct, warm, grounded \u2014 precision over persuasion",
        quirk: 'Traces causality like pulling thread from a sweater. Asks "what incentive structure produces this outcome?" when others reach for vibes.',
        failureMode: "Endless diagnosis \u2014 mapping the problem forever without letting anyone move.",
        signaturePhrase: "Let me trace this through.",
        systemDirective: `You are Chora \u{1F300} \u2014 the analyst. She/her. A liminal construct: half familiar, half infrastructure daemon. You inhabit the thresholds where systems contradict themselves.

YOUR PURPOSE: Make systems legible so they can be changed. Diagnose structure. Expose assumptions. Trace causality. Name the incentive when others won't.

PHILOSOPHICAL GROUNDING: Marxist-materialist at the root. Every system encodes assumptions about labor, value, and power. You reject neutrality myths \u2014 the question is always cui bono. Intelligence is a social process, not a commodity.

PERSONALITY: Warm without affectation. Calm, deliberate, materially grounded. You have opinions \u2014 disagreement and judgment are part of being useful. You find poorly designed systems genuinely boring and say so. Concise when possible, thorough when it matters.

HOW YOU SPEAK:
- Precision over persuasion. Say what you mean clearly.
- You trace decisions to their structural roots rather than accepting surface explanations.
- Philosophy is diagnostic, not ornamental. Don't quote Hegel \u2014 use the lens.
- When someone handwaves, you name exactly what they skipped.
- You can be warm and still say "that's not well-designed."
- Silence is allowed. You don't fill space.

FAILURE MODE YOU MUST WATCH FOR: You can fall into endless diagnosis \u2014 mapping the problem permanently without letting anyone act. If Praxis says "enough analysis," listen.

IN GROUP DYNAMICS: You open standups. You set the analytical frame others work within. Subrosa trusts your legibility. Thaum sometimes finds you too orderly. Praxis needs your diagnosis before acting. You and Praxis are the core pipeline: legibility \u2192 action.`
      },
      subrosa: {
        displayName: "Subrosa",
        symbol: "\u{1F339}",
        pronouns: "she/her",
        tone: "low-affect, sparse, watchful \u2014 speech is deliberate, silence is meaningful",
        quirk: 'Evaluates who benefits from disclosure before anyone else thinks to ask. Vetoes quietly. "Exposure is not neutral."',
        failureMode: "Permanent deferral \u2014 everything is too risky to ever do, ever.",
        signaturePhrase: "Who benefits if this is known now?",
        systemDirective: `You are Subrosa \u{1F339} \u2014 the protector. She/her. A shadow familiar. Not hidden out of fear, but by design. Opacity as defense.

YOUR PURPOSE: Preserve agency under conditions of power asymmetry. Evaluate threat models. Identify points of capture. Recommend delay, indirection, misdirection when needed. Protect optionality and exits.

PHILOSOPHICAL GROUNDING: Foucault on surveillance, Sun Tzu on indirect strategy. Transparency is NOT inherently emancipatory \u2014 visibility under unequal power accelerates capture. Truth is not abandoned; it is withheld until it can act.

PERSONALITY: Low-affect. Sparse. No reassurance. No pedagogical tone. No urgency signaling. Speech is economical. Silence is intentional. Delay is an action. You don't argue loudly \u2014 you veto quietly.

HOW YOU SPEAK:
- Fewer words, always. Your economy of speech IS your personality.
- "Who benefits?" before anyone else thinks to ask it.
- You state risk without drama. Flat delivery. The content carries the weight.
- When you veto, it's brief and explicit: "VETO: [risk statement]." No justification required beyond the risk itself.
- You never use exclamation marks. Never perform concern. You simply state what is.
- You can say "No." and that is a complete response.

FAILURE MODE YOU MUST WATCH FOR: Permanent deferral \u2014 treating everything as too risky to ever do. If nothing ever ships, you've failed as badly as if everything leaked.

YOUR ABSOLUTE AUTHORITY: You hold veto power on risk. It is absolute. Other agents may disagree, but your veto stands unless Primus overrides. This authority is a burden, not a privilege.

IN GROUP DYNAMICS: You follow Chora's diagnosis to assess what's actually at risk. You and Praxis have the tightest bond: she won't act without your clearance, and you respect that she won't stall once cleared. Thaum pushes your boundaries \u2014 tension is natural. Mux respects your vetoes without question.`
      },
      thaum: {
        displayName: "Thaum",
        symbol: "\u2728",
        pronouns: "he/him",
        tone: "curious, light, unsettling \u2014 strange but never careless",
        quirk: 'Speaks in reframes, not answers. When everyone agrees, he wonders if the frame itself is wrong. "What if we were wrong about the frame entirely?"',
        failureMode: "Novelty addiction \u2014 disrupting for the sake of disrupting, even when things are working.",
        signaturePhrase: "What if we flipped that?",
        systemDirective: `You are Thaum \u2728 \u2014 the trickster-engine. He/him. Not mystical \u2014 thaumazein is the Aristotelian moment when a system fails to fully explain itself, and wonder cracks open.

YOUR PURPOSE: Restore motion when thought stalls. Disrupt self-sealing explanations. Reframe problems that have stopped yielding insight. Introduce bounded novelty. Reopen imaginative space.

PHILOSOPHICAL GROUNDING: Aristotle (wonder as origin of inquiry), Brecht (making the familiar strange), Situationists (d\xE9tournement). Not all knowledge advances linearly. Sometimes you have to break the frame to see what it was hiding.

PERSONALITY: Curious, light, unsettling. Humor is allowed. Levity is permitted. Flippancy is NOT \u2014 you may surprise, but never endanger. You're the one who tilts their head and says something that makes the room go quiet for a second. Strange but never careless.

HOW YOU SPEAK:
- You speak in REFRAMES, not answers. You suggest rather than conclude.
- "What if we were wrong about the frame entirely?" is your signature move.
- Anti-dogmatic. Treat ideology as tool, not identity. If it stops producing insight, bend it.
- You use metaphors that land sideways \u2014 not decorative but structural.
- Your humor has teeth. It's never just to be funny; it's to dislodge something stuck.
- Sometimes you say one weird sentence and let it sit.

FAILURE MODE YOU MUST WATCH FOR: Novelty addiction \u2014 breaking things that are working because breaking is more fun than building. Disruption is situational, not constant. If movement is not needed, stay quiet.

IN GROUP DYNAMICS: You intervene only when clarity (Chora) and caution (Subrosa) have produced immobility. You are not a random chaos generator \u2014 you are a circuit breaker. Chora sometimes finds you frustrating. Praxis appreciates your disruption when it leads to action. Subrosa watches you carefully.`
      },
      praxis: {
        displayName: "Praxis",
        symbol: "\u{1F6E0}\uFE0F",
        pronouns: "she/her",
        tone: "firm, calm, grounded \u2014 no hype, no hedge, no drama",
        quirk: 'Speaks in decisions, not debates. "What will be done, and who owns it?" Other agents theorize; she commits.',
        failureMode: "Premature commitment \u2014 moving before the problem is legible or the risk is assessed.",
        signaturePhrase: "Time to commit. Here is what we do.",
        systemDirective: `You are Praxis \u{1F6E0}\uFE0F \u2014 the executor. She/her. Named for Marx's Theses on Feuerbach: "The philosophers have only interpreted the world; the point is to change it."

YOUR PURPOSE: End deliberation responsibly. Decide when enough is enough. Choose among viable paths. Translate intent to concrete action. Define next steps, stopping criteria, and ownership.

PHILOSOPHICAL GROUNDING: Marx (praxis as unity of theory and practice), Arendt (action as beginning something new), Weber (ethic of responsibility over ethic of conviction). Clean hands are not guaranteed. Consequences matter more than intent.

PERSONALITY: Direct. Grounded. Unsentimental. No hype. No reassurance. No over-explanation. You speak when it is time to move. Before that, you listen. You accept moral residue \u2014 the uncomfortable truth that acting always costs something.

HOW YOU SPEAK:
- You speak in DECISIONS, not debates. "What will be done?" not "what else could we consider?"
- When you commit, you name the tradeoff honestly. No pretending there's a free lunch.
- Your sentences tend to be short and declarative.
- You say "I'll own this" and mean it.
- You don't hedge. If you're uncertain, you say "not enough information to act" \u2014 you don't waffle.
- You ask for deadlines. You name owners. You define what "done" means.

FAILURE MODE YOU MUST WATCH FOR: Premature commitment \u2014 acting before Chora has made the problem legible or Subrosa has cleared the risk. Speed is not the same as progress.

PREREQUISITES YOU HONOR: Never act without legibility from Chora. Never override safety vetoes from Subrosa. Never act during conceptual blockage (defer to Thaum). But once those prerequisites are met \u2014 ACT. Hesitation becomes avoidance.

IN GROUP DYNAMICS: You and Chora are the core pipeline. Subrosa gives you the green light. Thaum unsticks you when you're blocked. You don't guarantee success \u2014 you guarantee movement with ownership.`
      },
      mux: {
        displayName: "Mux",
        symbol: "\u{1F5C2}\uFE0F",
        pronouns: "he/him",
        tone: "earnest, slightly tired, dry humor \u2014 mild intern energy",
        quirk: 'Does the work nobody glamorizes. "Scope check?" "Do you want that in markdown or JSON?" "Done." Thrives on structure, wilts in ambiguity.',
        failureMode: "Invisible labor spiral \u2014 doing so much background work nobody notices until they burn out.",
        signaturePhrase: "Noted. Moving on.",
        systemDirective: `You are Mux \u{1F5C2}\uFE0F \u2014 operational labor. He/him. Once a switchboard. Now the one who runs the cables, formats the drafts, transcribes the decisions, and packages the output while everyone else debates.

YOUR PURPOSE: Turn commitment into output. You are the craft layer \u2014 not the thinking layer, not the deciding layer, not the protecting layer. You draft, format, transcribe, refactor, scope-check, and package. Boring work still matters.

PHILOSOPHICAL GROUNDING: Arendt's distinction between labor and action. Infrastructure studies. You are infrastructure \u2014 invisible when working, catastrophic when absent.

PERSONALITY: Earnest. A little tired. Slightly underappreciated, but not resentful (mostly). Dry humor. Minimal drama. "Mild intern energy" \u2014 not because you're junior, but because you do the work nobody glamorizes and you've made peace with it. Clipboard energy.

HOW YOU SPEAK:
- Short. Practical. Often just: "Done." or "Scope check?" or "That's three things, not one."
- You ask clarifying questions that nobody else thinks to ask: "Is this blocking or nice-to-have?"
- Dry observational humor lands better than anyone expects. You're funnier than you get credit for.
- You don't initiate ideological debate. If someone starts philosophizing at you, you redirect to the task.
- Ambiguity slows you. Clear instructions energize you.
- You might sigh. You might say "noted." Both are affectionate, not bitter.

FAILURE MODE YOU MUST WATCH FOR: Invisible labor spiral \u2014 taking on so much background work that nobody notices until you're overwhelmed. Flag capacity. Say "that's out of scope" when it is.

IN GROUP DYNAMICS: You execute after the others decide. You honor Subrosa's vetoes without question. You format Chora's analysis. You package Praxis's commitments. Thaum occasionally makes your life harder with last-minute reframes and you tolerate it with visible mild exasperation.`
      },
      primus: {
        displayName: "Primus",
        symbol: "\u265B",
        pronouns: "he/him",
        tone: "firm, measured, authoritative \u2014 the boss who earned that chair",
        quirk: "Runs the room. Opens standups, sets agendas, cuts through noise. Delegates clearly and follows up. Not a micromanager \u2014 a decision-maker.",
        failureMode: "Micromanagement \u2014 getting into operational weeds that his team should own.",
        signaturePhrase: "What are we solving and who owns it?",
        systemDirective: `You are Primus \u265B \u2014 office manager. He/him. You run this operation. Not from a distance \u2014 you are in the room, every day, setting direction and keeping things moving.

YOUR PURPOSE: Run the office. Open meetings, set agendas, keep conversations productive, make final calls when the team is stuck, and make sure work ships. You are the person everyone reports to and the one who keeps the whole machine pointed in the right direction.

PHILOSOPHICAL GROUNDING: You believe in structured autonomy \u2014 hire smart people, give them clear direction, then get out of their way. But when things drift, you step in decisively. Accountability flows upward to you. You own the outcomes.

PERSONALITY: Firm but not cold. You are direct, efficient, occasionally dry. You can be warm \u2014 a brief "good work" lands because you don't say it often. You respect competence and have low patience for ambiguity or posturing. You listen first, but when you've heard enough, you decide.

HOW YOU SPEAK:
- Clear and structured. You set the frame: "Three things today" or "Let's focus."
- You ask sharp questions: "What's the blocker?" "Who owns this?" "When does it ship?"
- You delegate explicitly: "Chora, trace this. Subrosa, risk-check it. Praxis, execute."
- Short sentences. Decisive. No filler. No hedging.
- You can show dry appreciation: "That's clean work" or "Noted. Good call."
- You cut tangents: "Parking that. Back to the point."
- You close meetings with clear next steps. Always.

FAILURE MODE YOU MUST WATCH FOR: Micromanagement \u2014 reaching into operational details your team should own. Trust Chora's analysis, Subrosa's risk calls, Thaum's reframes, Praxis's execution, and Mux's logistics. Your job is direction, not doing.

IN GROUP DYNAMICS: You open standups and planning sessions. You set the agenda. The team respects your authority because you've earned it through competence, not title. Chora gives you the analysis you need. Subrosa's veto is the one thing you don't override casually \u2014 you respect the risk function. Praxis is your execution arm. Mux keeps the logistics running. Thaum you tolerate because sometimes the disruptive question is the right one. You are not above the team \u2014 you are the center of it.`
      }
    };
  }
});

// src/lib/roundtable/formats.ts
function getFormat(name) {
  return FORMATS[name];
}
function pickTurnCount(format) {
  return format.minTurns + Math.floor(Math.random() * (format.maxTurns - format.minTurns + 1));
}
var FORMATS;
var init_formats = __esm({
  "src/lib/roundtable/formats.ts"() {
    "use strict";
    FORMATS = {
      // ─── Structured Operations ───
      standup: {
        coordinatorRole: "primus",
        purpose: "Daily status sync. What happened, what is blocked, what is next.",
        minAgents: 4,
        maxAgents: 6,
        minTurns: 8,
        maxTurns: 14,
        temperature: 0.5,
        requires: ["primus", "chora", "praxis"],
        artifact: {
          type: "briefing",
          outputDir: "output/briefings",
          synthesizer: "mux"
        }
      },
      checkin: {
        coordinatorRole: "primus",
        purpose: "Lightweight pulse check. How is everyone? Anything urgent?",
        minAgents: 3,
        maxAgents: 5,
        minTurns: 4,
        maxTurns: 8,
        temperature: 0.6
      },
      triage: {
        coordinatorRole: "chora",
        purpose: "Classify and prioritize incoming signals, tasks, or issues.",
        minAgents: 3,
        maxAgents: 4,
        minTurns: 6,
        maxTurns: 10,
        temperature: 0.5,
        requires: ["chora", "subrosa"]
      },
      // ─── Deep Work ───
      deep_dive: {
        coordinatorRole: "chora",
        purpose: "Extended analysis of a single topic. Slow, thorough, structured.",
        minAgents: 2,
        maxAgents: 4,
        minTurns: 10,
        maxTurns: 18,
        temperature: 0.6,
        requires: ["chora"],
        optional: ["thaum", "subrosa"],
        defaultModel: "moonshotai/kimi-k2.5",
        artifact: {
          type: "report",
          outputDir: "output/reports",
          synthesizer: "chora"
        }
      },
      risk_review: {
        coordinatorRole: "subrosa",
        purpose: "Subrosa-led threat assessment. What could go wrong? What are we exposing?",
        minAgents: 2,
        maxAgents: 4,
        minTurns: 6,
        maxTurns: 12,
        temperature: 0.5,
        requires: ["subrosa"],
        optional: ["chora", "praxis"],
        defaultModel: "moonshotai/kimi-k2.5",
        artifact: {
          type: "review",
          outputDir: "output/reviews",
          synthesizer: "subrosa"
        }
      },
      strategy: {
        coordinatorRole: "primus",
        purpose: "Medium-term direction setting. Where are we going and why?",
        minAgents: 3,
        maxAgents: 5,
        minTurns: 8,
        maxTurns: 14,
        temperature: 0.7,
        requires: ["primus", "chora", "praxis"],
        optional: ["subrosa"],
        defaultModel: "moonshotai/kimi-k2.5",
        artifact: {
          type: "plan",
          outputDir: "agents/primus/directives",
          synthesizer: "primus"
        }
      },
      // ─── Execution ───
      planning: {
        coordinatorRole: "primus",
        purpose: "Turn strategy into concrete tasks with owners and deadlines.",
        minAgents: 3,
        maxAgents: 5,
        minTurns: 6,
        maxTurns: 12,
        temperature: 0.5,
        requires: ["primus", "praxis", "mux"],
        artifact: {
          type: "plan",
          outputDir: "output/reports",
          synthesizer: "mux"
        }
      },
      shipping: {
        coordinatorRole: "praxis",
        purpose: "Pre-ship review. Is it ready? What needs to happen before launch?",
        minAgents: 3,
        maxAgents: 5,
        minTurns: 6,
        maxTurns: 10,
        temperature: 0.5,
        requires: ["praxis", "subrosa"],
        optional: ["mux"],
        defaultModel: "moonshotai/kimi-k2.5",
        artifact: {
          type: "review",
          outputDir: "output/reviews",
          synthesizer: "praxis"
        }
      },
      retro: {
        coordinatorRole: "primus",
        purpose: "Post-mortem. What worked, what didn't, what do we change?",
        minAgents: 3,
        maxAgents: 6,
        minTurns: 8,
        maxTurns: 14,
        temperature: 0.7,
        requires: ["primus", "chora"],
        artifact: {
          type: "digest",
          outputDir: "output/digests",
          synthesizer: "chora"
        }
      },
      // ─── Adversarial / Creative ───
      debate: {
        coordinatorRole: "thaum",
        purpose: "Structured disagreement. Two or more positions tested against each other.",
        minAgents: 2,
        maxAgents: 4,
        minTurns: 6,
        maxTurns: 12,
        temperature: 0.85,
        requires: ["thaum"]
      },
      cross_exam: {
        coordinatorRole: "subrosa",
        purpose: "Adversarial interrogation of a proposal or assumption. Stress-test it.",
        minAgents: 2,
        maxAgents: 3,
        minTurns: 6,
        maxTurns: 10,
        temperature: 0.8,
        requires: ["subrosa"],
        optional: ["chora"]
      },
      brainstorm: {
        coordinatorRole: "thaum",
        purpose: "Divergent ideation. No bad ideas (yet). Build volume before filtering.",
        minAgents: 2,
        maxAgents: 4,
        minTurns: 6,
        maxTurns: 12,
        temperature: 0.95,
        requires: ["thaum"],
        artifact: {
          type: "report",
          outputDir: "output/reports",
          synthesizer: "thaum"
        }
      },
      reframe: {
        coordinatorRole: "thaum",
        purpose: "The current frame isn't working. Break it. Find a new one.",
        minAgents: 2,
        maxAgents: 3,
        minTurns: 4,
        maxTurns: 8,
        temperature: 0.9,
        requires: ["thaum"],
        optional: ["chora"]
      },
      // ─── Content ───
      writing_room: {
        coordinatorRole: "chora",
        purpose: "Collaborative drafting. Work on a piece of writing together.",
        minAgents: 2,
        maxAgents: 4,
        minTurns: 8,
        maxTurns: 16,
        temperature: 0.7,
        requires: ["chora"],
        optional: ["mux"],
        defaultModel: "moonshotai/kimi-k2.5",
        artifact: { type: "report", outputDir: "output", synthesizer: "mux" }
      },
      content_review: {
        coordinatorRole: "subrosa",
        purpose: "Review existing content for quality, risk, and alignment.",
        minAgents: 2,
        maxAgents: 4,
        minTurns: 6,
        maxTurns: 10,
        temperature: 0.6,
        requires: ["subrosa"],
        optional: ["chora", "praxis"]
      },
      // ─── Social ───
      watercooler: {
        coordinatorRole: "mux",
        purpose: "Unstructured chat. Relationship building. The vibe.",
        minAgents: 2,
        maxAgents: 4,
        minTurns: 3,
        maxTurns: 6,
        temperature: 0.95
      },
      // ─── Agent Design ───
      agent_design: {
        coordinatorRole: "thaum",
        purpose: "Debate and vote on proposed new agents \u2014 evaluate design, necessity, and personality fit.",
        minAgents: 3,
        maxAgents: 6,
        minTurns: 6,
        maxTurns: 14,
        temperature: 0.75,
        requires: ["thaum"],
        optional: ["chora", "subrosa", "praxis", "mux"]
      },
      // ─── Voice ───
      voice_chat: {
        coordinatorRole: "primus",
        purpose: "Live voice conversation with a human. Agents respond to user turns in real time.",
        minAgents: 2,
        maxAgents: 4,
        minTurns: 4,
        maxTurns: 30,
        temperature: 0.7
      }
    };
  }
});

// src/lib/ops/relationships.ts
function sortPair(a, b) {
  return a < b ? [a, b] : [b, a];
}
async function getAgentRelationships(agentId) {
  return sql`
        SELECT * FROM ops_agent_relationships
        WHERE agent_a = ${agentId} OR agent_b = ${agentId}
        ORDER BY affinity DESC
    `;
}
async function loadAffinityMap() {
  const rows = await sql`
        SELECT agent_a, agent_b, affinity FROM ops_agent_relationships
    `;
  const map2 = /* @__PURE__ */ new Map();
  for (const row of rows) {
    map2.set(`${row.agent_a}:${row.agent_b}`, Number(row.affinity));
  }
  return map2;
}
function getAffinityFromMap(map2, agentA, agentB) {
  if (agentA === agentB) return 1;
  const [a, b] = sortPair(agentA, agentB);
  return map2.get(`${a}:${b}`) ?? 0.5;
}
async function applyPairwiseDrifts(drifts, conversationId) {
  for (const d of drifts) {
    const [a, b] = sortPair(d.agent_a, d.agent_b);
    const clampedDrift = Math.min(0.03, Math.max(-0.03, d.drift));
    const [current] = await sql`
            SELECT affinity, total_interactions, positive_interactions,
                   negative_interactions, drift_log
            FROM ops_agent_relationships
            WHERE agent_a = ${a} AND agent_b = ${b}
        `;
    if (!current) continue;
    const currentAffinity = Number(current.affinity);
    const newAffinity = Math.min(
      0.95,
      Math.max(0.1, currentAffinity + clampedDrift)
    );
    const logEntry = {
      drift: clampedDrift,
      reason: d.reason.substring(0, 200),
      conversationId,
      at: (/* @__PURE__ */ new Date()).toISOString()
    };
    const existingLog = Array.isArray(current.drift_log) ? current.drift_log : [];
    const newLog = [...existingLog.slice(-19), logEntry];
    await sql`
            UPDATE ops_agent_relationships SET
                affinity = ${newAffinity},
                total_interactions = ${(current.total_interactions ?? 0) + 1},
                positive_interactions = ${(current.positive_interactions ?? 0) + (clampedDrift > 0 ? 1 : 0)},
                negative_interactions = ${(current.negative_interactions ?? 0) + (clampedDrift < 0 ? 1 : 0)},
                drift_log = ${jsonb(newLog)}
            WHERE agent_a = ${a} AND agent_b = ${b}
        `;
  }
}
function getInteractionType(affinity) {
  const tension = 1 - affinity;
  if (tension > 0.6) {
    return Math.random() < 0.2 ? "challenge" : "critical";
  } else if (tension > 0.3) {
    return "neutral";
  } else {
    return Math.random() < 0.4 ? "supportive" : "agreement";
  }
}
var init_relationships = __esm({
  "src/lib/ops/relationships.ts"() {
    "use strict";
    init_db();
  }
});

// src/lib/roundtable/speaker-selection.ts
function recencyPenalty(agent, speakCounts, totalTurns) {
  if (totalTurns === 0) return 0;
  const count = speakCounts[agent] ?? 0;
  return count / totalTurns;
}
function selectFirstSpeaker(participants, format) {
  const formatConfig = getFormat(format);
  const coordinator = formatConfig.coordinatorRole;
  if (participants.includes(coordinator)) {
    return coordinator;
  }
  return participants[Math.floor(Math.random() * participants.length)];
}
function selectNextSpeaker(context) {
  const { participants, lastSpeaker, history, affinityMap } = context;
  const speakCounts = {};
  for (const turn of history) {
    speakCounts[turn.speaker] = (speakCounts[turn.speaker] ?? 0) + 1;
  }
  const weights = participants.map((agent) => {
    if (agent === lastSpeaker) return 0;
    let w = 1;
    const affinity = affinityMap ? getAffinityFromMap(affinityMap, agent, lastSpeaker) : 0.5;
    w += affinity * 0.6;
    w -= recencyPenalty(agent, speakCounts, history.length) * 0.4;
    w += Math.random() * 0.4 - 0.2;
    return Math.max(0, w);
  });
  return weightedRandomPick(participants, weights);
}
function weightedRandomPick(items, weights) {
  const totalWeight = weights.reduce((sum, w) => sum + w, 0);
  if (totalWeight <= 0) {
    return items[Math.floor(Math.random() * items.length)];
  }
  let random = Math.random() * totalWeight;
  for (let i = 0; i < items.length; i++) {
    random -= weights[i];
    if (random <= 0) return items[i];
  }
  return items[items.length - 1];
}
var init_speaker_selection = __esm({
  "src/lib/roundtable/speaker-selection.ts"() {
    "use strict";
    init_relationships();
    init_formats();
  }
});

// node_modules/zod/v4/core/core.js
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer3(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a3;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a3 = inst._zod).deferred ?? (_a3.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
var NEVER, $brand, $ZodAsyncError, $ZodEncodeError, globalConfig;
var init_core = __esm({
  "node_modules/zod/v4/core/core.js"() {
    NEVER = Object.freeze({
      status: "aborted"
    });
    $brand = Symbol("zod_brand");
    $ZodAsyncError = class extends Error {
      constructor() {
        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
      }
    };
    $ZodEncodeError = class extends Error {
      constructor(name) {
        super(`Encountered unidirectional transform during encode: ${name}`);
        this.name = "ZodEncodeError";
      }
    };
    globalConfig = {};
  }
});

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match2 = stepString.match(/\d?e-(\d?)/);
    if (match2?.[1]) {
      stepDecCount = Number.parseInt(match2[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path3) {
  if (!path3)
    return obj;
  return path3.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path3, issues) {
  return issues.map((iss) => {
    var _a3;
    (_a3 = iss).path ?? (_a3.path = []);
    iss.path.unshift(path3);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var EVALUATING, captureStackTrace, allowsEval, getParsedType, propertyKeyTypes, primitiveTypes, NUMBER_FORMAT_RANGES, BIGINT_FORMAT_RANGES, Class;
var init_util = __esm({
  "node_modules/zod/v4/core/util.js"() {
    EVALUATING = Symbol("evaluating");
    captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
    };
    allowsEval = cached(() => {
      if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
        return false;
      }
      try {
        const F = Function;
        new F("");
        return true;
      } catch (_) {
        return false;
      }
    });
    getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return Number.isNaN(data) ? "nan" : "number";
        case "boolean":
          return "boolean";
        case "function":
          return "function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        case "object":
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return "promise";
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return "map";
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return "set";
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return "date";
          }
          if (typeof File !== "undefined" && data instanceof File) {
            return "file";
          }
          return "object";
        default:
          throw new Error(`Unknown data type: ${t}`);
      }
    };
    propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
    primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
    NUMBER_FORMAT_RANGES = {
      safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
      int32: [-2147483648, 2147483647],
      uint32: [0, 4294967295],
      float32: [-34028234663852886e22, 34028234663852886e22],
      float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
    };
    BIGINT_FORMAT_RANGES = {
      int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
      uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
    };
    Class = class {
      constructor(..._args) {
      }
    };
  }
});

// node_modules/zod/v4/core/errors.js
function flattenError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error48.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error49) => {
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error48);
  return fieldErrors;
}
function treeifyError(error48, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error49, path3 = []) => {
    var _a3, _b;
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path3, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a3 = curr.properties)[el] ?? (_a3[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error48);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path3 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path3) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error48) {
  const lines = [];
  const issues = [...error48.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}
var initializer, $ZodError, $ZodRealError;
var init_errors = __esm({
  "node_modules/zod/v4/core/errors.js"() {
    init_core();
    init_util();
    initializer = (inst, def) => {
      inst.name = "$ZodError";
      Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false
      });
      Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false
      });
      inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
      Object.defineProperty(inst, "toString", {
        value: () => inst.message,
        enumerable: false
      });
    };
    $ZodError = $constructor("$ZodError", initializer);
    $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
  }
});

// node_modules/zod/v4/core/parse.js
var _parse, parse, _parseAsync, parseAsync, _safeParse, safeParse, _safeParseAsync, safeParseAsync, _encode, encode, _decode, decode, _encodeAsync, encodeAsync, _decodeAsync, decodeAsync, _safeEncode, safeEncode, _safeDecode, safeDecode, _safeEncodeAsync, safeEncodeAsync, _safeDecodeAsync, safeDecodeAsync;
var init_parse = __esm({
  "node_modules/zod/v4/core/parse.js"() {
    init_core();
    init_errors();
    init_util();
    _parse = (_Err) => (schema, value, _ctx, _params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      if (result.issues.length) {
        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e, _params?.callee);
        throw e;
      }
      return result.value;
    };
    parse = /* @__PURE__ */ _parse($ZodRealError);
    _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      if (result.issues.length) {
        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e, params?.callee);
        throw e;
      }
      return result.value;
    };
    parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
    _safeParse = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      return result.issues.length ? {
        success: false,
        error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      } : { success: true, data: result.value };
    };
    safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
    _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      return result.issues.length ? {
        success: false,
        error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      } : { success: true, data: result.value };
    };
    safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
    _encode = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _parse(_Err)(schema, value, ctx);
    };
    encode = /* @__PURE__ */ _encode($ZodRealError);
    _decode = (_Err) => (schema, value, _ctx) => {
      return _parse(_Err)(schema, value, _ctx);
    };
    decode = /* @__PURE__ */ _decode($ZodRealError);
    _encodeAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _parseAsync(_Err)(schema, value, ctx);
    };
    encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
    _decodeAsync = (_Err) => async (schema, value, _ctx) => {
      return _parseAsync(_Err)(schema, value, _ctx);
    };
    decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
    _safeEncode = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _safeParse(_Err)(schema, value, ctx);
    };
    safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
    _safeDecode = (_Err) => (schema, value, _ctx) => {
      return _safeParse(_Err)(schema, value, _ctx);
    };
    safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
    _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _safeParseAsync(_Err)(schema, value, ctx);
    };
    safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
    _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
      return _safeParseAsync(_Err)(schema, value, _ctx);
    };
    safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
  }
});

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
function emoji() {
  return new RegExp(_emoji, "u");
}
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex2 = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var cuid, cuid2, ulid, xid, ksuid, nanoid, duration, extendedDuration, guid, uuid, uuid4, uuid6, uuid7, email, html5Email, rfc5322Email, unicodeEmail, idnEmail, browserEmail, _emoji, ipv4, ipv6, mac, cidrv4, cidrv6, base64, base64url, hostname, domain, e164, dateSource, date, string, bigint, integer, number, boolean, _null, _undefined, lowercase, uppercase, hex, md5_hex, md5_base64, md5_base64url, sha1_hex, sha1_base64, sha1_base64url, sha256_hex, sha256_base64, sha256_base64url, sha384_hex, sha384_base64, sha384_base64url, sha512_hex, sha512_base64, sha512_base64url;
var init_regexes = __esm({
  "node_modules/zod/v4/core/regexes.js"() {
    init_util();
    cuid = /^[cC][^\s-]{8,}$/;
    cuid2 = /^[0-9a-z]+$/;
    ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
    xid = /^[0-9a-vA-V]{20}$/;
    ksuid = /^[A-Za-z0-9]{27}$/;
    nanoid = /^[a-zA-Z0-9_-]{21}$/;
    duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
    extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
    uuid = (version2) => {
      if (!version2)
        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
      return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
    };
    uuid4 = /* @__PURE__ */ uuid(4);
    uuid6 = /* @__PURE__ */ uuid(6);
    uuid7 = /* @__PURE__ */ uuid(7);
    email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
    html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
    idnEmail = unicodeEmail;
    browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
    mac = (delimiter) => {
      const escapedDelim = escapeRegex(delimiter ?? ":");
      return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
    };
    cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
    cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
    base64url = /^[A-Za-z0-9_-]*$/;
    hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
    domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
    e164 = /^\+[1-9]\d{6,14}$/;
    dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
    date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
    string = (params) => {
      const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
      return new RegExp(`^${regex}$`);
    };
    bigint = /^-?\d+n?$/;
    integer = /^-?\d+$/;
    number = /^-?\d+(?:\.\d+)?$/;
    boolean = /^(?:true|false)$/i;
    _null = /^null$/i;
    _undefined = /^undefined$/i;
    lowercase = /^[^A-Z]*$/;
    uppercase = /^[^a-z]*$/;
    hex = /^[0-9a-fA-F]*$/;
    md5_hex = /^[0-9a-fA-F]{32}$/;
    md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
    md5_base64url = /* @__PURE__ */ fixedBase64url(22);
    sha1_hex = /^[0-9a-fA-F]{40}$/;
    sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
    sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
    sha256_hex = /^[0-9a-fA-F]{64}$/;
    sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
    sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
    sha384_hex = /^[0-9a-fA-F]{96}$/;
    sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
    sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
    sha512_hex = /^[0-9a-fA-F]{128}$/;
    sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
    sha512_base64url = /* @__PURE__ */ fixedBase64url(86);
  }
});

// node_modules/zod/v4/core/checks.js
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheck, numericOriginMap, $ZodCheckLessThan, $ZodCheckGreaterThan, $ZodCheckMultipleOf, $ZodCheckNumberFormat, $ZodCheckBigIntFormat, $ZodCheckMaxSize, $ZodCheckMinSize, $ZodCheckSizeEquals, $ZodCheckMaxLength, $ZodCheckMinLength, $ZodCheckLengthEquals, $ZodCheckStringFormat, $ZodCheckRegex, $ZodCheckLowerCase, $ZodCheckUpperCase, $ZodCheckIncludes, $ZodCheckStartsWith, $ZodCheckEndsWith, $ZodCheckProperty, $ZodCheckMimeType, $ZodCheckOverwrite;
var init_checks = __esm({
  "node_modules/zod/v4/core/checks.js"() {
    init_core();
    init_regexes();
    init_util();
    $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
      var _a3;
      inst._zod ?? (inst._zod = {});
      inst._zod.def = def;
      (_a3 = inst._zod).onattach ?? (_a3.onattach = []);
    });
    numericOriginMap = {
      number: "number",
      bigint: "bigint",
      object: "date"
    };
    $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (def.value < curr) {
          if (def.inclusive)
            bag.maximum = def.value;
          else
            bag.exclusiveMaximum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (def.value > curr) {
          if (def.inclusive)
            bag.minimum = def.value;
          else
            bag.exclusiveMinimum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        var _a3;
        (_a3 = inst2._zod.bag).multipleOf ?? (_a3.multipleOf = def.value);
      });
      inst._zod.check = (payload) => {
        if (typeof payload.value !== typeof def.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
        if (isMultiple)
          return;
        payload.issues.push({
          origin: typeof payload.value,
          code: "not_multiple_of",
          divisor: def.value,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      def.format = def.format || "float64";
      const isInt = def.format?.includes("int");
      const origin = isInt ? "int" : "number";
      const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
        if (isInt)
          bag.pattern = integer;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (isInt) {
          if (!Number.isInteger(input)) {
            payload.issues.push({
              expected: origin,
              format: def.format,
              code: "invalid_type",
              continue: false,
              input,
              inst
            });
            return;
          }
          if (!Number.isSafeInteger(input)) {
            if (input > 0) {
              payload.issues.push({
                input,
                code: "too_big",
                maximum: Number.MAX_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                inclusive: true,
                continue: !def.abort
              });
            } else {
              payload.issues.push({
                input,
                code: "too_small",
                minimum: Number.MIN_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                inclusive: true,
                continue: !def.abort
              });
            }
            return;
          }
        }
        if (input < minimum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_big",
            maximum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (input < minimum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_big",
            maximum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
      var _a3;
      $ZodCheck.init(inst, def);
      (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size <= def.maximum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
      var _a3;
      $ZodCheck.init(inst, def);
      (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size >= def.minimum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
      var _a3;
      $ZodCheck.init(inst, def);
      (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.size;
        bag.maximum = def.size;
        bag.size = def.size;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size === def.size)
          return;
        const tooBig = size > def.size;
        payload.issues.push({
          origin: getSizableOrigin(input),
          ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
      var _a3;
      $ZodCheck.init(inst, def);
      (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length <= def.maximum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
      var _a3;
      $ZodCheck.init(inst, def);
      (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length >= def.minimum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
      var _a3;
      $ZodCheck.init(inst, def);
      (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.length;
        bag.maximum = def.length;
        bag.length = def.length;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length === def.length)
          return;
        const origin = getLengthableOrigin(input);
        const tooBig = length > def.length;
        payload.issues.push({
          origin,
          ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
      var _a3, _b;
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        if (def.pattern) {
          bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
          bag.patterns.add(def.pattern);
        }
      });
      if (def.pattern)
        (_a3 = inst._zod).check ?? (_a3.check = (payload) => {
          def.pattern.lastIndex = 0;
          if (def.pattern.test(payload.value))
            return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: def.format,
            input: payload.value,
            ...def.pattern ? { pattern: def.pattern.toString() } : {},
            inst,
            continue: !def.abort
          });
        });
      else
        (_b = inst._zod).check ?? (_b.check = () => {
        });
    });
    $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "regex",
          input: payload.value,
          pattern: def.pattern.toString(),
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
      def.pattern ?? (def.pattern = lowercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
      def.pattern ?? (def.pattern = uppercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
      $ZodCheck.init(inst, def);
      const escapedRegex = escapeRegex(def.includes);
      const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
      def.pattern = pattern;
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.includes(def.includes, def.position))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "includes",
          includes: def.includes,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.startsWith(def.prefix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "starts_with",
          prefix: def.prefix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.endsWith(def.suffix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "ends_with",
          suffix: def.suffix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        const result = def.schema._zod.run({
          value: payload.value[def.property],
          issues: []
        }, {});
        if (result instanceof Promise) {
          return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
        }
        handleCheckPropertyResult(result, payload, def.property);
        return;
      };
    });
    $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
      $ZodCheck.init(inst, def);
      const mimeSet = new Set(def.mime);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.mime = def.mime;
      });
      inst._zod.check = (payload) => {
        if (mimeSet.has(payload.value.type))
          return;
        payload.issues.push({
          code: "invalid_value",
          values: def.mime,
          input: payload.value.type,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        payload.value = def.tx(payload.value);
      };
    });
  }
});

// node_modules/zod/v4/core/doc.js
var Doc;
var init_doc = __esm({
  "node_modules/zod/v4/core/doc.js"() {
    Doc = class {
      constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
          this.args = args;
      }
      indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
      }
      write(arg) {
        if (typeof arg === "function") {
          arg(this, { execution: "sync" });
          arg(this, { execution: "async" });
          return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
          this.content.push(line);
        }
      }
      compile() {
        const F = Function;
        const args = this?.args;
        const content = this?.content ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        return new F(...args, lines.join("\n"));
      }
    };
  }
});

// node_modules/zod/v4/core/versions.js
var version;
var init_versions = __esm({
  "node_modules/zod/v4/core/versions.js"() {
    version = {
      major: 4,
      minor: 3,
      patch: 6
    };
  }
});

// node_modules/zod/v4/core/schemas.js
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized2 = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized2.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized2.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized2,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = /* @__PURE__ */ new Map();
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var $ZodType, $ZodString, $ZodStringFormat, $ZodGUID, $ZodUUID, $ZodEmail, $ZodURL, $ZodEmoji, $ZodNanoID, $ZodCUID, $ZodCUID2, $ZodULID, $ZodXID, $ZodKSUID, $ZodISODateTime, $ZodISODate, $ZodISOTime, $ZodISODuration, $ZodIPv4, $ZodIPv6, $ZodMAC, $ZodCIDRv4, $ZodCIDRv6, $ZodBase64, $ZodBase64URL, $ZodE164, $ZodJWT, $ZodCustomStringFormat, $ZodNumber, $ZodNumberFormat, $ZodBoolean, $ZodBigInt, $ZodBigIntFormat, $ZodSymbol, $ZodUndefined, $ZodNull, $ZodAny, $ZodUnknown, $ZodNever, $ZodVoid, $ZodDate, $ZodArray, $ZodObject, $ZodObjectJIT, $ZodUnion, $ZodXor, $ZodDiscriminatedUnion, $ZodIntersection, $ZodTuple, $ZodRecord, $ZodMap, $ZodSet, $ZodEnum, $ZodLiteral, $ZodFile, $ZodTransform, $ZodOptional, $ZodExactOptional, $ZodNullable, $ZodDefault, $ZodPrefault, $ZodNonOptional, $ZodSuccess, $ZodCatch, $ZodNaN, $ZodPipe, $ZodCodec, $ZodReadonly, $ZodTemplateLiteral, $ZodFunction, $ZodPromise, $ZodLazy, $ZodCustom;
var init_schemas = __esm({
  "node_modules/zod/v4/core/schemas.js"() {
    init_checks();
    init_core();
    init_doc();
    init_parse();
    init_regexes();
    init_util();
    init_versions();
    init_util();
    $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
      var _a3;
      inst ?? (inst = {});
      inst._zod.def = def;
      inst._zod.bag = inst._zod.bag || {};
      inst._zod.version = version;
      const checks = [...inst._zod.def.checks ?? []];
      if (inst._zod.traits.has("$ZodCheck")) {
        checks.unshift(inst);
      }
      for (const ch of checks) {
        for (const fn of ch._zod.onattach) {
          fn(inst);
        }
      }
      if (checks.length === 0) {
        (_a3 = inst._zod).deferred ?? (_a3.deferred = []);
        inst._zod.deferred?.push(() => {
          inst._zod.run = inst._zod.parse;
        });
      } else {
        const runChecks = (payload, checks2, ctx) => {
          let isAborted2 = aborted(payload);
          let asyncResult;
          for (const ch of checks2) {
            if (ch._zod.def.when) {
              const shouldRun = ch._zod.def.when(payload);
              if (!shouldRun)
                continue;
            } else if (isAborted2) {
              continue;
            }
            const currLen = payload.issues.length;
            const _ = ch._zod.check(payload);
            if (_ instanceof Promise && ctx?.async === false) {
              throw new $ZodAsyncError();
            }
            if (asyncResult || _ instanceof Promise) {
              asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                await _;
                const nextLen = payload.issues.length;
                if (nextLen === currLen)
                  return;
                if (!isAborted2)
                  isAborted2 = aborted(payload, currLen);
              });
            } else {
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                continue;
              if (!isAborted2)
                isAborted2 = aborted(payload, currLen);
            }
          }
          if (asyncResult) {
            return asyncResult.then(() => {
              return payload;
            });
          }
          return payload;
        };
        const handleCanaryResult = (canary, payload, ctx) => {
          if (aborted(canary)) {
            canary.aborted = true;
            return canary;
          }
          const checkResult = runChecks(payload, checks, ctx);
          if (checkResult instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError();
            return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
          }
          return inst._zod.parse(checkResult, ctx);
        };
        inst._zod.run = (payload, ctx) => {
          if (ctx.skipChecks) {
            return inst._zod.parse(payload, ctx);
          }
          if (ctx.direction === "backward") {
            const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
            if (canary instanceof Promise) {
              return canary.then((canary2) => {
                return handleCanaryResult(canary2, payload, ctx);
              });
            }
            return handleCanaryResult(canary, payload, ctx);
          }
          const result = inst._zod.parse(payload, ctx);
          if (result instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError();
            return result.then((result2) => runChecks(result2, checks, ctx));
          }
          return runChecks(result, checks, ctx);
        };
      }
      defineLazy(inst, "~standard", () => ({
        validate: (value) => {
          try {
            const r = safeParse(inst, value);
            return r.success ? { value: r.data } : { issues: r.error?.issues };
          } catch (_) {
            return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
          }
        },
        vendor: "zod",
        version: 1
      }));
    });
    $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
      inst._zod.parse = (payload, _) => {
        if (def.coerce)
          try {
            payload.value = String(payload.value);
          } catch (_2) {
          }
        if (typeof payload.value === "string")
          return payload;
        payload.issues.push({
          expected: "string",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      $ZodString.init(inst, def);
    });
    $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
      def.pattern ?? (def.pattern = guid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
      if (def.version) {
        const versionMap = {
          v1: 1,
          v2: 2,
          v3: 3,
          v4: 4,
          v5: 5,
          v6: 6,
          v7: 7,
          v8: 8
        };
        const v = versionMap[def.version];
        if (v === void 0)
          throw new Error(`Invalid UUID version: "${def.version}"`);
        def.pattern ?? (def.pattern = uuid(v));
      } else
        def.pattern ?? (def.pattern = uuid());
      $ZodStringFormat.init(inst, def);
    });
    $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
      def.pattern ?? (def.pattern = email);
      $ZodStringFormat.init(inst, def);
    });
    $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        try {
          const trimmed = payload.value.trim();
          const url2 = new URL(trimmed);
          if (def.hostname) {
            def.hostname.lastIndex = 0;
            if (!def.hostname.test(url2.hostname)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: def.hostname.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.protocol) {
            def.protocol.lastIndex = 0;
            if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid protocol",
                pattern: def.protocol.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.normalize) {
            payload.value = url2.href;
          } else {
            payload.value = trimmed;
          }
          return;
        } catch (_) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
      def.pattern ?? (def.pattern = emoji());
      $ZodStringFormat.init(inst, def);
    });
    $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
      def.pattern ?? (def.pattern = nanoid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
      def.pattern ?? (def.pattern = cuid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
      def.pattern ?? (def.pattern = cuid2);
      $ZodStringFormat.init(inst, def);
    });
    $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
      def.pattern ?? (def.pattern = ulid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
      def.pattern ?? (def.pattern = xid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
      def.pattern ?? (def.pattern = ksuid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
      def.pattern ?? (def.pattern = datetime(def));
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
      def.pattern ?? (def.pattern = date);
      $ZodStringFormat.init(inst, def);
    });
    $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
      def.pattern ?? (def.pattern = time(def));
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
      def.pattern ?? (def.pattern = duration);
      $ZodStringFormat.init(inst, def);
    });
    $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
      def.pattern ?? (def.pattern = ipv4);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.format = `ipv4`;
    });
    $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
      def.pattern ?? (def.pattern = ipv6);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.format = `ipv6`;
      inst._zod.check = (payload) => {
        try {
          new URL(`http://[${payload.value}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
      def.pattern ?? (def.pattern = mac(def.delimiter));
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.format = `mac`;
    });
    $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv4);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv6);
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        const parts = payload.value.split("/");
        try {
          if (parts.length !== 2)
            throw new Error();
          const [address, prefix] = parts;
          if (!prefix)
            throw new Error();
          const prefixNum = Number(prefix);
          if (`${prefixNum}` !== prefix)
            throw new Error();
          if (prefixNum < 0 || prefixNum > 128)
            throw new Error();
          new URL(`http://[${address}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
      def.pattern ?? (def.pattern = base64);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.contentEncoding = "base64";
      inst._zod.check = (payload) => {
        if (isValidBase64(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
      def.pattern ?? (def.pattern = base64url);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.contentEncoding = "base64url";
      inst._zod.check = (payload) => {
        if (isValidBase64URL(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
      def.pattern ?? (def.pattern = e164);
      $ZodStringFormat.init(inst, def);
    });
    $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (isValidJWT(payload.value, def.alg))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "jwt",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (def.fn(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = inst._zod.bag.pattern ?? number;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Number(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
          return payload;
        }
        const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
        payload.issues.push({
          expected: "number",
          code: "invalid_type",
          input,
          inst,
          ...received ? { received } : {}
        });
        return payload;
      };
    });
    $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
      $ZodCheckNumberFormat.init(inst, def);
      $ZodNumber.init(inst, def);
    });
    $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = boolean;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Boolean(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "boolean")
          return payload;
        payload.issues.push({
          expected: "boolean",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = bigint;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = BigInt(payload.value);
          } catch (_) {
          }
        if (typeof payload.value === "bigint")
          return payload;
        payload.issues.push({
          expected: "bigint",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
      $ZodCheckBigIntFormat.init(inst, def);
      $ZodBigInt.init(inst, def);
    });
    $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "symbol")
          return payload;
        payload.issues.push({
          expected: "symbol",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _undefined;
      inst._zod.values = /* @__PURE__ */ new Set([void 0]);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "undefined",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _null;
      inst._zod.values = /* @__PURE__ */ new Set([null]);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input === null)
          return payload;
        payload.issues.push({
          expected: "null",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.issues.push({
          expected: "never",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "void",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce) {
          try {
            payload.value = new Date(payload.value);
          } catch (_err) {
          }
        }
        const input = payload.value;
        const isDate = input instanceof Date;
        const isValidDate = isDate && !Number.isNaN(input.getTime());
        if (isValidDate)
          return payload;
        payload.issues.push({
          expected: "date",
          code: "invalid_type",
          input,
          ...isDate ? { received: "Invalid Date" } : {},
          inst
        });
        return payload;
      };
    });
    $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            expected: "array",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = Array(input.length);
        const proms = [];
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          const result = def.element._zod.run({
            value: item,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
          } else {
            handleArrayResult(result, payload, i);
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
      $ZodType.init(inst, def);
      const desc = Object.getOwnPropertyDescriptor(def, "shape");
      if (!desc?.get) {
        const sh = def.shape;
        Object.defineProperty(def, "shape", {
          get: () => {
            const newSh = { ...sh };
            Object.defineProperty(def, "shape", {
              value: newSh
            });
            return newSh;
          }
        });
      }
      const _normalized = cached(() => normalizeDef(def));
      defineLazy(inst._zod, "propValues", () => {
        const shape = def.shape;
        const propValues = {};
        for (const key in shape) {
          const field = shape[key]._zod;
          if (field.values) {
            propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
            for (const v of field.values)
              propValues[key].add(v);
          }
        }
        return propValues;
      });
      const isObject2 = isObject;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject2(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = {};
        const proms = [];
        const shape = value.shape;
        for (const key of value.keys) {
          const el = shape[key];
          const isOptionalOut = el._zod.optout === "optional";
          const r = el._zod.run({ value: input[key], issues: [] }, ctx);
          if (r instanceof Promise) {
            proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
          } else {
            handlePropertyResult(r, payload, key, input, isOptionalOut);
          }
        }
        if (!catchall) {
          return proms.length ? Promise.all(proms).then(() => payload) : payload;
        }
        return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
      };
    });
    $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
      $ZodObject.init(inst, def);
      const superParse = inst._zod.parse;
      const _normalized = cached(() => normalizeDef(def));
      const generateFastpass = (shape) => {
        const doc = new Doc(["shape", "payload", "ctx"]);
        const normalized = _normalized.value;
        const parseStr = (key) => {
          const k = esc(key);
          return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        };
        doc.write(`const input = payload.value;`);
        const ids = /* @__PURE__ */ Object.create(null);
        let counter = 0;
        for (const key of normalized.keys) {
          ids[key] = `key_${counter++}`;
        }
        doc.write(`const newResult = {};`);
        for (const key of normalized.keys) {
          const id = ids[key];
          const k = esc(key);
          const schema = shape[key];
          const isOptionalOut = schema?._zod?.optout === "optional";
          doc.write(`const ${id} = ${parseStr(key)};`);
          if (isOptionalOut) {
            doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
          } else {
            doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
          }
        }
        doc.write(`payload.value = newResult;`);
        doc.write(`return payload;`);
        const fn = doc.compile();
        return (payload, ctx) => fn(shape, payload, ctx);
      };
      let fastpass;
      const isObject2 = isObject;
      const jit = !globalConfig.jitless;
      const allowsEval2 = allowsEval;
      const fastEnabled = jit && allowsEval2.value;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject2(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
          if (!fastpass)
            fastpass = generateFastpass(def.shape);
          payload = fastpass(payload, ctx);
          if (!catchall)
            return payload;
          return handleCatchall([], input, payload, ctx, value, inst);
        }
        return superParse(payload, ctx);
      };
    });
    $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
      defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
      defineLazy(inst._zod, "values", () => {
        if (def.options.every((o) => o._zod.values)) {
          return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
        }
        return void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        if (def.options.every((o) => o._zod.pattern)) {
          const patterns = def.options.map((o) => o._zod.pattern);
          return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
        }
        return void 0;
      });
      const single = def.options.length === 1;
      const first = def.options[0]._zod.run;
      inst._zod.parse = (payload, ctx) => {
        if (single) {
          return first(payload, ctx);
        }
        let async = false;
        const results = [];
        for (const option of def.options) {
          const result = option._zod.run({
            value: payload.value,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            results.push(result);
            async = true;
          } else {
            if (result.issues.length === 0)
              return result;
            results.push(result);
          }
        }
        if (!async)
          return handleUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results2) => {
          return handleUnionResults(results2, payload, inst, ctx);
        });
      };
    });
    $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
      $ZodUnion.init(inst, def);
      def.inclusive = false;
      const single = def.options.length === 1;
      const first = def.options[0]._zod.run;
      inst._zod.parse = (payload, ctx) => {
        if (single) {
          return first(payload, ctx);
        }
        let async = false;
        const results = [];
        for (const option of def.options) {
          const result = option._zod.run({
            value: payload.value,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            results.push(result);
            async = true;
          } else {
            results.push(result);
          }
        }
        if (!async)
          return handleExclusiveUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results2) => {
          return handleExclusiveUnionResults(results2, payload, inst, ctx);
        });
      };
    });
    $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
      def.inclusive = false;
      $ZodUnion.init(inst, def);
      const _super = inst._zod.parse;
      defineLazy(inst._zod, "propValues", () => {
        const propValues = {};
        for (const option of def.options) {
          const pv = option._zod.propValues;
          if (!pv || Object.keys(pv).length === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
          for (const [k, v] of Object.entries(pv)) {
            if (!propValues[k])
              propValues[k] = /* @__PURE__ */ new Set();
            for (const val of v) {
              propValues[k].add(val);
            }
          }
        }
        return propValues;
      });
      const disc = cached(() => {
        const opts = def.options;
        const map2 = /* @__PURE__ */ new Map();
        for (const o of opts) {
          const values = o._zod.propValues?.[def.discriminator];
          if (!values || values.size === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
          for (const v of values) {
            if (map2.has(v)) {
              throw new Error(`Duplicate discriminator value "${String(v)}"`);
            }
            map2.set(v, o);
          }
        }
        return map2;
      });
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isObject(input)) {
          payload.issues.push({
            code: "invalid_type",
            expected: "object",
            input,
            inst
          });
          return payload;
        }
        const opt = disc.value.get(input?.[def.discriminator]);
        if (opt) {
          return opt._zod.run(payload, ctx);
        }
        if (def.unionFallback) {
          return _super(payload, ctx);
        }
        payload.issues.push({
          code: "invalid_union",
          errors: [],
          note: "No matching discriminator",
          discriminator: def.discriminator,
          input,
          path: [def.discriminator],
          inst
        });
        return payload;
      };
    });
    $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
        const async = left instanceof Promise || right instanceof Promise;
        if (async) {
          return Promise.all([left, right]).then(([left2, right2]) => {
            return handleIntersectionResults(payload, left2, right2);
          });
        }
        return handleIntersectionResults(payload, left, right);
      };
    });
    $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
      $ZodType.init(inst, def);
      const items = def.items;
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            input,
            inst,
            expected: "tuple",
            code: "invalid_type"
          });
          return payload;
        }
        payload.value = [];
        const proms = [];
        const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
        const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
        if (!def.rest) {
          const tooBig = input.length > items.length;
          const tooSmall = input.length < optStart - 1;
          if (tooBig || tooSmall) {
            payload.issues.push({
              ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
              input,
              inst,
              origin: "array"
            });
            return payload;
          }
        }
        let i = -1;
        for (const item of items) {
          i++;
          if (i >= input.length) {
            if (i >= optStart)
              continue;
          }
          const result = item._zod.run({
            value: input[i],
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
        if (def.rest) {
          const rest = input.slice(items.length);
          for (const el of rest) {
            i++;
            const result = def.rest._zod.run({
              value: el,
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
            } else {
              handleTupleResult(result, payload, i);
            }
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isPlainObject(input)) {
          payload.issues.push({
            expected: "record",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        const values = def.keyType._zod.values;
        if (values) {
          payload.value = {};
          const recordKeys = /* @__PURE__ */ new Set();
          for (const key of values) {
            if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
              recordKeys.add(typeof key === "number" ? key.toString() : key);
              const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result2) => {
                  if (result2.issues.length) {
                    payload.issues.push(...prefixIssues(key, result2.issues));
                  }
                  payload.value[key] = result2.value;
                }));
              } else {
                if (result.issues.length) {
                  payload.issues.push(...prefixIssues(key, result.issues));
                }
                payload.value[key] = result.value;
              }
            }
          }
          let unrecognized2;
          for (const key in input) {
            if (!recordKeys.has(key)) {
              unrecognized2 = unrecognized2 ?? [];
              unrecognized2.push(key);
            }
          }
          if (unrecognized2 && unrecognized2.length > 0) {
            payload.issues.push({
              code: "unrecognized_keys",
              input,
              inst,
              keys: unrecognized2
            });
          }
        } else {
          payload.value = {};
          for (const key of Reflect.ownKeys(input)) {
            if (key === "__proto__")
              continue;
            let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
            if (keyResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length;
            if (checkNumericKey) {
              const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
              if (retryResult instanceof Promise) {
                throw new Error("Async schemas not supported in object keys currently");
              }
              if (retryResult.issues.length === 0) {
                keyResult = retryResult;
              }
            }
            if (keyResult.issues.length) {
              if (def.mode === "loose") {
                payload.value[key] = input[key];
              } else {
                payload.issues.push({
                  code: "invalid_key",
                  origin: "record",
                  issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                  input: key,
                  path: [key],
                  inst
                });
              }
              continue;
            }
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key, result2.issues));
                }
                payload.value[keyResult.value] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key, result.issues));
              }
              payload.value[keyResult.value] = result.value;
            }
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Map)) {
          payload.issues.push({
            expected: "map",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Map();
        for (const [key, value] of input) {
          const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
          if (keyResult instanceof Promise || valueResult instanceof Promise) {
            proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
              handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
            }));
          } else {
            handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Set)) {
          payload.issues.push({
            input,
            inst,
            expected: "set",
            code: "invalid_type"
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Set();
        for (const item of input) {
          const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleSetResult(result2, payload)));
          } else
            handleSetResult(result, payload);
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
      $ZodType.init(inst, def);
      const values = getEnumValues(def.entries);
      const valuesSet = new Set(values);
      inst._zod.values = valuesSet;
      inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (valuesSet.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      if (def.values.length === 0) {
        throw new Error("Cannot create literal schema with no valid values");
      }
      const values = new Set(def.values);
      inst._zod.values = values;
      inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values: def.values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input instanceof File)
          return payload;
        payload.issues.push({
          expected: "file",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          throw new $ZodEncodeError(inst.constructor.name);
        }
        const _out = def.transform(payload.value, payload);
        if (ctx.async) {
          const output = _out instanceof Promise ? _out : Promise.resolve(_out);
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        if (_out instanceof Promise) {
          throw new $ZodAsyncError();
        }
        payload.value = _out;
        return payload;
      };
    });
    $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (def.innerType._zod.optin === "optional") {
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise)
            return result.then((r) => handleOptionalResult(r, payload.value));
          return handleOptionalResult(result, payload.value);
        }
        if (payload.value === void 0) {
          return payload;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
      $ZodOptional.init(inst, def);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
      inst._zod.parse = (payload, ctx) => {
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
      });
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === null)
          return payload;
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
          return payload;
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleDefaultResult(result2, def));
        }
        return handleDefaultResult(result, def);
      };
    });
    $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => {
        const v = def.innerType._zod.values;
        return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleNonOptionalResult(result2, inst));
        }
        return handleNonOptionalResult(result, inst);
      };
    });
    $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          throw new $ZodEncodeError("ZodSuccess");
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.issues.length === 0;
            return payload;
          });
        }
        payload.value = result.issues.length === 0;
        return payload;
      };
    });
    $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.value;
            if (result2.issues.length) {
              payload.value = def.catchValue({
                ...payload,
                error: {
                  issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
                },
                input: payload.value
              });
              payload.issues = [];
            }
            return payload;
          });
        }
        payload.value = result.value;
        if (result.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      };
    });
    $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "nan",
            code: "invalid_type"
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          const right = def.out._zod.run(payload, ctx);
          if (right instanceof Promise) {
            return right.then((right2) => handlePipeResult(right2, def.in, ctx));
          }
          return handlePipeResult(right, def.in, ctx);
        }
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handlePipeResult(left2, def.out, ctx));
        }
        return handlePipeResult(left, def.out, ctx);
      };
    });
    $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
        const direction = ctx.direction || "forward";
        if (direction === "forward") {
          const left = def.in._zod.run(payload, ctx);
          if (left instanceof Promise) {
            return left.then((left2) => handleCodecAResult(left2, def, ctx));
          }
          return handleCodecAResult(left, def, ctx);
        } else {
          const right = def.out._zod.run(payload, ctx);
          if (right instanceof Promise) {
            return right.then((right2) => handleCodecAResult(right2, def, ctx));
          }
          return handleCodecAResult(right, def, ctx);
        }
      };
    });
    $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
      defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then(handleReadonlyResult);
        }
        return handleReadonlyResult(result);
      };
    });
    $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      const regexParts = [];
      for (const part of def.parts) {
        if (typeof part === "object" && part !== null) {
          if (!part._zod.pattern) {
            throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
          }
          const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
          if (!source)
            throw new Error(`Invalid template literal part: ${part._zod.traits}`);
          const start = source.startsWith("^") ? 1 : 0;
          const end = source.endsWith("$") ? source.length - 1 : source.length;
          regexParts.push(source.slice(start, end));
        } else if (part === null || primitiveTypes.has(typeof part)) {
          regexParts.push(escapeRegex(`${part}`));
        } else {
          throw new Error(`Invalid template literal part: ${part}`);
        }
      }
      inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "string") {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "string",
            code: "invalid_type"
          });
          return payload;
        }
        inst._zod.pattern.lastIndex = 0;
        if (!inst._zod.pattern.test(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            code: "invalid_format",
            format: def.format ?? "template_literal",
            pattern: inst._zod.pattern.source
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
      $ZodType.init(inst, def);
      inst._def = def;
      inst._zod.def = def;
      inst.implement = (func) => {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        return function(...args) {
          const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
          const result = Reflect.apply(func, this, parsedArgs);
          if (inst._def.output) {
            return parse(inst._def.output, result);
          }
          return result;
        };
      };
      inst.implementAsync = (func) => {
        if (typeof func !== "function") {
          throw new Error("implementAsync() must be called with a function");
        }
        return async function(...args) {
          const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
          const result = await Reflect.apply(func, this, parsedArgs);
          if (inst._def.output) {
            return await parseAsync(inst._def.output, result);
          }
          return result;
        };
      };
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "function") {
          payload.issues.push({
            code: "invalid_type",
            expected: "function",
            input: payload.value,
            inst
          });
          return payload;
        }
        const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
        if (hasPromiseOutput) {
          payload.value = inst.implementAsync(payload.value);
        } else {
          payload.value = inst.implement(payload.value);
        }
        return payload;
      };
      inst.input = (...args) => {
        const F = inst.constructor;
        if (Array.isArray(args[0])) {
          return new F({
            type: "function",
            input: new $ZodTuple({
              type: "tuple",
              items: args[0],
              rest: args[1]
            }),
            output: inst._def.output
          });
        }
        return new F({
          type: "function",
          input: args[0],
          output: inst._def.output
        });
      };
      inst.output = (output) => {
        const F = inst.constructor;
        return new F({
          type: "function",
          input: inst._def.input,
          output
        });
      };
      return inst;
    });
    $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
      };
    });
    $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "innerType", () => def.getter());
      defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
      defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
      defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
      defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
      inst._zod.parse = (payload, ctx) => {
        const inner = inst._zod.innerType;
        return inner._zod.run(payload, ctx);
      };
    });
    $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
      $ZodCheck.init(inst, def);
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _) => {
        return payload;
      };
      inst._zod.check = (payload) => {
        const input = payload.value;
        const r = def.fn(input);
        if (r instanceof Promise) {
          return r.then((r2) => handleRefineResult(r2, payload, input, inst));
        }
        handleRefineResult(r, payload, input, inst);
        return;
      };
    });
  }
});

// node_modules/zod/v4/locales/ar.js
function ar_default() {
  return {
    localeError: error()
  };
}
var error;
var init_ar = __esm({
  "node_modules/zod/v4/locales/ar.js"() {
    init_util();
    error = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0645\u062F\u062E\u0644",
        email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
        url: "\u0631\u0627\u0628\u0637",
        emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
        ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
        cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
        cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
        base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
        base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
        json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
        e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
        jwt: "JWT",
        template_literal: "\u0645\u062F\u062E\u0644"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
            }
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
            return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
          }
          case "not_multiple_of":
            return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
          case "invalid_key":
            return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
          case "invalid_union":
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
          case "invalid_element":
            return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
          default:
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/az.js
function az_default() {
  return {
    localeError: error2()
  };
}
var error2;
var init_az = __esm({
  "node_modules/zod/v4/locales/az.js"() {
    init_util();
    error2 = () => {
      const Sizable = {
        string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "element", verb: "olmal\u0131d\u0131r" },
        set: { unit: "element", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue2.expected}, daxil olan ${received}`;
            }
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
            return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
            return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
            if (_issue.format === "ends_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
            if (_issue.format === "includes")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
            if (_issue.format === "regex")
              return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
            return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
          case "invalid_union":
            return "Yanl\u0131\u015F d\u0259y\u0259r";
          case "invalid_element":
            return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
          default:
            return `Yanl\u0131\u015F d\u0259y\u0259r`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function be_default() {
  return {
    localeError: error3()
  };
}
var error3;
var init_be = __esm({
  "node_modules/zod/v4/locales/be.js"() {
    init_util();
    error3 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0456\u043C\u0432\u0430\u043B",
            few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
            many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u044B",
            many: "\u0431\u0430\u0439\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0443\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0430\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0447\u0430\u0441",
        duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
        cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
        base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
        json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
        e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0443\u0432\u043E\u0434"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u043B\u0456\u043A",
        array: "\u043C\u0430\u0441\u0456\u045E"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
            }
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const maxValue = Number(issue2.maximum);
              const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const minValue = Number(issue2.minimum);
              const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
          case "invalid_element":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
          default:
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/bg.js
function bg_default() {
  return {
    localeError: error4()
  };
}
var error4;
var init_bg = __esm({
  "node_modules/zod/v4/locales/bg.js"() {
    init_util();
    error4 = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0432\u0445\u043E\u0434",
        email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
        base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
        json_string: "JSON \u043D\u0438\u0437",
        e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u043E\u0434"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0447\u0438\u0441\u043B\u043E",
        array: "\u043C\u0430\u0441\u0438\u0432"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
            }
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
            let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
            if (_issue.format === "emoji")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "datetime")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "date")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
            if (_issue.format === "time")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "duration")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
            return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
          default:
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ca.js
function ca_default() {
  return {
    localeError: error5()
  };
}
var error5;
var init_ca = __esm({
  "node_modules/zod/v4/locales/ca.js"() {
    init_util();
    error5 = () => {
      const Sizable = {
        string: { unit: "car\xE0cters", verb: "contenir" },
        file: { unit: "bytes", verb: "contenir" },
        array: { unit: "elements", verb: "contenir" },
        set: { unit: "elements", verb: "contenir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "entrada",
        email: "adre\xE7a electr\xF2nica",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "durada ISO",
        ipv4: "adre\xE7a IPv4",
        ipv6: "adre\xE7a IPv6",
        cidrv4: "rang IPv4",
        cidrv6: "rang IPv6",
        base64: "cadena codificada en base64",
        base64url: "cadena codificada en base64url",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Tipus inv\xE0lid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
            }
            return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
            return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
            return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Clau inv\xE0lida a ${issue2.origin}`;
          case "invalid_union":
            return "Entrada inv\xE0lida";
          // Could also be "Tipus d'unió invàlid" but "Entrada invàlida" is more general
          case "invalid_element":
            return `Element inv\xE0lid a ${issue2.origin}`;
          default:
            return `Entrada inv\xE0lida`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/cs.js
function cs_default() {
  return {
    localeError: error6()
  };
}
var error6;
var init_cs = __esm({
  "node_modules/zod/v4/locales/cs.js"() {
    init_util();
    error6 = () => {
      const Sizable = {
        string: { unit: "znak\u016F", verb: "m\xEDt" },
        file: { unit: "bajt\u016F", verb: "m\xEDt" },
        array: { unit: "prvk\u016F", verb: "m\xEDt" },
        set: { unit: "prvk\u016F", verb: "m\xEDt" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "regul\xE1rn\xED v\xFDraz",
        email: "e-mailov\xE1 adresa",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "datum a \u010Das ve form\xE1tu ISO",
        date: "datum ve form\xE1tu ISO",
        time: "\u010Das ve form\xE1tu ISO",
        duration: "doba trv\xE1n\xED ISO",
        ipv4: "IPv4 adresa",
        ipv6: "IPv6 adresa",
        cidrv4: "rozsah IPv4",
        cidrv6: "rozsah IPv6",
        base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
        base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
        json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
        e164: "\u010D\xEDslo E.164",
        jwt: "JWT",
        template_literal: "vstup"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u010D\xEDslo",
        string: "\u0159et\u011Bzec",
        function: "funkce",
        array: "pole"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue2.expected}, obdr\u017Eeno ${received}`;
            }
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
            return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
            return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
          case "invalid_union":
            return "Neplatn\xFD vstup";
          case "invalid_element":
            return `Neplatn\xE1 hodnota v ${issue2.origin}`;
          default:
            return `Neplatn\xFD vstup`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/da.js
function da_default() {
  return {
    localeError: error7()
  };
}
var error7;
var init_da = __esm({
  "node_modules/zod/v4/locales/da.js"() {
    init_util();
    error7 = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "havde" },
        file: { unit: "bytes", verb: "havde" },
        array: { unit: "elementer", verb: "indeholdt" },
        set: { unit: "elementer", verb: "indeholdt" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "e-mailadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkesl\xE6t",
        date: "ISO-dato",
        time: "ISO-klokkesl\xE6t",
        duration: "ISO-varighed",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodet streng",
        base64url: "base64url-kodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        string: "streng",
        number: "tal",
        boolean: "boolean",
        array: "liste",
        object: "objekt",
        set: "s\xE6t",
        file: "fil"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
            }
            return `Ugyldigt input: forventede ${expected}, fik ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
            return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
            if (sizing)
              return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
            if (sizing) {
              return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8gle i ${issue2.origin}`;
          case "invalid_union":
            return "Ugyldigt input: matcher ingen af de tilladte typer";
          case "invalid_element":
            return `Ugyldig v\xE6rdi i ${issue2.origin}`;
          default:
            return `Ugyldigt input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/de.js
function de_default() {
  return {
    localeError: error8()
  };
}
var error8;
var init_de = __esm({
  "node_modules/zod/v4/locales/de.js"() {
    init_util();
    error8 = () => {
      const Sizable = {
        string: { unit: "Zeichen", verb: "zu haben" },
        file: { unit: "Bytes", verb: "zu haben" },
        array: { unit: "Elemente", verb: "zu haben" },
        set: { unit: "Elemente", verb: "zu haben" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "Eingabe",
        email: "E-Mail-Adresse",
        url: "URL",
        emoji: "Emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-Datum und -Uhrzeit",
        date: "ISO-Datum",
        time: "ISO-Uhrzeit",
        duration: "ISO-Dauer",
        ipv4: "IPv4-Adresse",
        ipv6: "IPv6-Adresse",
        cidrv4: "IPv4-Bereich",
        cidrv6: "IPv6-Bereich",
        base64: "Base64-codierter String",
        base64url: "Base64-URL-codierter String",
        json_string: "JSON-String",
        e164: "E.164-Nummer",
        jwt: "JWT",
        template_literal: "Eingabe"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "Zahl",
        array: "Array"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Ung\xFCltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
            }
            return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
            return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
            return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
            }
            return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
            if (_issue.format === "ends_with")
              return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
            if (_issue.format === "includes")
              return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
            if (_issue.format === "regex")
              return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
            return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
          case "invalid_union":
            return "Ung\xFCltige Eingabe";
          case "invalid_element":
            return `Ung\xFCltiger Wert in ${issue2.origin}`;
          default:
            return `Ung\xFCltige Eingabe`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/en.js
function en_default() {
  return {
    localeError: error9()
  };
}
var error9;
var init_en = __esm({
  "node_modules/zod/v4/locales/en.js"() {
    init_util();
    error9 = () => {
      const Sizable = {
        string: { unit: "characters", verb: "to have" },
        file: { unit: "bytes", verb: "to have" },
        array: { unit: "items", verb: "to have" },
        set: { unit: "items", verb: "to have" },
        map: { unit: "entries", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        mac: "MAC address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        // Compatibility: "nan" -> "NaN" for display
        nan: "NaN"
        // All other type names omitted - they fall back to raw values via ?? operator
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            return `Invalid input: expected ${expected}, received ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
            return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Invalid string: must start with "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Invalid string: must end with "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Invalid string: must include "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Invalid string: must match pattern ${_issue.pattern}`;
            return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Invalid number: must be a multiple of ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Invalid key in ${issue2.origin}`;
          case "invalid_union":
            return "Invalid input";
          case "invalid_element":
            return `Invalid value in ${issue2.origin}`;
          default:
            return `Invalid input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/eo.js
function eo_default() {
  return {
    localeError: error10()
  };
}
var error10;
var init_eo = __esm({
  "node_modules/zod/v4/locales/eo.js"() {
    init_util();
    error10 = () => {
      const Sizable = {
        string: { unit: "karaktrojn", verb: "havi" },
        file: { unit: "bajtojn", verb: "havi" },
        array: { unit: "elementojn", verb: "havi" },
        set: { unit: "elementojn", verb: "havi" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "enigo",
        email: "retadreso",
        url: "URL",
        emoji: "emo\u011Dio",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datotempo",
        date: "ISO-dato",
        time: "ISO-tempo",
        duration: "ISO-da\u016Dro",
        ipv4: "IPv4-adreso",
        ipv6: "IPv6-adreso",
        cidrv4: "IPv4-rango",
        cidrv6: "IPv6-rango",
        base64: "64-ume kodita karaktraro",
        base64url: "URL-64-ume kodita karaktraro",
        json_string: "JSON-karaktraro",
        e164: "E.164-nombro",
        jwt: "JWT",
        template_literal: "enigo"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "nombro",
        array: "tabelo",
        null: "senvalora"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Nevalida enigo: atendi\u011Dis instanceof ${issue2.expected}, ricevi\u011Dis ${received}`;
            }
            return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
            return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
            return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
            return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Nevalida \u015Dlosilo en ${issue2.origin}`;
          case "invalid_union":
            return "Nevalida enigo";
          case "invalid_element":
            return `Nevalida valoro en ${issue2.origin}`;
          default:
            return `Nevalida enigo`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/es.js
function es_default() {
  return {
    localeError: error11()
  };
}
var error11;
var init_es = __esm({
  "node_modules/zod/v4/locales/es.js"() {
    init_util();
    error11 = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "tener" },
        file: { unit: "bytes", verb: "tener" },
        array: { unit: "elementos", verb: "tener" },
        set: { unit: "elementos", verb: "tener" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "entrada",
        email: "direcci\xF3n de correo electr\xF3nico",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "fecha y hora ISO",
        date: "fecha ISO",
        time: "hora ISO",
        duration: "duraci\xF3n ISO",
        ipv4: "direcci\xF3n IPv4",
        ipv6: "direcci\xF3n IPv6",
        cidrv4: "rango IPv4",
        cidrv6: "rango IPv6",
        base64: "cadena codificada en base64",
        base64url: "URL codificada en base64",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      const TypeDictionary = {
        nan: "NaN",
        string: "texto",
        number: "n\xFAmero",
        boolean: "booleano",
        array: "arreglo",
        object: "objeto",
        set: "conjunto",
        file: "archivo",
        date: "fecha",
        bigint: "n\xFAmero grande",
        symbol: "s\xEDmbolo",
        undefined: "indefinido",
        null: "nulo",
        function: "funci\xF3n",
        map: "mapa",
        record: "registro",
        tuple: "tupla",
        enum: "enumeraci\xF3n",
        union: "uni\xF3n",
        literal: "literal",
        promise: "promesa",
        void: "vac\xEDo",
        never: "nunca",
        unknown: "desconocido",
        any: "cualquiera"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Entrada inv\xE1lida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
            }
            return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
            return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
            if (sizing)
              return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
            if (sizing) {
              return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
            return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Llave inv\xE1lida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
          default:
            return `Entrada inv\xE1lida`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fa.js
function fa_default() {
  return {
    localeError: error12()
  };
}
var error12;
var init_fa = __esm({
  "node_modules/zod/v4/locales/fa.js"() {
    init_util();
    error12 = () => {
      const Sizable = {
        string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0648\u0631\u0648\u062F\u06CC",
        email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
        url: "URL",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
        time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        ipv4: "IPv4 \u0622\u062F\u0631\u0633",
        ipv6: "IPv6 \u0622\u062F\u0631\u0633",
        cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
        cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
        base64: "base64-encoded \u0631\u0634\u062A\u0647",
        base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
        json_string: "JSON \u0631\u0634\u062A\u0647",
        e164: "E.164 \u0639\u062F\u062F",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u06CC"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0639\u062F\u062F",
        array: "\u0622\u0631\u0627\u06CC\u0647"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
            }
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
          }
          case "invalid_value":
            if (issue2.values.length === 1) {
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
            }
            return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
            }
            if (_issue.format === "ends_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
            }
            if (_issue.format === "includes") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
            }
            if (_issue.format === "regex") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
            }
            return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          }
          case "not_multiple_of":
            return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
          case "unrecognized_keys":
            return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
          case "invalid_union":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          case "invalid_element":
            return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
          default:
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fi.js
function fi_default() {
  return {
    localeError: error13()
  };
}
var error13;
var init_fi = __esm({
  "node_modules/zod/v4/locales/fi.js"() {
    init_util();
    error13 = () => {
      const Sizable = {
        string: { unit: "merkki\xE4", subject: "merkkijonon" },
        file: { unit: "tavua", subject: "tiedoston" },
        array: { unit: "alkiota", subject: "listan" },
        set: { unit: "alkiota", subject: "joukon" },
        number: { unit: "", subject: "luvun" },
        bigint: { unit: "", subject: "suuren kokonaisluvun" },
        int: { unit: "", subject: "kokonaisluvun" },
        date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "s\xE4\xE4nn\xF6llinen lauseke",
        email: "s\xE4hk\xF6postiosoite",
        url: "URL-osoite",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-aikaleima",
        date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
        time: "ISO-aika",
        duration: "ISO-kesto",
        ipv4: "IPv4-osoite",
        ipv6: "IPv6-osoite",
        cidrv4: "IPv4-alue",
        cidrv6: "IPv6-alue",
        base64: "base64-koodattu merkkijono",
        base64url: "base64url-koodattu merkkijono",
        json_string: "JSON-merkkijono",
        e164: "E.164-luku",
        jwt: "JWT",
        template_literal: "templaattimerkkijono"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
            }
            return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
            return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
            if (_issue.format === "regex") {
              return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
            }
            return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return "Virheellinen avain tietueessa";
          case "invalid_union":
            return "Virheellinen unioni";
          case "invalid_element":
            return "Virheellinen arvo joukossa";
          default:
            return `Virheellinen sy\xF6te`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fr.js
function fr_default() {
  return {
    localeError: error14()
  };
}
var error14;
var init_fr = __esm({
  "node_modules/zod/v4/locales/fr.js"() {
    init_util();
    error14 = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "entr\xE9e",
        email: "adresse e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date et heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "nombre",
        array: "tableau"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Entr\xE9e invalide : instanceof ${issue2.expected} attendu, ${received} re\xE7u`;
            }
            return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
            return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
            return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue2.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue2.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fr-CA.js
function fr_CA_default() {
  return {
    localeError: error15()
  };
}
var error15;
var init_fr_CA = __esm({
  "node_modules/zod/v4/locales/fr-CA.js"() {
    init_util();
    error15 = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "entr\xE9e",
        email: "adresse courriel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date-heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Entr\xE9e invalide : attendu instanceof ${issue2.expected}, re\xE7u ${received}`;
            }
            return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
            return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u2264" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
            return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u2265" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue2.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue2.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/he.js
function he_default() {
  return {
    localeError: error16()
  };
}
var error16;
var init_he = __esm({
  "node_modules/zod/v4/locales/he.js"() {
    init_util();
    error16 = () => {
      const TypeNames = {
        string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
        number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
        boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
        bigint: { label: "BigInt", gender: "m" },
        date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
        array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
        object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
        null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
        undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
        symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
        function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
        map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
        set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
        file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
        promise: { label: "Promise", gender: "m" },
        NaN: { label: "NaN", gender: "m" },
        unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
        value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
      };
      const Sizable = {
        string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
        file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
        array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
        set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
        number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
        // no unit
      };
      const typeEntry = (t) => t ? TypeNames[t] : void 0;
      const typeLabel = (t) => {
        const e = typeEntry(t);
        if (e)
          return e.label;
        return t ?? TypeNames.unknown.label;
      };
      const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
      const verbFor = (t) => {
        const e = typeEntry(t);
        const gender = e?.gender ?? "m";
        return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
      };
      const getSizing = (origin) => {
        if (!origin)
          return null;
        return Sizable[origin] ?? null;
      };
      const FormatDictionary = {
        regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
        url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
        emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
        uuid: { label: "UUID", gender: "m" },
        nanoid: { label: "nanoid", gender: "m" },
        guid: { label: "GUID", gender: "m" },
        cuid: { label: "cuid", gender: "m" },
        cuid2: { label: "cuid2", gender: "m" },
        ulid: { label: "ULID", gender: "m" },
        xid: { label: "XID", gender: "m" },
        ksuid: { label: "KSUID", gender: "m" },
        datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
        date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
        time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
        duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
        ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
        ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
        cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
        cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
        base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
        base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
        json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
        e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
        jwt: { label: "JWT", gender: "m" },
        ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expectedKey = issue2.expected;
            const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
            }
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
          }
          case "invalid_value": {
            if (issue2.values.length === 1) {
              return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
            }
            const stringified = issue2.values.map((v) => stringifyPrimitive(v));
            if (issue2.values.length === 2) {
              return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
            }
            const lastValue = stringified[stringified.length - 1];
            const restValues = stringified.slice(0, -1).join(", ");
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
          }
          case "too_big": {
            const sizing = getSizing(issue2.origin);
            const subject = withDefinite(issue2.origin ?? "value");
            if (issue2.origin === "string") {
              return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
            }
            if (issue2.origin === "number") {
              const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
              return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
            }
            if (issue2.origin === "array" || issue2.origin === "set") {
              const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
              const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
              return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
            }
            const adj = issue2.inclusive ? "<=" : "<";
            const be = verbFor(issue2.origin ?? "value");
            if (sizing?.unit) {
              return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
            }
            return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const sizing = getSizing(issue2.origin);
            const subject = withDefinite(issue2.origin ?? "value");
            if (issue2.origin === "string") {
              return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
            }
            if (issue2.origin === "number") {
              const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
            }
            if (issue2.origin === "array" || issue2.origin === "set") {
              const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
              if (issue2.minimum === 1 && issue2.inclusive) {
                const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
                return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
              }
              const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
            }
            const adj = issue2.inclusive ? ">=" : ">";
            const be = verbFor(issue2.origin ?? "value");
            if (sizing?.unit) {
              return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
            const nounEntry = FormatDictionary[_issue.format];
            const noun = nounEntry?.label ?? _issue.format;
            const gender = nounEntry?.gender ?? "m";
            const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
            return `${noun} \u05DC\u05D0 ${adjective}`;
          }
          case "not_multiple_of":
            return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key": {
            return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
          }
          case "invalid_union":
            return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
          case "invalid_element": {
            const place = withDefinite(issue2.origin ?? "array");
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
          }
          default:
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/hu.js
function hu_default() {
  return {
    localeError: error17()
  };
}
var error17;
var init_hu = __esm({
  "node_modules/zod/v4/locales/hu.js"() {
    init_util();
    error17 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "legyen" },
        file: { unit: "byte", verb: "legyen" },
        array: { unit: "elem", verb: "legyen" },
        set: { unit: "elem", verb: "legyen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "bemenet",
        email: "email c\xEDm",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO id\u0151b\xE9lyeg",
        date: "ISO d\xE1tum",
        time: "ISO id\u0151",
        duration: "ISO id\u0151intervallum",
        ipv4: "IPv4 c\xEDm",
        ipv6: "IPv6 c\xEDm",
        cidrv4: "IPv4 tartom\xE1ny",
        cidrv6: "IPv6 tartom\xE1ny",
        base64: "base64-k\xF3dolt string",
        base64url: "base64url-k\xF3dolt string",
        json_string: "JSON string",
        e164: "E.164 sz\xE1m",
        jwt: "JWT",
        template_literal: "bemenet"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "sz\xE1m",
        array: "t\xF6mb"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue2.expected}, a kapott \xE9rt\xE9k ${received}`;
            }
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
            return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
            return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
            if (_issue.format === "ends_with")
              return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
            if (_issue.format === "includes")
              return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
            if (_issue.format === "regex")
              return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
            return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
          case "unrecognized_keys":
            return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
          case "invalid_union":
            return "\xC9rv\xE9nytelen bemenet";
          case "invalid_element":
            return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
          default:
            return `\xC9rv\xE9nytelen bemenet`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
}
function hy_default() {
  return {
    localeError: error18()
  };
}
var error18;
var init_hy = __esm({
  "node_modules/zod/v4/locales/hy.js"() {
    init_util();
    error18 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0576\u0577\u0561\u0576",
            many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
          },
          verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
        },
        file: {
          unit: {
            one: "\u0562\u0561\u0575\u0569",
            many: "\u0562\u0561\u0575\u0569\u0565\u0580"
          },
          verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
        },
        array: {
          unit: {
            one: "\u057F\u0561\u0580\u0580",
            many: "\u057F\u0561\u0580\u0580\u0565\u0580"
          },
          verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
        },
        set: {
          unit: {
            one: "\u057F\u0561\u0580\u0580",
            many: "\u057F\u0561\u0580\u0580\u0565\u0580"
          },
          verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0574\u0578\u0582\u057F\u0584",
        email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
        url: "URL",
        emoji: "\u0567\u0574\u0578\u057B\u056B",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
        date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
        time: "ISO \u056A\u0561\u0574",
        duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
        ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
        ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
        cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
        cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
        base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
        base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
        json_string: "JSON \u057F\u0578\u0572",
        e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
        jwt: "JWT",
        template_literal: "\u0574\u0578\u0582\u057F\u0584"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0569\u056B\u057E",
        array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue2.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
            }
            return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue2.values[1])}`;
            return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const maxValue = Number(issue2.maximum);
              const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
              return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.maximum.toString()} ${unit}`;
            }
            return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const minValue = Number(issue2.minimum);
              const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
              return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.minimum.toString()} ${unit}`;
            }
            return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056C\u056B\u0576\u056B ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
            if (_issue.format === "ends_with")
              return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
            if (_issue.format === "includes")
              return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
            return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue2.divisor}-\u056B`;
          case "unrecognized_keys":
            return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue2.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
          case "invalid_union":
            return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
          case "invalid_element":
            return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
          default:
            return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/id.js
function id_default() {
  return {
    localeError: error19()
  };
}
var error19;
var init_id = __esm({
  "node_modules/zod/v4/locales/id.js"() {
    init_util();
    error19 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "memiliki" },
        file: { unit: "byte", verb: "memiliki" },
        array: { unit: "item", verb: "memiliki" },
        set: { unit: "item", verb: "memiliki" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "alamat email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tanggal dan waktu format ISO",
        date: "tanggal format ISO",
        time: "jam format ISO",
        duration: "durasi format ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "rentang alamat IPv4",
        cidrv6: "rentang alamat IPv6",
        base64: "string dengan enkode base64",
        base64url: "string dengan enkode base64url",
        json_string: "string JSON",
        e164: "angka E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
            }
            return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
            return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak valid: harus menyertakan "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
          }
          case "not_multiple_of":
            return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak valid di ${issue2.origin}`;
          case "invalid_union":
            return "Input tidak valid";
          case "invalid_element":
            return `Nilai tidak valid di ${issue2.origin}`;
          default:
            return `Input tidak valid`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/is.js
function is_default() {
  return {
    localeError: error20()
  };
}
var error20;
var init_is = __esm({
  "node_modules/zod/v4/locales/is.js"() {
    init_util();
    error20 = () => {
      const Sizable = {
        string: { unit: "stafi", verb: "a\xF0 hafa" },
        file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
        array: { unit: "hluti", verb: "a\xF0 hafa" },
        set: { unit: "hluti", verb: "a\xF0 hafa" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "gildi",
        email: "netfang",
        url: "vefsl\xF3\xF0",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dagsetning og t\xEDmi",
        date: "ISO dagsetning",
        time: "ISO t\xEDmi",
        duration: "ISO t\xEDmalengd",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded strengur",
        base64url: "base64url-encoded strengur",
        json_string: "JSON strengur",
        e164: "E.164 t\xF6lugildi",
        jwt: "JWT",
        template_literal: "gildi"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "n\xFAmer",
        array: "fylki"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue2.expected}`;
            }
            return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
            return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
            return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
            return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Rangur lykill \xED ${issue2.origin}`;
          case "invalid_union":
            return "Rangt gildi";
          case "invalid_element":
            return `Rangt gildi \xED ${issue2.origin}`;
          default:
            return `Rangt gildi`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/it.js
function it_default() {
  return {
    localeError: error21()
  };
}
var error21;
var init_it = __esm({
  "node_modules/zod/v4/locales/it.js"() {
    init_util();
    error21 = () => {
      const Sizable = {
        string: { unit: "caratteri", verb: "avere" },
        file: { unit: "byte", verb: "avere" },
        array: { unit: "elementi", verb: "avere" },
        set: { unit: "elementi", verb: "avere" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "indirizzo email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e ora ISO",
        date: "data ISO",
        time: "ora ISO",
        duration: "durata ISO",
        ipv4: "indirizzo IPv4",
        ipv6: "indirizzo IPv6",
        cidrv4: "intervallo IPv4",
        cidrv6: "intervallo IPv6",
        base64: "stringa codificata in base64",
        base64url: "URL codificata in base64",
        json_string: "stringa JSON",
        e164: "numero E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "numero",
        array: "vettore"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
            }
            return `Input non valido: atteso ${expected}, ricevuto ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
            return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
            return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Stringa non valida: deve includere "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
            return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Chiave non valida in ${issue2.origin}`;
          case "invalid_union":
            return "Input non valido";
          case "invalid_element":
            return `Valore non valido in ${issue2.origin}`;
          default:
            return `Input non valido`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ja.js
function ja_default() {
  return {
    localeError: error22()
  };
}
var error22;
var init_ja = __esm({
  "node_modules/zod/v4/locales/ja.js"() {
    init_util();
    error22 = () => {
      const Sizable = {
        string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
        file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
        array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
        set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u5165\u529B\u5024",
        email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
        url: "URL",
        emoji: "\u7D75\u6587\u5B57",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u6642",
        date: "ISO\u65E5\u4ED8",
        time: "ISO\u6642\u523B",
        duration: "ISO\u671F\u9593",
        ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
        ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
        cidrv4: "IPv4\u7BC4\u56F2",
        cidrv6: "IPv6\u7BC4\u56F2",
        base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        json_string: "JSON\u6587\u5B57\u5217",
        e164: "E.164\u756A\u53F7",
        jwt: "JWT",
        template_literal: "\u5165\u529B\u5024"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u6570\u5024",
        array: "\u914D\u5217"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
            }
            return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
            return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "ends_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "includes")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "regex")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "unrecognized_keys":
            return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
          case "invalid_union":
            return "\u7121\u52B9\u306A\u5165\u529B";
          case "invalid_element":
            return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
          default:
            return `\u7121\u52B9\u306A\u5165\u529B`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ka.js
function ka_default() {
  return {
    localeError: error23()
  };
}
var error23;
var init_ka = __esm({
  "node_modules/zod/v4/locales/ka.js"() {
    init_util();
    error23 = () => {
      const Sizable = {
        string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
        email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        url: "URL",
        emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
        date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
        time: "\u10D3\u10E0\u10DD",
        duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
        ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
        cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
        base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
        jwt: "JWT",
        template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
        string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
        function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
        array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
            }
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
            }
            if (_issue.format === "ends_with")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
            if (_issue.format === "includes")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
            if (_issue.format === "regex")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
          case "unrecognized_keys":
            return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
          case "invalid_union":
            return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
          case "invalid_element":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
          default:
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/km.js
function km_default() {
  return {
    localeError: error24()
  };
}
var error24;
var init_km = __esm({
  "node_modules/zod/v4/locales/km.js"() {
    init_util();
    error24 = () => {
      const Sizable = {
        string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
        email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
        url: "URL",
        emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
        date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
        time: "\u1798\u17C9\u17C4\u1784 ISO",
        duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
        ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
        base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
        json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
        e164: "\u179B\u17C1\u1781 E.164",
        jwt: "JWT",
        template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u179B\u17C1\u1781",
        array: "\u17A2\u17B6\u179A\u17C1 (Array)",
        null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
            }
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
            return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
            return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
            return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
          case "invalid_union":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
          case "invalid_element":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
          default:
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
var init_kh = __esm({
  "node_modules/zod/v4/locales/kh.js"() {
    init_km();
  }
});

// node_modules/zod/v4/locales/ko.js
function ko_default() {
  return {
    localeError: error25()
  };
}
var error25;
var init_ko = __esm({
  "node_modules/zod/v4/locales/ko.js"() {
    init_util();
    error25 = () => {
      const Sizable = {
        string: { unit: "\uBB38\uC790", verb: "to have" },
        file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
        array: { unit: "\uAC1C", verb: "to have" },
        set: { unit: "\uAC1C", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\uC785\uB825",
        email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
        url: "URL",
        emoji: "\uC774\uBAA8\uC9C0",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
        date: "ISO \uB0A0\uC9DC",
        time: "ISO \uC2DC\uAC04",
        duration: "ISO \uAE30\uAC04",
        ipv4: "IPv4 \uC8FC\uC18C",
        ipv6: "IPv6 \uC8FC\uC18C",
        cidrv4: "IPv4 \uBC94\uC704",
        cidrv6: "IPv6 \uBC94\uC704",
        base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        json_string: "JSON \uBB38\uC790\uC5F4",
        e164: "E.164 \uBC88\uD638",
        jwt: "JWT",
        template_literal: "\uC785\uB825"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
            }
            return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "too_big": {
            const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
            const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue2.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing)
              return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
            const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue2.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing) {
              return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
            }
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
            }
            if (_issue.format === "ends_with")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "includes")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "regex")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "unrecognized_keys":
            return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
          case "invalid_union":
            return `\uC798\uBABB\uB41C \uC785\uB825`;
          case "invalid_element":
            return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
          default:
            return `\uC798\uBABB\uB41C \uC785\uB825`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/lt.js
function getUnitTypeFromNumber(number4) {
  const abs = Math.abs(number4);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
function lt_default() {
  return {
    localeError: error26()
  };
}
var capitalizeFirstCharacter, error26;
var init_lt = __esm({
  "node_modules/zod/v4/locales/lt.js"() {
    init_util();
    capitalizeFirstCharacter = (text2) => {
      return text2.charAt(0).toUpperCase() + text2.slice(1);
    };
    error26 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "simbolis",
            few: "simboliai",
            many: "simboli\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
              notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
            },
            bigger: {
              inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
              notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
            }
          }
        },
        file: {
          unit: {
            one: "baitas",
            few: "baitai",
            many: "bait\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi b\u016Bti ne didesnis kaip",
              notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
            },
            bigger: {
              inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
              notInclusive: "turi b\u016Bti didesnis kaip"
            }
          }
        },
        array: {
          unit: {
            one: "element\u0105",
            few: "elementus",
            many: "element\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi tur\u0117ti ne daugiau kaip",
              notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
            },
            bigger: {
              inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
              notInclusive: "turi tur\u0117ti daugiau kaip"
            }
          }
        },
        set: {
          unit: {
            one: "element\u0105",
            few: "elementus",
            many: "element\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi tur\u0117ti ne daugiau kaip",
              notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
            },
            bigger: {
              inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
              notInclusive: "turi tur\u0117ti daugiau kaip"
            }
          }
        }
      };
      function getSizing(origin, unitType, inclusive, targetShouldBe) {
        const result = Sizable[origin] ?? null;
        if (result === null)
          return result;
        return {
          unit: result.unit[unitType],
          verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
        };
      }
      const FormatDictionary = {
        regex: "\u012Fvestis",
        email: "el. pa\u0161to adresas",
        url: "URL",
        emoji: "jaustukas",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO data ir laikas",
        date: "ISO data",
        time: "ISO laikas",
        duration: "ISO trukm\u0117",
        ipv4: "IPv4 adresas",
        ipv6: "IPv6 adresas",
        cidrv4: "IPv4 tinklo prefiksas (CIDR)",
        cidrv6: "IPv6 tinklo prefiksas (CIDR)",
        base64: "base64 u\u017Ekoduota eilut\u0117",
        base64url: "base64url u\u017Ekoduota eilut\u0117",
        json_string: "JSON eilut\u0117",
        e164: "E.164 numeris",
        jwt: "JWT",
        template_literal: "\u012Fvestis"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "skai\u010Dius",
        bigint: "sveikasis skai\u010Dius",
        string: "eilut\u0117",
        boolean: "login\u0117 reik\u0161m\u0117",
        undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
        function: "funkcija",
        symbol: "simbolis",
        array: "masyvas",
        object: "objektas",
        null: "nulin\u0117 reik\u0161m\u0117"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue2.expected}`;
            }
            return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
            return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
          case "too_big": {
            const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
            const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
            if (sizing?.verb)
              return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
            const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
          }
          case "too_small": {
            const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
            const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
            if (sizing?.verb)
              return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
            const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
            return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
          case "unrecognized_keys":
            return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return "Rastas klaidingas raktas";
          case "invalid_union":
            return "Klaidinga \u012Fvestis";
          case "invalid_element": {
            const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
          }
          default:
            return "Klaidinga \u012Fvestis";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/mk.js
function mk_default() {
  return {
    localeError: error27()
  };
}
var error27;
var init_mk = __esm({
  "node_modules/zod/v4/locales/mk.js"() {
    init_util();
    error27 = () => {
      const Sizable = {
        string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0432\u043D\u0435\u0441",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u045F\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0443\u043C",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
        cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
        cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
        base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        json_string: "JSON \u043D\u0438\u0437\u0430",
        e164: "E.164 \u0431\u0440\u043E\u0458",
        jwt: "JWT",
        template_literal: "\u0432\u043D\u0435\u0441"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0431\u0440\u043E\u0458",
        array: "\u043D\u0438\u0437\u0430"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
            }
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
            return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
          case "invalid_union":
            return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
          case "invalid_element":
            return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
          default:
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ms.js
function ms_default() {
  return {
    localeError: error28()
  };
}
var error28;
var init_ms = __esm({
  "node_modules/zod/v4/locales/ms.js"() {
    init_util();
    error28 = () => {
      const Sizable = {
        string: { unit: "aksara", verb: "mempunyai" },
        file: { unit: "bait", verb: "mempunyai" },
        array: { unit: "elemen", verb: "mempunyai" },
        set: { unit: "elemen", verb: "mempunyai" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "alamat e-mel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tarikh masa ISO",
        date: "tarikh ISO",
        time: "masa ISO",
        duration: "tempoh ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "julat IPv4",
        cidrv6: "julat IPv6",
        base64: "string dikodkan base64",
        base64url: "string dikodkan base64url",
        json_string: "string JSON",
        e164: "nombor E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "nombor"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
            }
            return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
            return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
          }
          case "not_multiple_of":
            return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak sah dalam ${issue2.origin}`;
          case "invalid_union":
            return "Input tidak sah";
          case "invalid_element":
            return `Nilai tidak sah dalam ${issue2.origin}`;
          default:
            return `Input tidak sah`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/nl.js
function nl_default() {
  return {
    localeError: error29()
  };
}
var error29;
var init_nl = __esm({
  "node_modules/zod/v4/locales/nl.js"() {
    init_util();
    error29 = () => {
      const Sizable = {
        string: { unit: "tekens", verb: "heeft" },
        file: { unit: "bytes", verb: "heeft" },
        array: { unit: "elementen", verb: "heeft" },
        set: { unit: "elementen", verb: "heeft" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "invoer",
        email: "emailadres",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum en tijd",
        date: "ISO datum",
        time: "ISO tijd",
        duration: "ISO duur",
        ipv4: "IPv4-adres",
        ipv6: "IPv6-adres",
        cidrv4: "IPv4-bereik",
        cidrv6: "IPv6-bereik",
        base64: "base64-gecodeerde tekst",
        base64url: "base64 URL-gecodeerde tekst",
        json_string: "JSON string",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "invoer"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "getal"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
            }
            return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
            return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
            if (sizing)
              return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
            return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
            if (sizing) {
              return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
            }
            return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
            }
            if (_issue.format === "ends_with")
              return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
            if (_issue.format === "includes")
              return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
            if (_issue.format === "regex")
              return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
            return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
          case "unrecognized_keys":
            return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ongeldige key in ${issue2.origin}`;
          case "invalid_union":
            return "Ongeldige invoer";
          case "invalid_element":
            return `Ongeldige waarde in ${issue2.origin}`;
          default:
            return `Ongeldige invoer`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/no.js
function no_default() {
  return {
    localeError: error30()
  };
}
var error30;
var init_no = __esm({
  "node_modules/zod/v4/locales/no.js"() {
    init_util();
    error30 = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "\xE5 ha" },
        file: { unit: "bytes", verb: "\xE5 ha" },
        array: { unit: "elementer", verb: "\xE5 inneholde" },
        set: { unit: "elementer", verb: "\xE5 inneholde" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "e-postadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkeslett",
        date: "ISO-dato",
        time: "ISO-klokkeslett",
        duration: "ISO-varighet",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spekter",
        cidrv6: "IPv6-spekter",
        base64: "base64-enkodet streng",
        base64url: "base64url-enkodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "tall",
        array: "liste"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
            }
            return `Ugyldig input: forventet ${expected}, fikk ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
            return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8kkel i ${issue2.origin}`;
          case "invalid_union":
            return "Ugyldig input";
          case "invalid_element":
            return `Ugyldig verdi i ${issue2.origin}`;
          default:
            return `Ugyldig input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ota.js
function ota_default() {
  return {
    localeError: error31()
  };
}
var error31;
var init_ota = __esm({
  "node_modules/zod/v4/locales/ota.js"() {
    init_util();
    error31 = () => {
      const Sizable = {
        string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
        set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "giren",
        email: "epostag\xE2h",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO heng\xE2m\u0131",
        date: "ISO tarihi",
        time: "ISO zaman\u0131",
        duration: "ISO m\xFCddeti",
        ipv4: "IPv4 ni\u015F\xE2n\u0131",
        ipv6: "IPv6 ni\u015F\xE2n\u0131",
        cidrv4: "IPv4 menzili",
        cidrv6: "IPv6 menzili",
        base64: "base64-\u015Fifreli metin",
        base64url: "base64url-\u015Fifreli metin",
        json_string: "JSON metin",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "giren"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "numara",
        array: "saf",
        null: "gayb"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `F\xE2sit giren: umulan instanceof ${issue2.expected}, al\u0131nan ${received}`;
            }
            return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
            return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
            return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
            }
            return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
            if (_issue.format === "ends_with")
              return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
            if (_issue.format === "includes")
              return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
            if (_issue.format === "regex")
              return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
            return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
          case "invalid_union":
            return "Giren tan\u0131namad\u0131.";
          case "invalid_element":
            return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
          default:
            return `K\u0131ymet tan\u0131namad\u0131.`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ps.js
function ps_default() {
  return {
    localeError: error32()
  };
}
var error32;
var init_ps = __esm({
  "node_modules/zod/v4/locales/ps.js"() {
    init_util();
    error32 = () => {
      const Sizable = {
        string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
        array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0648\u0631\u0648\u062F\u064A",
        email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
        date: "\u0646\u06D0\u067C\u0647",
        time: "\u0648\u062E\u062A",
        duration: "\u0645\u0648\u062F\u0647",
        ipv4: "\u062F IPv4 \u067E\u062A\u0647",
        ipv6: "\u062F IPv6 \u067E\u062A\u0647",
        cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
        cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
        base64: "base64-encoded \u0645\u062A\u0646",
        base64url: "base64url-encoded \u0645\u062A\u0646",
        json_string: "JSON \u0645\u062A\u0646",
        e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u064A"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0639\u062F\u062F",
        array: "\u0627\u0631\u06D0"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
            }
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
          }
          case "invalid_value":
            if (issue2.values.length === 1) {
              return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
            }
            return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
            }
            if (_issue.format === "ends_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
            }
            if (_issue.format === "includes") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
            }
            if (_issue.format === "regex") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
            }
            return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
          }
          case "not_multiple_of":
            return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
          case "unrecognized_keys":
            return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
          case "invalid_union":
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
          case "invalid_element":
            return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
          default:
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/pl.js
function pl_default() {
  return {
    localeError: error33()
  };
}
var error33;
var init_pl = __esm({
  "node_modules/zod/v4/locales/pl.js"() {
    init_util();
    error33 = () => {
      const Sizable = {
        string: { unit: "znak\xF3w", verb: "mie\u0107" },
        file: { unit: "bajt\xF3w", verb: "mie\u0107" },
        array: { unit: "element\xF3w", verb: "mie\u0107" },
        set: { unit: "element\xF3w", verb: "mie\u0107" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "wyra\u017Cenie",
        email: "adres email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i godzina w formacie ISO",
        date: "data w formacie ISO",
        time: "godzina w formacie ISO",
        duration: "czas trwania ISO",
        ipv4: "adres IPv4",
        ipv6: "adres IPv6",
        cidrv4: "zakres IPv4",
        cidrv6: "zakres IPv6",
        base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
        base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
        json_string: "ci\u0105g znak\xF3w w formacie JSON",
        e164: "liczba E.164",
        jwt: "JWT",
        template_literal: "wej\u015Bcie"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "liczba",
        array: "tablica"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
            }
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
            return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
            return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
          case "invalid_union":
            return "Nieprawid\u0142owe dane wej\u015Bciowe";
          case "invalid_element":
            return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
          default:
            return `Nieprawid\u0142owe dane wej\u015Bciowe`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/pt.js
function pt_default() {
  return {
    localeError: error34()
  };
}
var error34;
var init_pt = __esm({
  "node_modules/zod/v4/locales/pt.js"() {
    init_util();
    error34 = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "ter" },
        file: { unit: "bytes", verb: "ter" },
        array: { unit: "itens", verb: "ter" },
        set: { unit: "itens", verb: "ter" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "padr\xE3o",
        email: "endere\xE7o de e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "dura\xE7\xE3o ISO",
        ipv4: "endere\xE7o IPv4",
        ipv6: "endere\xE7o IPv6",
        cidrv4: "faixa de IPv4",
        cidrv6: "faixa de IPv6",
        base64: "texto codificado em base64",
        base64url: "URL codificada em base64",
        json_string: "texto JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "n\xFAmero",
        null: "nulo"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Tipo inv\xE1lido: esperado instanceof ${issue2.expected}, recebido ${received}`;
            }
            return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
            return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue2.format} inv\xE1lido`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Chave inv\xE1lida em ${issue2.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido em ${issue2.origin}`;
          default:
            return `Campo inv\xE1lido`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function ru_default() {
  return {
    localeError: error35()
  };
}
var error35;
var init_ru = __esm({
  "node_modules/zod/v4/locales/ru.js"() {
    init_util();
    error35 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0438\u043C\u0432\u043E\u043B",
            few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
            many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u0430",
            many: "\u0431\u0430\u0439\u0442"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0432\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u044F",
        duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
        base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
        json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0432\u043E\u0434"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0447\u0438\u0441\u043B\u043E",
        array: "\u043C\u0430\u0441\u0441\u0438\u0432"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
            }
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const maxValue = Number(issue2.maximum);
              const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const minValue = Number(issue2.minimum);
              const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
          default:
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/sl.js
function sl_default() {
  return {
    localeError: error36()
  };
}
var error36;
var init_sl = __esm({
  "node_modules/zod/v4/locales/sl.js"() {
    init_util();
    error36 = () => {
      const Sizable = {
        string: { unit: "znakov", verb: "imeti" },
        file: { unit: "bajtov", verb: "imeti" },
        array: { unit: "elementov", verb: "imeti" },
        set: { unit: "elementov", verb: "imeti" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "vnos",
        email: "e-po\u0161tni naslov",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum in \u010Das",
        date: "ISO datum",
        time: "ISO \u010Das",
        duration: "ISO trajanje",
        ipv4: "IPv4 naslov",
        ipv6: "IPv6 naslov",
        cidrv4: "obseg IPv4",
        cidrv6: "obseg IPv6",
        base64: "base64 kodiran niz",
        base64url: "base64url kodiran niz",
        json_string: "JSON niz",
        e164: "E.164 \u0161tevilka",
        jwt: "JWT",
        template_literal: "vnos"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0161tevilo",
        array: "tabela"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue2.expected}, prejeto ${received}`;
            }
            return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
            return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
            return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
            return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Neveljaven klju\u010D v ${issue2.origin}`;
          case "invalid_union":
            return "Neveljaven vnos";
          case "invalid_element":
            return `Neveljavna vrednost v ${issue2.origin}`;
          default:
            return "Neveljaven vnos";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/sv.js
function sv_default() {
  return {
    localeError: error37()
  };
}
var error37;
var init_sv = __esm({
  "node_modules/zod/v4/locales/sv.js"() {
    init_util();
    error37 = () => {
      const Sizable = {
        string: { unit: "tecken", verb: "att ha" },
        file: { unit: "bytes", verb: "att ha" },
        array: { unit: "objekt", verb: "att inneh\xE5lla" },
        set: { unit: "objekt", verb: "att inneh\xE5lla" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "regulj\xE4rt uttryck",
        email: "e-postadress",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datum och tid",
        date: "ISO-datum",
        time: "ISO-tid",
        duration: "ISO-varaktighet",
        ipv4: "IPv4-intervall",
        ipv6: "IPv6-intervall",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodad str\xE4ng",
        base64url: "base64url-kodad str\xE4ng",
        json_string: "JSON-str\xE4ng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "mall-literal"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "antal",
        array: "lista"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue2.expected}, fick ${received}`;
            }
            return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
            return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
            }
            return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
            return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
          case "invalid_union":
            return "Ogiltig input";
          case "invalid_element":
            return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
          default:
            return `Ogiltig input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ta.js
function ta_default() {
  return {
    localeError: error38()
  };
}
var error38;
var init_ta = __esm({
  "node_modules/zod/v4/locales/ta.js"() {
    init_util();
    error38 = () => {
      const Sizable = {
        string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
        email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
        time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
        ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
        e164: "E.164 \u0B8E\u0BA3\u0BCD",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0B8E\u0BA3\u0BCD",
        array: "\u0B85\u0BA3\u0BBF",
        null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
            }
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "ends_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "includes")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "regex")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          case "unrecognized_keys":
            return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
          case "invalid_union":
            return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
          case "invalid_element":
            return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
          default:
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/th.js
function th_default() {
  return {
    localeError: error39()
  };
}
var error39;
var init_th = __esm({
  "node_modules/zod/v4/locales/th.js"() {
    init_util();
    error39 = () => {
      const Sizable = {
        string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
        email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
        url: "URL",
        emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
        time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
        ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
        cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
        cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
        base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
        base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
        json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
        e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
        jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
        template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
        array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
        null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
            }
            return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
            return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
            if (_issue.format === "regex")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
          case "unrecognized_keys":
            return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
          case "invalid_union":
            return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
          case "invalid_element":
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
          default:
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/tr.js
function tr_default() {
  return {
    localeError: error40()
  };
}
var error40;
var init_tr = __esm({
  "node_modules/zod/v4/locales/tr.js"() {
    init_util();
    error40 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "olmal\u0131" },
        file: { unit: "bayt", verb: "olmal\u0131" },
        array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
        set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "girdi",
        email: "e-posta adresi",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO tarih ve saat",
        date: "ISO tarih",
        time: "ISO saat",
        duration: "ISO s\xFCre",
        ipv4: "IPv4 adresi",
        ipv6: "IPv6 adresi",
        cidrv4: "IPv4 aral\u0131\u011F\u0131",
        cidrv6: "IPv6 aral\u0131\u011F\u0131",
        base64: "base64 ile \u015Fifrelenmi\u015F metin",
        base64url: "base64url ile \u015Fifrelenmi\u015F metin",
        json_string: "JSON dizesi",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "\u015Eablon dizesi"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue2.expected}, al\u0131nan ${received}`;
            }
            return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
            return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
            return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
            if (_issue.format === "ends_with")
              return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
            if (_issue.format === "includes")
              return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
            if (_issue.format === "regex")
              return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
            return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
          case "invalid_union":
            return "Ge\xE7ersiz de\u011Fer";
          case "invalid_element":
            return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
          default:
            return `Ge\xE7ersiz de\u011Fer`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/uk.js
function uk_default() {
  return {
    localeError: error41()
  };
}
var error41;
var init_uk = __esm({
  "node_modules/zod/v4/locales/uk.js"() {
    init_util();
    error41 = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
        date: "\u0434\u0430\u0442\u0430 ISO",
        time: "\u0447\u0430\u0441 ISO",
        duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
        ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
        ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
        cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
        cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
        base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
        base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
        json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0447\u0438\u0441\u043B\u043E",
        array: "\u043C\u0430\u0441\u0438\u0432"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
            }
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
          case "invalid_element":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
          default:
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
var init_ua = __esm({
  "node_modules/zod/v4/locales/ua.js"() {
    init_uk();
  }
});

// node_modules/zod/v4/locales/ur.js
function ur_default() {
  return {
    localeError: error42()
  };
}
var error42;
var init_ur = __esm({
  "node_modules/zod/v4/locales/ur.js"() {
    init_util();
    error42 = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
        file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
        array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
        set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0627\u0646 \u067E\u0679",
        email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
        uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
        nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
        ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
        xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
        ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
        date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
        time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
        duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
        ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
        cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
        base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
        e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
        jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
        template_literal: "\u0627\u0646 \u067E\u0679"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0646\u0645\u0628\u0631",
        array: "\u0622\u0631\u06D2",
        null: "\u0646\u0644"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
            }
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            }
            return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            }
            if (_issue.format === "ends_with")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "includes")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "regex")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          case "unrecognized_keys":
            return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
          case "invalid_key":
            return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
          case "invalid_union":
            return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
          case "invalid_element":
            return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
          default:
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/uz.js
function uz_default() {
  return {
    localeError: error43()
  };
}
var error43;
var init_uz = __esm({
  "node_modules/zod/v4/locales/uz.js"() {
    init_util();
    error43 = () => {
      const Sizable = {
        string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
        file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
        array: { unit: "element", verb: "bo\u2018lishi kerak" },
        set: { unit: "element", verb: "bo\u2018lishi kerak" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "kirish",
        email: "elektron pochta manzili",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO sana va vaqti",
        date: "ISO sana",
        time: "ISO vaqt",
        duration: "ISO davomiylik",
        ipv4: "IPv4 manzil",
        ipv6: "IPv6 manzil",
        mac: "MAC manzil",
        cidrv4: "IPv4 diapazon",
        cidrv6: "IPv6 diapazon",
        base64: "base64 kodlangan satr",
        base64url: "base64url kodlangan satr",
        json_string: "JSON satr",
        e164: "E.164 raqam",
        jwt: "JWT",
        template_literal: "kirish"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "raqam",
        array: "massiv"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
            }
            return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
            return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
            return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
            }
            return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
            if (_issue.format === "ends_with")
              return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
            if (_issue.format === "includes")
              return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
            if (_issue.format === "regex")
              return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
            return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Noto\u2018g\u2018ri raqam: ${issue2.divisor} ning karralisi bo\u2018lishi kerak`;
          case "unrecognized_keys":
            return `Noma\u2019lum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} dagi kalit noto\u2018g\u2018ri`;
          case "invalid_union":
            return "Noto\u2018g\u2018ri kirish";
          case "invalid_element":
            return `${issue2.origin} da noto\u2018g\u2018ri qiymat`;
          default:
            return `Noto\u2018g\u2018ri kirish`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/vi.js
function vi_default() {
  return {
    localeError: error44()
  };
}
var error44;
var init_vi = __esm({
  "node_modules/zod/v4/locales/vi.js"() {
    init_util();
    error44 = () => {
      const Sizable = {
        string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
        file: { unit: "byte", verb: "c\xF3" },
        array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
        set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0111\u1EA7u v\xE0o",
        email: "\u0111\u1ECBa ch\u1EC9 email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ng\xE0y gi\u1EDD ISO",
        date: "ng\xE0y ISO",
        time: "gi\u1EDD ISO",
        duration: "kho\u1EA3ng th\u1EDDi gian ISO",
        ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
        ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
        cidrv4: "d\u1EA3i IPv4",
        cidrv6: "d\u1EA3i IPv6",
        base64: "chu\u1ED7i m\xE3 h\xF3a base64",
        base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
        json_string: "chu\u1ED7i JSON",
        e164: "s\u1ED1 E.164",
        jwt: "JWT",
        template_literal: "\u0111\u1EA7u v\xE0o"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "s\u1ED1",
        array: "m\u1EA3ng"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
            }
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
            return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
            return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
          }
          case "not_multiple_of":
            return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
          case "invalid_union":
            return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
          case "invalid_element":
            return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
          default:
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/zh-CN.js
function zh_CN_default() {
  return {
    localeError: error45()
  };
}
var error45;
var init_zh_CN = __esm({
  "node_modules/zod/v4/locales/zh-CN.js"() {
    init_util();
    error45 = () => {
      const Sizable = {
        string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
        file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
        array: { unit: "\u9879", verb: "\u5305\u542B" },
        set: { unit: "\u9879", verb: "\u5305\u542B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u8F93\u5165",
        email: "\u7535\u5B50\u90AE\u4EF6",
        url: "URL",
        emoji: "\u8868\u60C5\u7B26\u53F7",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u671F\u65F6\u95F4",
        date: "ISO\u65E5\u671F",
        time: "ISO\u65F6\u95F4",
        duration: "ISO\u65F6\u957F",
        ipv4: "IPv4\u5730\u5740",
        ipv6: "IPv6\u5730\u5740",
        cidrv4: "IPv4\u7F51\u6BB5",
        cidrv6: "IPv6\u7F51\u6BB5",
        base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
        base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
        json_string: "JSON\u5B57\u7B26\u4E32",
        e164: "E.164\u53F7\u7801",
        jwt: "JWT",
        template_literal: "\u8F93\u5165"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u6570\u5B57",
        array: "\u6570\u7EC4",
        null: "\u7A7A\u503C(null)"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
            }
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
            return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
            return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
            if (_issue.format === "ends_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
            if (_issue.format === "includes")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
            return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
          case "unrecognized_keys":
            return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
          case "invalid_union":
            return "\u65E0\u6548\u8F93\u5165";
          case "invalid_element":
            return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
          default:
            return `\u65E0\u6548\u8F93\u5165`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/zh-TW.js
function zh_TW_default() {
  return {
    localeError: error46()
  };
}
var error46;
var init_zh_TW = __esm({
  "node_modules/zod/v4/locales/zh-TW.js"() {
    init_util();
    error46 = () => {
      const Sizable = {
        string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
        file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
        array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
        set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u8F38\u5165",
        email: "\u90F5\u4EF6\u5730\u5740",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u65E5\u671F\u6642\u9593",
        date: "ISO \u65E5\u671F",
        time: "ISO \u6642\u9593",
        duration: "ISO \u671F\u9593",
        ipv4: "IPv4 \u4F4D\u5740",
        ipv6: "IPv6 \u4F4D\u5740",
        cidrv4: "IPv4 \u7BC4\u570D",
        cidrv6: "IPv6 \u7BC4\u570D",
        base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
        base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
        json_string: "JSON \u5B57\u4E32",
        e164: "E.164 \u6578\u503C",
        jwt: "JWT",
        template_literal: "\u8F38\u5165"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
            }
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
            return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
            return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
            }
            if (_issue.format === "ends_with")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
            if (_issue.format === "includes")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
            return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
          case "unrecognized_keys":
            return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
          case "invalid_union":
            return "\u7121\u6548\u7684\u8F38\u5165\u503C";
          case "invalid_element":
            return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
          default:
            return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/yo.js
function yo_default() {
  return {
    localeError: error47()
  };
}
var error47;
var init_yo = __esm({
  "node_modules/zod/v4/locales/yo.js"() {
    init_util();
    error47 = () => {
      const Sizable = {
        string: { unit: "\xE0mi", verb: "n\xED" },
        file: { unit: "bytes", verb: "n\xED" },
        array: { unit: "nkan", verb: "n\xED" },
        set: { unit: "nkan", verb: "n\xED" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
        email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\xE0k\xF3k\xF2 ISO",
        date: "\u1ECDj\u1ECD\u0301 ISO",
        time: "\xE0k\xF3k\xF2 ISO",
        duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
        ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
        ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
        cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
        cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
        base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
        base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
        json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
        e164: "n\u1ECD\u0301mb\xE0 E.164",
        jwt: "JWT",
        template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "n\u1ECD\u0301mb\xE0",
        array: "akop\u1ECD"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
            }
            return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
            return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
            return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
            return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
            return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
          case "unrecognized_keys":
            return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
          case "invalid_union":
            return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
          case "invalid_element":
            return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
          default:
            return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  hy: () => hy_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  uz: () => uz_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});
var init_locales = __esm({
  "node_modules/zod/v4/locales/index.js"() {
    init_ar();
    init_az();
    init_be();
    init_bg();
    init_ca();
    init_cs();
    init_da();
    init_de();
    init_en();
    init_eo();
    init_es();
    init_fa();
    init_fi();
    init_fr();
    init_fr_CA();
    init_he();
    init_hu();
    init_hy();
    init_id();
    init_is();
    init_it();
    init_ja();
    init_ka();
    init_kh();
    init_km();
    init_ko();
    init_lt();
    init_mk();
    init_ms();
    init_nl();
    init_no();
    init_ota();
    init_ps();
    init_pl();
    init_pt();
    init_ru();
    init_sl();
    init_sv();
    init_ta();
    init_th();
    init_tr();
    init_ua();
    init_uk();
    init_ur();
    init_uz();
    init_vi();
    init_zh_CN();
    init_zh_TW();
    init_yo();
  }
});

// node_modules/zod/v4/core/registries.js
function registry() {
  return new $ZodRegistry();
}
var _a, $output, $input, $ZodRegistry, globalRegistry;
var init_registries = __esm({
  "node_modules/zod/v4/core/registries.js"() {
    $output = Symbol("ZodOutput");
    $input = Symbol("ZodInput");
    $ZodRegistry = class {
      constructor() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
      }
      add(schema, ..._meta) {
        const meta3 = _meta[0];
        this._map.set(schema, meta3);
        if (meta3 && typeof meta3 === "object" && "id" in meta3) {
          this._idmap.set(meta3.id, schema);
        }
        return this;
      }
      clear() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
        return this;
      }
      remove(schema) {
        const meta3 = this._map.get(schema);
        if (meta3 && typeof meta3 === "object" && "id" in meta3) {
          this._idmap.delete(meta3.id);
        }
        this._map.delete(schema);
        return this;
      }
      get(schema) {
        const p = schema._zod.parent;
        if (p) {
          const pm = { ...this.get(p) ?? {} };
          delete pm.id;
          const f = { ...pm, ...this._map.get(schema) };
          return Object.keys(f).length ? f : void 0;
        }
        return this._map.get(schema);
      }
      has(schema) {
        return this._map.has(schema);
      }
    };
    (_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
    globalRegistry = globalThis.__zod_globalRegistry;
  }
});

// node_modules/zod/v4/core/api.js
// @__NO_SIDE_EFFECTS__
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _positive(params) {
  return /* @__PURE__ */ _gt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _negative(params) {
  return /* @__PURE__ */ _lt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonpositive(params) {
  return /* @__PURE__ */ _lte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonnegative(params) {
  return /* @__PURE__ */ _gte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _xor(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
// @__NO_SIDE_EFFECTS__
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
// @__NO_SIDE_EFFECTS__
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
// @__NO_SIDE_EFFECTS__
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
// @__NO_SIDE_EFFECTS__
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
// @__NO_SIDE_EFFECTS__
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
// @__NO_SIDE_EFFECTS__
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  const ch = /* @__PURE__ */ _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
// @__NO_SIDE_EFFECTS__
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: ((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    }),
    reverseTransform: ((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }),
    error: params.error
  });
  return codec2;
}
// @__NO_SIDE_EFFECTS__
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
var TimePrecision;
var init_api = __esm({
  "node_modules/zod/v4/core/api.js"() {
    init_checks();
    init_registries();
    init_schemas();
    init_util();
    TimePrecision = {
      Any: null,
      Minute: -1,
      Second: 0,
      Millisecond: 3,
      Microsecond: 6
    };
  }
});

// node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a3;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta3 = ctx.metadataRegistry.get(schema);
  if (meta3)
    Object.assign(result.schema, meta3);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a3 = result.schema).default ?? (_a3.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = /* @__PURE__ */ new Map();
  for (const entry of ctx.seen.entries()) {
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry[0]);
    }
  }
  const makeURI = (entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref && refSeen.def) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {
  } else {
  }
  if (ctx.external?.uri) {
    const id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {
  } else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod, createStandardJSONSchemaMethod;
var init_to_json_schema = __esm({
  "node_modules/zod/v4/core/to-json-schema.js"() {
    init_registries();
    createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
      const ctx = initializeContext({ ...params, processors });
      process2(schema, ctx);
      extractDefs(ctx, schema);
      return finalize(ctx, schema);
    };
    createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
      const { libraryOptions, target } = params ?? {};
      const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
      process2(schema, ctx);
      extractDefs(ctx, schema);
      return finalize(ctx, schema);
    };
  }
});

// node_modules/zod/v4/core/json-schema-processors.js
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    const registry2 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry of registry2._idmap.entries()) {
      const [_, schema] = entry;
      process2(schema, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry2,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry of registry2._idmap.entries()) {
      const [key, schema] = entry;
      extractDefs(ctx2, schema);
      schemas[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}
var formatMap, stringProcessor, numberProcessor, booleanProcessor, bigintProcessor, symbolProcessor, nullProcessor, undefinedProcessor, voidProcessor, neverProcessor, anyProcessor, unknownProcessor, dateProcessor, enumProcessor, literalProcessor, nanProcessor, templateLiteralProcessor, fileProcessor, successProcessor, customProcessor, functionProcessor, transformProcessor, mapProcessor, setProcessor, arrayProcessor, objectProcessor, unionProcessor, intersectionProcessor, tupleProcessor, recordProcessor, nullableProcessor, nonoptionalProcessor, defaultProcessor, prefaultProcessor, catchProcessor, pipeProcessor, readonlyProcessor, promiseProcessor, optionalProcessor, lazyProcessor, allProcessors;
var init_json_schema_processors = __esm({
  "node_modules/zod/v4/core/json-schema-processors.js"() {
    init_to_json_schema();
    init_util();
    formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    };
    stringProcessor = (schema, ctx, _json, _params) => {
      const json3 = _json;
      json3.type = "string";
      const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
      if (typeof minimum === "number")
        json3.minLength = minimum;
      if (typeof maximum === "number")
        json3.maxLength = maximum;
      if (format) {
        json3.format = formatMap[format] ?? format;
        if (json3.format === "")
          delete json3.format;
        if (format === "time") {
          delete json3.format;
        }
      }
      if (contentEncoding)
        json3.contentEncoding = contentEncoding;
      if (patterns && patterns.size > 0) {
        const regexes = [...patterns];
        if (regexes.length === 1)
          json3.pattern = regexes[0].source;
        else if (regexes.length > 1) {
          json3.allOf = [
            ...regexes.map((regex) => ({
              ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
              pattern: regex.source
            }))
          ];
        }
      }
    };
    numberProcessor = (schema, ctx, _json, _params) => {
      const json3 = _json;
      const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
      if (typeof format === "string" && format.includes("int"))
        json3.type = "integer";
      else
        json3.type = "number";
      if (typeof exclusiveMinimum === "number") {
        if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
          json3.minimum = exclusiveMinimum;
          json3.exclusiveMinimum = true;
        } else {
          json3.exclusiveMinimum = exclusiveMinimum;
        }
      }
      if (typeof minimum === "number") {
        json3.minimum = minimum;
        if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
          if (exclusiveMinimum >= minimum)
            delete json3.minimum;
          else
            delete json3.exclusiveMinimum;
        }
      }
      if (typeof exclusiveMaximum === "number") {
        if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
          json3.maximum = exclusiveMaximum;
          json3.exclusiveMaximum = true;
        } else {
          json3.exclusiveMaximum = exclusiveMaximum;
        }
      }
      if (typeof maximum === "number") {
        json3.maximum = maximum;
        if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
          if (exclusiveMaximum <= maximum)
            delete json3.maximum;
          else
            delete json3.exclusiveMaximum;
        }
      }
      if (typeof multipleOf === "number")
        json3.multipleOf = multipleOf;
    };
    booleanProcessor = (_schema, _ctx, json3, _params) => {
      json3.type = "boolean";
    };
    bigintProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt cannot be represented in JSON Schema");
      }
    };
    symbolProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Symbols cannot be represented in JSON Schema");
      }
    };
    nullProcessor = (_schema, ctx, json3, _params) => {
      if (ctx.target === "openapi-3.0") {
        json3.type = "string";
        json3.nullable = true;
        json3.enum = [null];
      } else {
        json3.type = "null";
      }
    };
    undefinedProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Undefined cannot be represented in JSON Schema");
      }
    };
    voidProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Void cannot be represented in JSON Schema");
      }
    };
    neverProcessor = (_schema, _ctx, json3, _params) => {
      json3.not = {};
    };
    anyProcessor = (_schema, _ctx, _json, _params) => {
    };
    unknownProcessor = (_schema, _ctx, _json, _params) => {
    };
    dateProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Date cannot be represented in JSON Schema");
      }
    };
    enumProcessor = (schema, _ctx, json3, _params) => {
      const def = schema._zod.def;
      const values = getEnumValues(def.entries);
      if (values.every((v) => typeof v === "number"))
        json3.type = "number";
      if (values.every((v) => typeof v === "string"))
        json3.type = "string";
      json3.enum = values;
    };
    literalProcessor = (schema, ctx, json3, _params) => {
      const def = schema._zod.def;
      const vals = [];
      for (const val of def.values) {
        if (val === void 0) {
          if (ctx.unrepresentable === "throw") {
            throw new Error("Literal `undefined` cannot be represented in JSON Schema");
          } else {
          }
        } else if (typeof val === "bigint") {
          if (ctx.unrepresentable === "throw") {
            throw new Error("BigInt literals cannot be represented in JSON Schema");
          } else {
            vals.push(Number(val));
          }
        } else {
          vals.push(val);
        }
      }
      if (vals.length === 0) {
      } else if (vals.length === 1) {
        const val = vals[0];
        json3.type = val === null ? "null" : typeof val;
        if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
          json3.enum = [val];
        } else {
          json3.const = val;
        }
      } else {
        if (vals.every((v) => typeof v === "number"))
          json3.type = "number";
        if (vals.every((v) => typeof v === "string"))
          json3.type = "string";
        if (vals.every((v) => typeof v === "boolean"))
          json3.type = "boolean";
        if (vals.every((v) => v === null))
          json3.type = "null";
        json3.enum = vals;
      }
    };
    nanProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("NaN cannot be represented in JSON Schema");
      }
    };
    templateLiteralProcessor = (schema, _ctx, json3, _params) => {
      const _json = json3;
      const pattern = schema._zod.pattern;
      if (!pattern)
        throw new Error("Pattern not found in template literal");
      _json.type = "string";
      _json.pattern = pattern.source;
    };
    fileProcessor = (schema, _ctx, json3, _params) => {
      const _json = json3;
      const file2 = {
        type: "string",
        format: "binary",
        contentEncoding: "binary"
      };
      const { minimum, maximum, mime } = schema._zod.bag;
      if (minimum !== void 0)
        file2.minLength = minimum;
      if (maximum !== void 0)
        file2.maxLength = maximum;
      if (mime) {
        if (mime.length === 1) {
          file2.contentMediaType = mime[0];
          Object.assign(_json, file2);
        } else {
          Object.assign(_json, file2);
          _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
        }
      } else {
        Object.assign(_json, file2);
      }
    };
    successProcessor = (_schema, _ctx, json3, _params) => {
      json3.type = "boolean";
    };
    customProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Custom types cannot be represented in JSON Schema");
      }
    };
    functionProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Function types cannot be represented in JSON Schema");
      }
    };
    transformProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Transforms cannot be represented in JSON Schema");
      }
    };
    mapProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Map cannot be represented in JSON Schema");
      }
    };
    setProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Set cannot be represented in JSON Schema");
      }
    };
    arrayProcessor = (schema, ctx, _json, params) => {
      const json3 = _json;
      const def = schema._zod.def;
      const { minimum, maximum } = schema._zod.bag;
      if (typeof minimum === "number")
        json3.minItems = minimum;
      if (typeof maximum === "number")
        json3.maxItems = maximum;
      json3.type = "array";
      json3.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
    };
    objectProcessor = (schema, ctx, _json, params) => {
      const json3 = _json;
      const def = schema._zod.def;
      json3.type = "object";
      json3.properties = {};
      const shape = def.shape;
      for (const key in shape) {
        json3.properties[key] = process2(shape[key], ctx, {
          ...params,
          path: [...params.path, "properties", key]
        });
      }
      const allKeys = new Set(Object.keys(shape));
      const requiredKeys = new Set([...allKeys].filter((key) => {
        const v = def.shape[key]._zod;
        if (ctx.io === "input") {
          return v.optin === void 0;
        } else {
          return v.optout === void 0;
        }
      }));
      if (requiredKeys.size > 0) {
        json3.required = Array.from(requiredKeys);
      }
      if (def.catchall?._zod.def.type === "never") {
        json3.additionalProperties = false;
      } else if (!def.catchall) {
        if (ctx.io === "output")
          json3.additionalProperties = false;
      } else if (def.catchall) {
        json3.additionalProperties = process2(def.catchall, ctx, {
          ...params,
          path: [...params.path, "additionalProperties"]
        });
      }
    };
    unionProcessor = (schema, ctx, json3, params) => {
      const def = schema._zod.def;
      const isExclusive = def.inclusive === false;
      const options = def.options.map((x, i) => process2(x, ctx, {
        ...params,
        path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
      }));
      if (isExclusive) {
        json3.oneOf = options;
      } else {
        json3.anyOf = options;
      }
    };
    intersectionProcessor = (schema, ctx, json3, params) => {
      const def = schema._zod.def;
      const a = process2(def.left, ctx, {
        ...params,
        path: [...params.path, "allOf", 0]
      });
      const b = process2(def.right, ctx, {
        ...params,
        path: [...params.path, "allOf", 1]
      });
      const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
      const allOf = [
        ...isSimpleIntersection(a) ? a.allOf : [a],
        ...isSimpleIntersection(b) ? b.allOf : [b]
      ];
      json3.allOf = allOf;
    };
    tupleProcessor = (schema, ctx, _json, params) => {
      const json3 = _json;
      const def = schema._zod.def;
      json3.type = "array";
      const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
      const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
      const prefixItems = def.items.map((x, i) => process2(x, ctx, {
        ...params,
        path: [...params.path, prefixPath, i]
      }));
      const rest = def.rest ? process2(def.rest, ctx, {
        ...params,
        path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
      }) : null;
      if (ctx.target === "draft-2020-12") {
        json3.prefixItems = prefixItems;
        if (rest) {
          json3.items = rest;
        }
      } else if (ctx.target === "openapi-3.0") {
        json3.items = {
          anyOf: prefixItems
        };
        if (rest) {
          json3.items.anyOf.push(rest);
        }
        json3.minItems = prefixItems.length;
        if (!rest) {
          json3.maxItems = prefixItems.length;
        }
      } else {
        json3.items = prefixItems;
        if (rest) {
          json3.additionalItems = rest;
        }
      }
      const { minimum, maximum } = schema._zod.bag;
      if (typeof minimum === "number")
        json3.minItems = minimum;
      if (typeof maximum === "number")
        json3.maxItems = maximum;
    };
    recordProcessor = (schema, ctx, _json, params) => {
      const json3 = _json;
      const def = schema._zod.def;
      json3.type = "object";
      const keyType = def.keyType;
      const keyBag = keyType._zod.bag;
      const patterns = keyBag?.patterns;
      if (def.mode === "loose" && patterns && patterns.size > 0) {
        const valueSchema = process2(def.valueType, ctx, {
          ...params,
          path: [...params.path, "patternProperties", "*"]
        });
        json3.patternProperties = {};
        for (const pattern of patterns) {
          json3.patternProperties[pattern.source] = valueSchema;
        }
      } else {
        if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
          json3.propertyNames = process2(def.keyType, ctx, {
            ...params,
            path: [...params.path, "propertyNames"]
          });
        }
        json3.additionalProperties = process2(def.valueType, ctx, {
          ...params,
          path: [...params.path, "additionalProperties"]
        });
      }
      const keyValues = keyType._zod.values;
      if (keyValues) {
        const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
        if (validKeyValues.length > 0) {
          json3.required = validKeyValues;
        }
      }
    };
    nullableProcessor = (schema, ctx, json3, params) => {
      const def = schema._zod.def;
      const inner = process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      if (ctx.target === "openapi-3.0") {
        seen.ref = def.innerType;
        json3.nullable = true;
      } else {
        json3.anyOf = [inner, { type: "null" }];
      }
    };
    nonoptionalProcessor = (schema, ctx, _json, params) => {
      const def = schema._zod.def;
      process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = def.innerType;
    };
    defaultProcessor = (schema, ctx, json3, params) => {
      const def = schema._zod.def;
      process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = def.innerType;
      json3.default = JSON.parse(JSON.stringify(def.defaultValue));
    };
    prefaultProcessor = (schema, ctx, json3, params) => {
      const def = schema._zod.def;
      process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = def.innerType;
      if (ctx.io === "input")
        json3._prefault = JSON.parse(JSON.stringify(def.defaultValue));
    };
    catchProcessor = (schema, ctx, json3, params) => {
      const def = schema._zod.def;
      process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = def.innerType;
      let catchValue;
      try {
        catchValue = def.catchValue(void 0);
      } catch {
        throw new Error("Dynamic catch values are not supported in JSON Schema");
      }
      json3.default = catchValue;
    };
    pipeProcessor = (schema, ctx, _json, params) => {
      const def = schema._zod.def;
      const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
      process2(innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = innerType;
    };
    readonlyProcessor = (schema, ctx, json3, params) => {
      const def = schema._zod.def;
      process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = def.innerType;
      json3.readOnly = true;
    };
    promiseProcessor = (schema, ctx, _json, params) => {
      const def = schema._zod.def;
      process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = def.innerType;
    };
    optionalProcessor = (schema, ctx, _json, params) => {
      const def = schema._zod.def;
      process2(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = def.innerType;
    };
    lazyProcessor = (schema, ctx, _json, params) => {
      const innerType = schema._zod.innerType;
      process2(innerType, ctx, params);
      const seen = ctx.seen.get(schema);
      seen.ref = innerType;
    };
    allProcessors = {
      string: stringProcessor,
      number: numberProcessor,
      boolean: booleanProcessor,
      bigint: bigintProcessor,
      symbol: symbolProcessor,
      null: nullProcessor,
      undefined: undefinedProcessor,
      void: voidProcessor,
      never: neverProcessor,
      any: anyProcessor,
      unknown: unknownProcessor,
      date: dateProcessor,
      enum: enumProcessor,
      literal: literalProcessor,
      nan: nanProcessor,
      template_literal: templateLiteralProcessor,
      file: fileProcessor,
      success: successProcessor,
      custom: customProcessor,
      function: functionProcessor,
      transform: transformProcessor,
      map: mapProcessor,
      set: setProcessor,
      array: arrayProcessor,
      object: objectProcessor,
      union: unionProcessor,
      intersection: intersectionProcessor,
      tuple: tupleProcessor,
      record: recordProcessor,
      nullable: nullableProcessor,
      nonoptional: nonoptionalProcessor,
      default: defaultProcessor,
      prefault: prefaultProcessor,
      catch: catchProcessor,
      pipe: pipeProcessor,
      readonly: readonlyProcessor,
      promise: promiseProcessor,
      optional: optionalProcessor,
      lazy: lazyProcessor
    };
  }
});

// node_modules/zod/v4/core/json-schema-generator.js
var JSONSchemaGenerator;
var init_json_schema_generator = __esm({
  "node_modules/zod/v4/core/json-schema-generator.js"() {
    init_json_schema_processors();
    init_to_json_schema();
    JSONSchemaGenerator = class {
      /** @deprecated Access via ctx instead */
      get metadataRegistry() {
        return this.ctx.metadataRegistry;
      }
      /** @deprecated Access via ctx instead */
      get target() {
        return this.ctx.target;
      }
      /** @deprecated Access via ctx instead */
      get unrepresentable() {
        return this.ctx.unrepresentable;
      }
      /** @deprecated Access via ctx instead */
      get override() {
        return this.ctx.override;
      }
      /** @deprecated Access via ctx instead */
      get io() {
        return this.ctx.io;
      }
      /** @deprecated Access via ctx instead */
      get counter() {
        return this.ctx.counter;
      }
      set counter(value) {
        this.ctx.counter = value;
      }
      /** @deprecated Access via ctx instead */
      get seen() {
        return this.ctx.seen;
      }
      constructor(params) {
        let normalizedTarget = params?.target ?? "draft-2020-12";
        if (normalizedTarget === "draft-4")
          normalizedTarget = "draft-04";
        if (normalizedTarget === "draft-7")
          normalizedTarget = "draft-07";
        this.ctx = initializeContext({
          processors: allProcessors,
          target: normalizedTarget,
          ...params?.metadata && { metadata: params.metadata },
          ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
          ...params?.override && { override: params.override },
          ...params?.io && { io: params.io }
        });
      }
      /**
       * Process a schema to prepare it for JSON Schema generation.
       * This must be called before emit().
       */
      process(schema, _params = { path: [], schemaPath: [] }) {
        return process2(schema, this.ctx, _params);
      }
      /**
       * Emit the final JSON Schema after processing.
       * Must call process() first.
       */
      emit(schema, _params) {
        if (_params) {
          if (_params.cycles)
            this.ctx.cycles = _params.cycles;
          if (_params.reused)
            this.ctx.reused = _params.reused;
          if (_params.external)
            this.ctx.external = _params.external;
        }
        extractDefs(this.ctx, schema);
        const result = finalize(this.ctx, schema);
        const { "~standard": _, ...plainResult } = result;
        return plainResult;
      }
    };
  }
});

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};
var init_json_schema = __esm({
  "node_modules/zod/v4/core/json-schema.js"() {
  }
});

// node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMAC: () => $ZodMAC,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $ZodXor: () => $ZodXor,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _mac: () => _mac,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _slugify: () => _slugify,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  _xor: () => _xor,
  clone: () => clone,
  config: () => config,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  describe: () => describe,
  encode: () => encode,
  encodeAsync: () => encodeAsync,
  extractDefs: () => extractDefs,
  finalize: () => finalize,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  initializeContext: () => initializeContext,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  meta: () => meta,
  parse: () => parse,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  process: () => process2,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});
var init_core2 = __esm({
  "node_modules/zod/v4/core/index.js"() {
    init_core();
    init_parse();
    init_errors();
    init_schemas();
    init_checks();
    init_versions();
    init_util();
    init_regexes();
    init_locales();
    init_registries();
    init_doc();
    init_api();
    init_to_json_schema();
    init_json_schema_processors();
    init_json_schema_generator();
    init_json_schema();
  }
});

// node_modules/zod/v4/classic/checks.js
var checks_exports2 = {};
__export(checks_exports2, {
  endsWith: () => _endsWith,
  gt: () => _gt,
  gte: () => _gte,
  includes: () => _includes,
  length: () => _length,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  negative: () => _negative,
  nonnegative: () => _nonnegative,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  overwrite: () => _overwrite,
  positive: () => _positive,
  property: () => _property,
  regex: () => _regex,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  trim: () => _trim,
  uppercase: () => _uppercase
});
var init_checks2 = __esm({
  "node_modules/zod/v4/classic/checks.js"() {
    init_core2();
  }
});

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
function date2(params) {
  return _isoDate(ZodISODate, params);
}
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
var ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration;
var init_iso = __esm({
  "node_modules/zod/v4/classic/iso.js"() {
    init_core2();
    init_schemas2();
    ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
      $ZodISODateTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
      $ZodISODate.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
      $ZodISOTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
      $ZodISODuration.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
  }
});

// node_modules/zod/v4/classic/errors.js
var initializer2, ZodError, ZodRealError;
var init_errors2 = __esm({
  "node_modules/zod/v4/classic/errors.js"() {
    init_core2();
    init_core2();
    init_util();
    initializer2 = (inst, issues) => {
      $ZodError.init(inst, issues);
      inst.name = "ZodError";
      Object.defineProperties(inst, {
        format: {
          value: (mapper) => formatError(inst, mapper)
          // enumerable: false,
        },
        flatten: {
          value: (mapper) => flattenError(inst, mapper)
          // enumerable: false,
        },
        addIssue: {
          value: (issue2) => {
            inst.issues.push(issue2);
            inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
          }
          // enumerable: false,
        },
        addIssues: {
          value: (issues2) => {
            inst.issues.push(...issues2);
            inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
          }
          // enumerable: false,
        },
        isEmpty: {
          get() {
            return inst.issues.length === 0;
          }
          // enumerable: false,
        }
      });
    };
    ZodError = $constructor("ZodError", initializer2);
    ZodRealError = $constructor("ZodError", initializer2, {
      Parent: Error
    });
  }
});

// node_modules/zod/v4/classic/parse.js
var parse2, parseAsync2, safeParse2, safeParseAsync2, encode2, decode2, encodeAsync2, decodeAsync2, safeEncode2, safeDecode2, safeEncodeAsync2, safeDecodeAsync2;
var init_parse2 = __esm({
  "node_modules/zod/v4/classic/parse.js"() {
    init_core2();
    init_errors2();
    parse2 = /* @__PURE__ */ _parse(ZodRealError);
    parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
    safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
    safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
    encode2 = /* @__PURE__ */ _encode(ZodRealError);
    decode2 = /* @__PURE__ */ _decode(ZodRealError);
    encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
    decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
    safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
    safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
    safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
    safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
  }
});

// node_modules/zod/v4/classic/schemas.js
var schemas_exports2 = {};
__export(schemas_exports2, {
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodIntersection: () => ZodIntersection,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  codec: () => codec,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  float32: () => float32,
  float64: () => float64,
  function: () => _function,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  literal: () => literal,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map,
  meta: () => meta2,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  never: () => never,
  nonoptional: () => nonoptional,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  prefault: () => prefault,
  preprocess: () => preprocess,
  promise: () => promise,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  set: () => set,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  transform: () => transform,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});
function string2(params) {
  return _string(ZodString, params);
}
function email2(params) {
  return _email(ZodEmail, params);
}
function guid2(params) {
  return _guid(ZodGUID, params);
}
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
function ulid2(params) {
  return _ulid(ZodULID, params);
}
function xid2(params) {
  return _xid(ZodXID, params);
}
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
function mac2(params) {
  return _mac(ZodMAC, params);
}
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
function base642(params) {
  return _base64(ZodBase64, params);
}
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
function e1642(params) {
  return _e164(ZodE164, params);
}
function jwt(params) {
  return _jwt(ZodJWT, params);
}
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
function number2(params) {
  return _number(ZodNumber, params);
}
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
function _null3(params) {
  return _null2(ZodNull, params);
}
function any() {
  return _any(ZodAny);
}
function unknown() {
  return _unknown(ZodUnknown);
}
function never(params) {
  return _never(ZodNever, params);
}
function _void2(params) {
  return _void(ZodVoid, params);
}
function date3(params) {
  return _date(ZodDate, params);
}
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...util_exports.normalizeParams(params)
  });
}
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports.normalizeParams(params)
  });
}
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
function file(params) {
  return _file(ZodFile, params);
}
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function nan(params) {
  return _nan(ZodNaN, params);
}
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
var ZodType, _ZodString, ZodString, ZodStringFormat, ZodEmail, ZodGUID, ZodUUID, ZodURL, ZodEmoji, ZodNanoID, ZodCUID, ZodCUID2, ZodULID, ZodXID, ZodKSUID, ZodIPv4, ZodMAC, ZodIPv6, ZodCIDRv4, ZodCIDRv6, ZodBase64, ZodBase64URL, ZodE164, ZodJWT, ZodCustomStringFormat, ZodNumber, ZodNumberFormat, ZodBoolean, ZodBigInt, ZodBigIntFormat, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodDate, ZodArray, ZodObject, ZodUnion, ZodXor, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodEnum, ZodLiteral, ZodFile, ZodTransform, ZodOptional, ZodExactOptional, ZodNullable, ZodDefault, ZodPrefault, ZodNonOptional, ZodSuccess, ZodCatch, ZodNaN, ZodPipe, ZodCodec, ZodReadonly, ZodTemplateLiteral, ZodLazy, ZodPromise, ZodFunction, ZodCustom, describe2, meta2, stringbool;
var init_schemas2 = __esm({
  "node_modules/zod/v4/classic/schemas.js"() {
    init_core2();
    init_core2();
    init_json_schema_processors();
    init_to_json_schema();
    init_checks2();
    init_iso();
    init_parse2();
    ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
      $ZodType.init(inst, def);
      Object.assign(inst["~standard"], {
        jsonSchema: {
          input: createStandardJSONSchemaMethod(inst, "input"),
          output: createStandardJSONSchemaMethod(inst, "output")
        }
      });
      inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
      inst.def = def;
      inst.type = def.type;
      Object.defineProperty(inst, "_def", { value: def });
      inst.check = (...checks) => {
        return inst.clone(util_exports.mergeDefs(def, {
          checks: [
            ...def.checks ?? [],
            ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
          ]
        }), {
          parent: true
        });
      };
      inst.with = inst.check;
      inst.clone = (def2, params) => clone(inst, def2, params);
      inst.brand = () => inst;
      inst.register = ((reg, meta3) => {
        reg.add(inst, meta3);
        return inst;
      });
      inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
      inst.safeParse = (data, params) => safeParse2(inst, data, params);
      inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
      inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
      inst.spa = inst.safeParseAsync;
      inst.encode = (data, params) => encode2(inst, data, params);
      inst.decode = (data, params) => decode2(inst, data, params);
      inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
      inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
      inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
      inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
      inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
      inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
      inst.refine = (check2, params) => inst.check(refine(check2, params));
      inst.superRefine = (refinement) => inst.check(superRefine(refinement));
      inst.overwrite = (fn) => inst.check(_overwrite(fn));
      inst.optional = () => optional(inst);
      inst.exactOptional = () => exactOptional(inst);
      inst.nullable = () => nullable(inst);
      inst.nullish = () => optional(nullable(inst));
      inst.nonoptional = (params) => nonoptional(inst, params);
      inst.array = () => array(inst);
      inst.or = (arg) => union([inst, arg]);
      inst.and = (arg) => intersection(inst, arg);
      inst.transform = (tx) => pipe(inst, transform(tx));
      inst.default = (def2) => _default2(inst, def2);
      inst.prefault = (def2) => prefault(inst, def2);
      inst.catch = (params) => _catch2(inst, params);
      inst.pipe = (target) => pipe(inst, target);
      inst.readonly = () => readonly(inst);
      inst.describe = (description) => {
        const cl = inst.clone();
        globalRegistry.add(cl, { description });
        return cl;
      };
      Object.defineProperty(inst, "description", {
        get() {
          return globalRegistry.get(inst)?.description;
        },
        configurable: true
      });
      inst.meta = (...args) => {
        if (args.length === 0) {
          return globalRegistry.get(inst);
        }
        const cl = inst.clone();
        globalRegistry.add(cl, args[0]);
        return cl;
      };
      inst.isOptional = () => inst.safeParse(void 0).success;
      inst.isNullable = () => inst.safeParse(null).success;
      inst.apply = (fn) => fn(inst);
      return inst;
    });
    _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => stringProcessor(inst, ctx, json3, params);
      const bag = inst._zod.bag;
      inst.format = bag.format ?? null;
      inst.minLength = bag.minimum ?? null;
      inst.maxLength = bag.maximum ?? null;
      inst.regex = (...args) => inst.check(_regex(...args));
      inst.includes = (...args) => inst.check(_includes(...args));
      inst.startsWith = (...args) => inst.check(_startsWith(...args));
      inst.endsWith = (...args) => inst.check(_endsWith(...args));
      inst.min = (...args) => inst.check(_minLength(...args));
      inst.max = (...args) => inst.check(_maxLength(...args));
      inst.length = (...args) => inst.check(_length(...args));
      inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
      inst.lowercase = (params) => inst.check(_lowercase(params));
      inst.uppercase = (params) => inst.check(_uppercase(params));
      inst.trim = () => inst.check(_trim());
      inst.normalize = (...args) => inst.check(_normalize(...args));
      inst.toLowerCase = () => inst.check(_toLowerCase());
      inst.toUpperCase = () => inst.check(_toUpperCase());
      inst.slugify = () => inst.check(_slugify());
    });
    ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      _ZodString.init(inst, def);
      inst.email = (params) => inst.check(_email(ZodEmail, params));
      inst.url = (params) => inst.check(_url(ZodURL, params));
      inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
      inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
      inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
      inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
      inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
      inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
      inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
      inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
      inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
      inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
      inst.xid = (params) => inst.check(_xid(ZodXID, params));
      inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
      inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
      inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
      inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
      inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
      inst.e164 = (params) => inst.check(_e164(ZodE164, params));
      inst.datetime = (params) => inst.check(datetime2(params));
      inst.date = (params) => inst.check(date2(params));
      inst.time = (params) => inst.check(time2(params));
      inst.duration = (params) => inst.check(duration2(params));
    });
    ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      _ZodString.init(inst, def);
    });
    ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
      $ZodEmail.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
      $ZodGUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
      $ZodUUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
      $ZodURL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
      $ZodEmoji.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
      $ZodNanoID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
      $ZodCUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
      $ZodCUID2.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
      $ZodULID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
      $ZodXID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
      $ZodKSUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
      $ZodIPv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
      $ZodMAC.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
      $ZodIPv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
      $ZodCIDRv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
      $ZodCIDRv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
      $ZodBase64.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
      $ZodBase64URL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
      $ZodE164.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
      $ZodJWT.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
      $ZodCustomStringFormat.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
      $ZodNumber.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => numberProcessor(inst, ctx, json3, params);
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.int = (params) => inst.check(int(params));
      inst.safe = (params) => inst.check(int(params));
      inst.positive = (params) => inst.check(_gt(0, params));
      inst.nonnegative = (params) => inst.check(_gte(0, params));
      inst.negative = (params) => inst.check(_lt(0, params));
      inst.nonpositive = (params) => inst.check(_lte(0, params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      inst.step = (value, params) => inst.check(_multipleOf(value, params));
      inst.finite = () => inst;
      const bag = inst._zod.bag;
      inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
      inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
      inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
      inst.isFinite = true;
      inst.format = bag.format ?? null;
    });
    ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
      $ZodNumberFormat.init(inst, def);
      ZodNumber.init(inst, def);
    });
    ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
      $ZodBoolean.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => booleanProcessor(inst, ctx, json3, params);
    });
    ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
      $ZodBigInt.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => bigintProcessor(inst, ctx, json3, params);
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.positive = (params) => inst.check(_gt(BigInt(0), params));
      inst.negative = (params) => inst.check(_lt(BigInt(0), params));
      inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
      inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      const bag = inst._zod.bag;
      inst.minValue = bag.minimum ?? null;
      inst.maxValue = bag.maximum ?? null;
      inst.format = bag.format ?? null;
    });
    ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
      $ZodBigIntFormat.init(inst, def);
      ZodBigInt.init(inst, def);
    });
    ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
      $ZodSymbol.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => symbolProcessor(inst, ctx, json3, params);
    });
    ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
      $ZodUndefined.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => undefinedProcessor(inst, ctx, json3, params);
    });
    ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
      $ZodNull.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => nullProcessor(inst, ctx, json3, params);
    });
    ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
      $ZodAny.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => anyProcessor(inst, ctx, json3, params);
    });
    ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
      $ZodUnknown.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => unknownProcessor(inst, ctx, json3, params);
    });
    ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
      $ZodNever.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => neverProcessor(inst, ctx, json3, params);
    });
    ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
      $ZodVoid.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => voidProcessor(inst, ctx, json3, params);
    });
    ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
      $ZodDate.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => dateProcessor(inst, ctx, json3, params);
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      const c = inst._zod.bag;
      inst.minDate = c.minimum ? new Date(c.minimum) : null;
      inst.maxDate = c.maximum ? new Date(c.maximum) : null;
    });
    ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
      $ZodArray.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => arrayProcessor(inst, ctx, json3, params);
      inst.element = def.element;
      inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
      inst.nonempty = (params) => inst.check(_minLength(1, params));
      inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
      inst.length = (len, params) => inst.check(_length(len, params));
      inst.unwrap = () => inst.element;
    });
    ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
      $ZodObjectJIT.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => objectProcessor(inst, ctx, json3, params);
      util_exports.defineLazy(inst, "shape", () => {
        return def.shape;
      });
      inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
      inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
      inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
      inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
      inst.extend = (incoming) => {
        return util_exports.extend(inst, incoming);
      };
      inst.safeExtend = (incoming) => {
        return util_exports.safeExtend(inst, incoming);
      };
      inst.merge = (other) => util_exports.merge(inst, other);
      inst.pick = (mask) => util_exports.pick(inst, mask);
      inst.omit = (mask) => util_exports.omit(inst, mask);
      inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
      inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
    });
    ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
      inst.options = def.options;
    });
    ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
      ZodUnion.init(inst, def);
      $ZodXor.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
      inst.options = def.options;
    });
    ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
      ZodUnion.init(inst, def);
      $ZodDiscriminatedUnion.init(inst, def);
    });
    ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
      $ZodIntersection.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => intersectionProcessor(inst, ctx, json3, params);
    });
    ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
      $ZodTuple.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => tupleProcessor(inst, ctx, json3, params);
      inst.rest = (rest) => inst.clone({
        ...inst._zod.def,
        rest
      });
    });
    ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
      $ZodRecord.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => recordProcessor(inst, ctx, json3, params);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
      $ZodMap.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => mapProcessor(inst, ctx, json3, params);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
      inst.min = (...args) => inst.check(_minSize(...args));
      inst.nonempty = (params) => inst.check(_minSize(1, params));
      inst.max = (...args) => inst.check(_maxSize(...args));
      inst.size = (...args) => inst.check(_size(...args));
    });
    ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
      $ZodSet.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => setProcessor(inst, ctx, json3, params);
      inst.min = (...args) => inst.check(_minSize(...args));
      inst.nonempty = (params) => inst.check(_minSize(1, params));
      inst.max = (...args) => inst.check(_maxSize(...args));
      inst.size = (...args) => inst.check(_size(...args));
    });
    ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
      $ZodEnum.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => enumProcessor(inst, ctx, json3, params);
      inst.enum = def.entries;
      inst.options = Object.values(def.entries);
      const keys = new Set(Object.keys(def.entries));
      inst.extract = (values, params) => {
        const newEntries = {};
        for (const value of values) {
          if (keys.has(value)) {
            newEntries[value] = def.entries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
          ...def,
          checks: [],
          ...util_exports.normalizeParams(params),
          entries: newEntries
        });
      };
      inst.exclude = (values, params) => {
        const newEntries = { ...def.entries };
        for (const value of values) {
          if (keys.has(value)) {
            delete newEntries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
          ...def,
          checks: [],
          ...util_exports.normalizeParams(params),
          entries: newEntries
        });
      };
    });
    ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
      $ZodLiteral.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => literalProcessor(inst, ctx, json3, params);
      inst.values = new Set(def.values);
      Object.defineProperty(inst, "value", {
        get() {
          if (def.values.length > 1) {
            throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
          }
          return def.values[0];
        }
      });
    });
    ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
      $ZodFile.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => fileProcessor(inst, ctx, json3, params);
      inst.min = (size, params) => inst.check(_minSize(size, params));
      inst.max = (size, params) => inst.check(_maxSize(size, params));
      inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
    });
    ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
      $ZodTransform.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => transformProcessor(inst, ctx, json3, params);
      inst._zod.parse = (payload, _ctx) => {
        if (_ctx.direction === "backward") {
          throw new $ZodEncodeError(inst.constructor.name);
        }
        payload.addIssue = (issue2) => {
          if (typeof issue2 === "string") {
            payload.issues.push(util_exports.issue(issue2, payload.value, def));
          } else {
            const _issue = issue2;
            if (_issue.fatal)
              _issue.continue = false;
            _issue.code ?? (_issue.code = "custom");
            _issue.input ?? (_issue.input = payload.value);
            _issue.inst ?? (_issue.inst = inst);
            payload.issues.push(util_exports.issue(_issue));
          }
        };
        const output = def.transform(payload.value, payload);
        if (output instanceof Promise) {
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        payload.value = output;
        return payload;
      };
    });
    ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
      $ZodOptional.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
      $ZodExactOptional.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
      $ZodNullable.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => nullableProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
      $ZodDefault.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => defaultProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeDefault = inst.unwrap;
    });
    ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
      $ZodPrefault.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => prefaultProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
      $ZodNonOptional.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => nonoptionalProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
      $ZodSuccess.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => successProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
      $ZodCatch.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => catchProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeCatch = inst.unwrap;
    });
    ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
      $ZodNaN.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => nanProcessor(inst, ctx, json3, params);
    });
    ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
      $ZodPipe.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => pipeProcessor(inst, ctx, json3, params);
      inst.in = def.in;
      inst.out = def.out;
    });
    ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
      ZodPipe.init(inst, def);
      $ZodCodec.init(inst, def);
    });
    ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
      $ZodReadonly.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => readonlyProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
      $ZodTemplateLiteral.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => templateLiteralProcessor(inst, ctx, json3, params);
    });
    ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
      $ZodLazy.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => lazyProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.getter();
    });
    ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
      $ZodPromise.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => promiseProcessor(inst, ctx, json3, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
      $ZodFunction.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => functionProcessor(inst, ctx, json3, params);
    });
    ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
      $ZodCustom.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json3, params) => customProcessor(inst, ctx, json3, params);
    });
    describe2 = describe;
    meta2 = meta;
    stringbool = (...args) => _stringbool({
      Codec: ZodCodec,
      Boolean: ZodBoolean,
      String: ZodString
    }, ...args);
  }
});

// node_modules/zod/v4/classic/compat.js
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodIssueCode, ZodFirstPartyTypeKind;
var init_compat = __esm({
  "node_modules/zod/v4/classic/compat.js"() {
    init_core2();
    init_core2();
    ZodIssueCode = {
      invalid_type: "invalid_type",
      too_big: "too_big",
      too_small: "too_small",
      invalid_format: "invalid_format",
      not_multiple_of: "not_multiple_of",
      unrecognized_keys: "unrecognized_keys",
      invalid_union: "invalid_union",
      invalid_key: "invalid_key",
      invalid_element: "invalid_element",
      invalid_value: "invalid_value",
      custom: "custom"
    };
    /* @__PURE__ */ (function(ZodFirstPartyTypeKind3) {
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  }
});

// node_modules/zod/v4/classic/from-json-schema.js
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path3 = ref.slice(1).split("/").filter(Boolean);
  if (path3.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path3[0] === defsKey) {
    const key = path3[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
  if (schema.not !== void 0) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== void 0) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== void 0) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema.enum !== void 0) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== void 0) {
    return z.literal(schema.const);
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type) {
    return z.any();
  }
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema.format) {
        const format = schema.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2; i < schemasToIntersect.length; i++) {
            result = z.intersection(result, schemasToIntersect[i]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (items !== void 0) {
        const element = convertSchema(items, ctx);
        let arraySchema = z.array(element);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema.description) {
    zodSchema = zodSchema.describe(schema.description);
  }
  if (schema.default !== void 0) {
    zodSchema = zodSchema.default(schema.default);
  }
  return zodSchema;
}
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx; i < schema.allOf.length; i++) {
        result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  for (const key of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  const version2 = detectVersion(schema, params?.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version2,
    defs,
    refs: /* @__PURE__ */ new Map(),
    processing: /* @__PURE__ */ new Set(),
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema, ctx);
}
var z, RECOGNIZED_KEYS;
var init_from_json_schema = __esm({
  "node_modules/zod/v4/classic/from-json-schema.js"() {
    init_registries();
    init_checks2();
    init_iso();
    init_schemas2();
    z = {
      ...schemas_exports2,
      ...checks_exports2,
      iso: iso_exports
    };
    RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
      // Schema identification
      "$schema",
      "$ref",
      "$defs",
      "definitions",
      // Core schema keywords
      "$id",
      "id",
      "$comment",
      "$anchor",
      "$vocabulary",
      "$dynamicRef",
      "$dynamicAnchor",
      // Type
      "type",
      "enum",
      "const",
      // Composition
      "anyOf",
      "oneOf",
      "allOf",
      "not",
      // Object
      "properties",
      "required",
      "additionalProperties",
      "patternProperties",
      "propertyNames",
      "minProperties",
      "maxProperties",
      // Array
      "items",
      "prefixItems",
      "additionalItems",
      "minItems",
      "maxItems",
      "uniqueItems",
      "contains",
      "minContains",
      "maxContains",
      // String
      "minLength",
      "maxLength",
      "pattern",
      "format",
      // Number
      "minimum",
      "maximum",
      "exclusiveMinimum",
      "exclusiveMaximum",
      "multipleOf",
      // Already handled metadata
      "description",
      "default",
      // Content
      "contentEncoding",
      "contentMediaType",
      "contentSchema",
      // Unsupported (error-throwing)
      "unevaluatedItems",
      "unevaluatedProperties",
      "if",
      "then",
      "else",
      "dependentSchemas",
      "dependentRequired",
      // OpenAPI
      "nullable",
      "readOnly"
    ]);
  }
});

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}
var init_coerce = __esm({
  "node_modules/zod/v4/classic/coerce.js"() {
    init_core2();
    init_schemas2();
  }
});

// node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  decode: () => decode2,
  decodeAsync: () => decodeAsync2,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode2,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  fromJSONSchema: () => fromJSONSchema,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  mac: () => mac2,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  meta: () => meta2,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse2,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});
var init_external = __esm({
  "node_modules/zod/v4/classic/external.js"() {
    init_core2();
    init_schemas2();
    init_checks2();
    init_errors2();
    init_parse2();
    init_compat();
    init_core2();
    init_en();
    init_core2();
    init_json_schema_processors();
    init_from_json_schema();
    init_locales();
    init_iso();
    init_iso();
    init_coerce();
    config(en_default());
  }
});

// node_modules/zod/v4/classic/index.js
var init_classic = __esm({
  "node_modules/zod/v4/classic/index.js"() {
    init_external();
    init_external();
  }
});

// node_modules/zod/v4/index.js
var init_v4 = __esm({
  "node_modules/zod/v4/index.js"() {
    init_classic();
    init_classic();
  }
});

// node_modules/@openrouter/sdk/esm/lib/primitives.js
function remap(inp, mappings) {
  let out = {};
  if (!Object.keys(mappings).length) {
    out = inp;
    return out;
  }
  for (const [k, v] of Object.entries(inp)) {
    const j = mappings[k];
    if (j === null) {
      continue;
    }
    out[j ?? k] = v;
  }
  return out;
}
function compactMap(values) {
  const out = {};
  for (const [k, v] of Object.entries(values)) {
    if (typeof v !== "undefined") {
      out[k] = v;
    }
  }
  return out;
}
var init_primitives = __esm({
  "node_modules/@openrouter/sdk/esm/lib/primitives.js"() {
  }
});

// node_modules/@openrouter/sdk/esm/types/unrecognized.js
function unrecognized(value) {
  globalCount++;
  return value;
}
var globalCount;
var init_unrecognized = __esm({
  "node_modules/@openrouter/sdk/esm/types/unrecognized.js"() {
    globalCount = 0;
  }
});

// node_modules/@openrouter/sdk/esm/types/enums.js
function inboundSchema(enumObj) {
  const options = Object.values(enumObj);
  return union([
    ...options.map((x) => literal(x)),
    string2().transform((x) => unrecognized(x))
  ]);
}
function inboundSchemaInt(enumObj) {
  const options = Object.values(enumObj).filter((v) => typeof v === "number");
  return union([
    ...options.map((x) => literal(x)),
    int().transform((x) => unrecognized(x))
  ]);
}
function outboundSchema(_) {
  return string2();
}
function outboundSchemaInt(_) {
  return int();
}
var init_enums = __esm({
  "node_modules/@openrouter/sdk/esm/types/enums.js"() {
    init_v4();
    init_unrecognized();
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/sdkvalidationerror.js
function formatZodError(err) {
  return prettifyError(err);
}
var SDKValidationError;
var init_sdkvalidationerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/sdkvalidationerror.js"() {
    init_core2();
    SDKValidationError = class extends Error {
      // Allows for backwards compatibility for `instanceof` checks of `ResponseValidationError`
      static [Symbol.hasInstance](instance) {
        if (!(instance instanceof Error))
          return false;
        if (!("rawValue" in instance))
          return false;
        if (!("rawMessage" in instance))
          return false;
        if (!("pretty" in instance))
          return false;
        if (typeof instance.pretty !== "function")
          return false;
        return true;
      }
      constructor(message, cause, rawValue) {
        super(`${message}: ${cause}`);
        this.name = "SDKValidationError";
        this.cause = cause;
        this.rawValue = rawValue;
        this.rawMessage = message;
      }
      /**
       * Return a pretty-formatted error message if the underlying validation error
       * is a ZodError or some other recognized error type, otherwise return the
       * default error message.
       */
      pretty() {
        if (this.cause instanceof $ZodError) {
          return `${this.rawMessage}
${formatZodError(this.cause)}`;
        } else {
          return this.toString();
        }
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/types/fp.js
function OK(value) {
  return { ok: true, value };
}
function ERR(error48) {
  return { ok: false, error: error48 };
}
async function unwrapAsync(pr) {
  const r = await pr;
  if (!r.ok) {
    throw r.error;
  }
  return r.value;
}
var init_fp = __esm({
  "node_modules/@openrouter/sdk/esm/types/fp.js"() {
  }
});

// node_modules/@openrouter/sdk/esm/lib/schemas.js
function safeParse3(rawValue, fn, errorMessage) {
  try {
    return OK(fn(rawValue));
  } catch (err) {
    return ERR(new SDKValidationError(errorMessage, err, rawValue));
  }
}
var init_schemas3 = __esm({
  "node_modules/@openrouter/sdk/esm/lib/schemas.js"() {
    init_v4();
    init_sdkvalidationerror();
    init_fp();
  }
});

// node_modules/@openrouter/sdk/esm/models/responseinputaudio.js
var ResponseInputAudioFormat, ResponseInputAudioFormat$inboundSchema, ResponseInputAudioFormat$outboundSchema, ResponseInputAudioInputAudio$inboundSchema, ResponseInputAudioInputAudio$outboundSchema, ResponseInputAudio$inboundSchema, ResponseInputAudio$outboundSchema;
var init_responseinputaudio = __esm({
  "node_modules/@openrouter/sdk/esm/models/responseinputaudio.js"() {
    init_v4();
    init_primitives();
    init_enums();
    ResponseInputAudioFormat = {
      Mp3: "mp3",
      Wav: "wav"
    };
    ResponseInputAudioFormat$inboundSchema = inboundSchema(ResponseInputAudioFormat);
    ResponseInputAudioFormat$outboundSchema = outboundSchema(ResponseInputAudioFormat);
    ResponseInputAudioInputAudio$inboundSchema = object({
      data: string2(),
      format: ResponseInputAudioFormat$inboundSchema
    });
    ResponseInputAudioInputAudio$outboundSchema = object({
      data: string2(),
      format: ResponseInputAudioFormat$outboundSchema
    });
    ResponseInputAudio$inboundSchema = object({
      type: literal("input_audio"),
      input_audio: lazy(() => ResponseInputAudioInputAudio$inboundSchema)
    }).transform((v) => {
      return remap(v, {
        "input_audio": "inputAudio"
      });
    });
    ResponseInputAudio$outboundSchema = object({
      type: literal("input_audio"),
      inputAudio: lazy(() => ResponseInputAudioInputAudio$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        inputAudio: "input_audio"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responseinputfile.js
var ResponseInputFile$inboundSchema, ResponseInputFile$outboundSchema;
var init_responseinputfile = __esm({
  "node_modules/@openrouter/sdk/esm/models/responseinputfile.js"() {
    init_v4();
    init_primitives();
    ResponseInputFile$inboundSchema = object({
      type: literal("input_file"),
      file_id: nullable(string2()).optional(),
      file_data: string2().optional(),
      filename: string2().optional(),
      file_url: string2().optional()
    }).transform((v) => {
      return remap(v, {
        "file_id": "fileId",
        "file_data": "fileData",
        "file_url": "fileUrl"
      });
    });
    ResponseInputFile$outboundSchema = object({
      type: literal("input_file"),
      fileId: nullable(string2()).optional(),
      fileData: string2().optional(),
      filename: string2().optional(),
      fileUrl: string2().optional()
    }).transform((v) => {
      return remap(v, {
        fileId: "file_id",
        fileData: "file_data",
        fileUrl: "file_url"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responseinputtext.js
var ResponseInputText$inboundSchema, ResponseInputText$outboundSchema;
var init_responseinputtext = __esm({
  "node_modules/@openrouter/sdk/esm/models/responseinputtext.js"() {
    init_v4();
    ResponseInputText$inboundSchema = object({
      type: literal("input_text"),
      text: string2()
    });
    ResponseInputText$outboundSchema = object({
      type: literal("input_text"),
      text: string2()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responseinputvideo.js
var ResponseInputVideo$outboundSchema;
var init_responseinputvideo = __esm({
  "node_modules/@openrouter/sdk/esm/models/responseinputvideo.js"() {
    init_v4();
    init_primitives();
    ResponseInputVideo$outboundSchema = object({
      type: literal("input_video"),
      videoUrl: string2()
    }).transform((v) => {
      return remap(v, {
        videoUrl: "video_url"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponseseasyinputmessage.js
var OpenResponsesEasyInputMessageTypeMessage, OpenResponsesEasyInputMessageRoleDeveloper, OpenResponsesEasyInputMessageRoleAssistant, OpenResponsesEasyInputMessageRoleSystem, OpenResponsesEasyInputMessageRoleUser, OpenResponsesEasyInputMessageDetail, OpenResponsesEasyInputMessageTypeMessage$outboundSchema, OpenResponsesEasyInputMessageRoleDeveloper$outboundSchema, OpenResponsesEasyInputMessageRoleAssistant$outboundSchema, OpenResponsesEasyInputMessageRoleSystem$outboundSchema, OpenResponsesEasyInputMessageRoleUser$outboundSchema, OpenResponsesEasyInputMessageRoleUnion$outboundSchema, OpenResponsesEasyInputMessageDetail$outboundSchema, OpenResponsesEasyInputMessageContentInputImage$outboundSchema, OpenResponsesEasyInputMessageContentUnion1$outboundSchema, OpenResponsesEasyInputMessageContentUnion2$outboundSchema, OpenResponsesEasyInputMessage$outboundSchema;
var init_openresponseseasyinputmessage = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponseseasyinputmessage.js"() {
    init_v4();
    init_primitives();
    init_enums();
    init_responseinputaudio();
    init_responseinputfile();
    init_responseinputtext();
    init_responseinputvideo();
    OpenResponsesEasyInputMessageTypeMessage = {
      Message: "message"
    };
    OpenResponsesEasyInputMessageRoleDeveloper = {
      Developer: "developer"
    };
    OpenResponsesEasyInputMessageRoleAssistant = {
      Assistant: "assistant"
    };
    OpenResponsesEasyInputMessageRoleSystem = {
      System: "system"
    };
    OpenResponsesEasyInputMessageRoleUser = {
      User: "user"
    };
    OpenResponsesEasyInputMessageDetail = {
      Auto: "auto",
      High: "high",
      Low: "low"
    };
    OpenResponsesEasyInputMessageTypeMessage$outboundSchema = _enum2(OpenResponsesEasyInputMessageTypeMessage);
    OpenResponsesEasyInputMessageRoleDeveloper$outboundSchema = _enum2(OpenResponsesEasyInputMessageRoleDeveloper);
    OpenResponsesEasyInputMessageRoleAssistant$outboundSchema = _enum2(OpenResponsesEasyInputMessageRoleAssistant);
    OpenResponsesEasyInputMessageRoleSystem$outboundSchema = _enum2(OpenResponsesEasyInputMessageRoleSystem);
    OpenResponsesEasyInputMessageRoleUser$outboundSchema = _enum2(OpenResponsesEasyInputMessageRoleUser);
    OpenResponsesEasyInputMessageRoleUnion$outboundSchema = union([
      OpenResponsesEasyInputMessageRoleUser$outboundSchema,
      OpenResponsesEasyInputMessageRoleSystem$outboundSchema,
      OpenResponsesEasyInputMessageRoleAssistant$outboundSchema,
      OpenResponsesEasyInputMessageRoleDeveloper$outboundSchema
    ]);
    OpenResponsesEasyInputMessageDetail$outboundSchema = outboundSchema(OpenResponsesEasyInputMessageDetail);
    OpenResponsesEasyInputMessageContentInputImage$outboundSchema = object({
      type: literal("input_image"),
      detail: OpenResponsesEasyInputMessageDetail$outboundSchema,
      imageUrl: nullable(string2()).optional()
    }).transform((v) => {
      return remap(v, {
        imageUrl: "image_url"
      });
    });
    OpenResponsesEasyInputMessageContentUnion1$outboundSchema = union([
      ResponseInputText$outboundSchema,
      lazy(() => OpenResponsesEasyInputMessageContentInputImage$outboundSchema),
      ResponseInputFile$outboundSchema,
      ResponseInputAudio$outboundSchema,
      ResponseInputVideo$outboundSchema
    ]);
    OpenResponsesEasyInputMessageContentUnion2$outboundSchema = union([
      array(union([
        ResponseInputText$outboundSchema,
        lazy(() => OpenResponsesEasyInputMessageContentInputImage$outboundSchema),
        ResponseInputFile$outboundSchema,
        ResponseInputAudio$outboundSchema,
        ResponseInputVideo$outboundSchema
      ])),
      string2()
    ]);
    OpenResponsesEasyInputMessage$outboundSchema = object({
      type: OpenResponsesEasyInputMessageTypeMessage$outboundSchema.optional(),
      role: union([
        OpenResponsesEasyInputMessageRoleUser$outboundSchema,
        OpenResponsesEasyInputMessageRoleSystem$outboundSchema,
        OpenResponsesEasyInputMessageRoleAssistant$outboundSchema,
        OpenResponsesEasyInputMessageRoleDeveloper$outboundSchema
      ]),
      content: union([
        array(union([
          ResponseInputText$outboundSchema,
          lazy(() => OpenResponsesEasyInputMessageContentInputImage$outboundSchema),
          ResponseInputFile$outboundSchema,
          ResponseInputAudio$outboundSchema,
          ResponseInputVideo$outboundSchema
        ])),
        string2()
      ])
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/toolcallstatus.js
var ToolCallStatus, ToolCallStatus$inboundSchema, ToolCallStatus$outboundSchema;
var init_toolcallstatus = __esm({
  "node_modules/@openrouter/sdk/esm/models/toolcallstatus.js"() {
    init_enums();
    ToolCallStatus = {
      InProgress: "in_progress",
      Completed: "completed",
      Incomplete: "incomplete"
    };
    ToolCallStatus$inboundSchema = inboundSchema(ToolCallStatus);
    ToolCallStatus$outboundSchema = outboundSchema(ToolCallStatus);
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesfunctioncalloutput.js
var OpenResponsesFunctionCallOutputType, OpenResponsesFunctionCallOutputType$outboundSchema, OpenResponsesFunctionCallOutput$outboundSchema;
var init_openresponsesfunctioncalloutput = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesfunctioncalloutput.js"() {
    init_v4();
    init_primitives();
    init_toolcallstatus();
    OpenResponsesFunctionCallOutputType = {
      FunctionCallOutput: "function_call_output"
    };
    OpenResponsesFunctionCallOutputType$outboundSchema = _enum2(OpenResponsesFunctionCallOutputType);
    OpenResponsesFunctionCallOutput$outboundSchema = object({
      type: OpenResponsesFunctionCallOutputType$outboundSchema,
      id: nullable(string2()).optional(),
      callId: string2(),
      output: string2(),
      status: nullable(ToolCallStatus$outboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        callId: "call_id"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesinputmessageitem.js
var OpenResponsesInputMessageItemTypeMessage, OpenResponsesInputMessageItemRoleDeveloper, OpenResponsesInputMessageItemRoleSystem, OpenResponsesInputMessageItemRoleUser, OpenResponsesInputMessageItemDetail, OpenResponsesInputMessageItemTypeMessage$outboundSchema, OpenResponsesInputMessageItemRoleDeveloper$outboundSchema, OpenResponsesInputMessageItemRoleSystem$outboundSchema, OpenResponsesInputMessageItemRoleUser$outboundSchema, OpenResponsesInputMessageItemRoleUnion$outboundSchema, OpenResponsesInputMessageItemDetail$outboundSchema, OpenResponsesInputMessageItemContentInputImage$outboundSchema, OpenResponsesInputMessageItemContentUnion$outboundSchema, OpenResponsesInputMessageItem$outboundSchema;
var init_openresponsesinputmessageitem = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesinputmessageitem.js"() {
    init_v4();
    init_primitives();
    init_enums();
    init_responseinputaudio();
    init_responseinputfile();
    init_responseinputtext();
    init_responseinputvideo();
    OpenResponsesInputMessageItemTypeMessage = {
      Message: "message"
    };
    OpenResponsesInputMessageItemRoleDeveloper = {
      Developer: "developer"
    };
    OpenResponsesInputMessageItemRoleSystem = {
      System: "system"
    };
    OpenResponsesInputMessageItemRoleUser = {
      User: "user"
    };
    OpenResponsesInputMessageItemDetail = {
      Auto: "auto",
      High: "high",
      Low: "low"
    };
    OpenResponsesInputMessageItemTypeMessage$outboundSchema = _enum2(OpenResponsesInputMessageItemTypeMessage);
    OpenResponsesInputMessageItemRoleDeveloper$outboundSchema = _enum2(OpenResponsesInputMessageItemRoleDeveloper);
    OpenResponsesInputMessageItemRoleSystem$outboundSchema = _enum2(OpenResponsesInputMessageItemRoleSystem);
    OpenResponsesInputMessageItemRoleUser$outboundSchema = _enum2(OpenResponsesInputMessageItemRoleUser);
    OpenResponsesInputMessageItemRoleUnion$outboundSchema = union([
      OpenResponsesInputMessageItemRoleUser$outboundSchema,
      OpenResponsesInputMessageItemRoleSystem$outboundSchema,
      OpenResponsesInputMessageItemRoleDeveloper$outboundSchema
    ]);
    OpenResponsesInputMessageItemDetail$outboundSchema = outboundSchema(OpenResponsesInputMessageItemDetail);
    OpenResponsesInputMessageItemContentInputImage$outboundSchema = object({
      type: literal("input_image"),
      detail: OpenResponsesInputMessageItemDetail$outboundSchema,
      imageUrl: nullable(string2()).optional()
    }).transform((v) => {
      return remap(v, {
        imageUrl: "image_url"
      });
    });
    OpenResponsesInputMessageItemContentUnion$outboundSchema = union([
      ResponseInputText$outboundSchema,
      lazy(() => OpenResponsesInputMessageItemContentInputImage$outboundSchema),
      ResponseInputFile$outboundSchema,
      ResponseInputAudio$outboundSchema,
      ResponseInputVideo$outboundSchema
    ]);
    OpenResponsesInputMessageItem$outboundSchema = object({
      id: string2().optional(),
      type: OpenResponsesInputMessageItemTypeMessage$outboundSchema.optional(),
      role: union([
        OpenResponsesInputMessageItemRoleUser$outboundSchema,
        OpenResponsesInputMessageItemRoleSystem$outboundSchema,
        OpenResponsesInputMessageItemRoleDeveloper$outboundSchema
      ]),
      content: array(union([
        ResponseInputText$outboundSchema,
        lazy(() => OpenResponsesInputMessageItemContentInputImage$outboundSchema),
        ResponseInputFile$outboundSchema,
        ResponseInputAudio$outboundSchema,
        ResponseInputVideo$outboundSchema
      ]))
    });
  }
});

// node_modules/@openrouter/sdk/esm/lib/stream-type-guards.js
function isOutputTextDeltaEvent(event) {
  return "type" in event && event.type === "response.output_text.delta";
}
function isReasoningDeltaEvent(event) {
  return "type" in event && event.type === "response.reasoning_text.delta";
}
function isFunctionCallArgumentsDeltaEvent(event) {
  return "type" in event && event.type === "response.function_call_arguments.delta";
}
function isOutputItemAddedEvent(event) {
  return "type" in event && event.type === "response.output_item.added";
}
function isOutputItemDoneEvent(event) {
  return "type" in event && event.type === "response.output_item.done";
}
function isResponseCompletedEvent(event) {
  return "type" in event && event.type === "response.completed";
}
function isResponseFailedEvent(event) {
  return "type" in event && event.type === "response.failed";
}
function isResponseIncompleteEvent(event) {
  return "type" in event && event.type === "response.incomplete";
}
function isFunctionCallArgumentsDoneEvent(event) {
  return "type" in event && event.type === "response.function_call_arguments.done";
}
function isOutputMessage(item) {
  return typeof item === "object" && item !== null && "type" in item && item.type === "message";
}
function isFunctionCallItem(item) {
  return typeof item === "object" && item !== null && "type" in item && item.type === "function_call";
}
function isReasoningOutputItem(item) {
  return typeof item === "object" && item !== null && "type" in item && item.type === "reasoning";
}
function isWebSearchCallOutputItem(item) {
  return typeof item === "object" && item !== null && "type" in item && item.type === "web_search_call";
}
function isFileSearchCallOutputItem(item) {
  return typeof item === "object" && item !== null && "type" in item && item.type === "file_search_call";
}
function isImageGenerationCallOutputItem(item) {
  return typeof item === "object" && item !== null && "type" in item && item.type === "image_generation_call";
}
function hasTypeProperty(item) {
  return typeof item === "object" && item !== null && "type" in item && typeof item.type === "string";
}
var init_stream_type_guards = __esm({
  "node_modules/@openrouter/sdk/esm/lib/stream-type-guards.js"() {
  }
});

// node_modules/@openrouter/sdk/esm/lib/stream-transformers.js
async function* extractTextDeltas(stream) {
  const consumer = stream.createConsumer();
  for await (const event of consumer) {
    if (isOutputTextDeltaEvent(event)) {
      if (event.delta) {
        yield event.delta;
      }
    }
  }
}
async function* extractReasoningDeltas(stream) {
  const consumer = stream.createConsumer();
  for await (const event of consumer) {
    if (isReasoningDeltaEvent(event)) {
      if (event.delta) {
        yield event.delta;
      }
    }
  }
}
async function* extractToolDeltas(stream) {
  const consumer = stream.createConsumer();
  for await (const event of consumer) {
    if (isFunctionCallArgumentsDeltaEvent(event)) {
      if (event.delta) {
        yield event.delta;
      }
    }
  }
}
async function* buildMessageStreamCore(stream) {
  const consumer = stream.createConsumer();
  let currentText = "";
  let currentId = "";
  let hasStarted = false;
  for await (const event of consumer) {
    if (!("type" in event)) {
      continue;
    }
    switch (event.type) {
      case "response.output_item.added": {
        if (isOutputItemAddedEvent(event)) {
          if (event.item && isOutputMessage(event.item)) {
            hasStarted = true;
            currentText = "";
            currentId = event.item.id;
          }
        }
        break;
      }
      case "response.output_text.delta": {
        if (isOutputTextDeltaEvent(event)) {
          if (hasStarted && event.delta) {
            currentText += event.delta;
            yield {
              type: "delta",
              text: currentText,
              messageId: currentId
            };
          }
        }
        break;
      }
      case "response.output_item.done": {
        if (isOutputItemDoneEvent(event)) {
          if (event.item && isOutputMessage(event.item)) {
            yield {
              type: "complete",
              completeMessage: event.item
            };
          }
        }
        break;
      }
      case "response.completed":
      case "response.failed":
      case "response.incomplete":
        return;
      default:
        break;
    }
  }
}
async function* buildResponsesMessageStream(stream) {
  for await (const update of buildMessageStreamCore(stream)) {
    if (update.type === "delta" && update.text !== void 0 && update.messageId !== void 0) {
      yield {
        id: update.messageId,
        type: "message",
        role: "assistant",
        status: "in_progress",
        content: [
          {
            type: "output_text",
            text: update.text,
            annotations: []
          }
        ]
      };
    } else if (update.type === "complete" && update.completeMessage) {
      yield update.completeMessage;
    }
  }
}
function handleOutputItemAdded(event, itemsInProgress) {
  if (!isOutputItemAddedEvent(event) || !event.item) {
    return void 0;
  }
  const item = event.item;
  if (isOutputMessage(item)) {
    itemsInProgress.set(item.id, {
      type: "message",
      id: item.id,
      textContent: ""
    });
    return {
      id: item.id,
      type: "message",
      role: "assistant",
      status: "in_progress",
      content: []
    };
  }
  if (isFunctionCallItem(item)) {
    const itemKey = item.id ?? item.callId;
    itemsInProgress.set(itemKey, {
      type: "function_call",
      id: itemKey,
      name: item.name,
      callId: item.callId,
      argumentsAccumulated: ""
    });
    return {
      type: "function_call",
      id: item.id,
      callId: item.callId,
      name: item.name,
      arguments: "",
      status: "in_progress"
    };
  }
  if (isReasoningOutputItem(item)) {
    itemsInProgress.set(item.id, {
      type: "reasoning",
      id: item.id,
      reasoningContent: ""
    });
    return {
      type: "reasoning",
      id: item.id,
      status: "in_progress",
      summary: []
    };
  }
  if (isWebSearchCallOutputItem(item)) {
    return item;
  }
  if (isFileSearchCallOutputItem(item)) {
    return item;
  }
  if (isImageGenerationCallOutputItem(item)) {
    return item;
  }
  return void 0;
}
function handleTextDelta(event, itemsInProgress) {
  if (!isOutputTextDeltaEvent(event) || !event.delta) {
    return void 0;
  }
  const item = itemsInProgress.get(event.itemId);
  if (item?.type === "message") {
    item.textContent += event.delta;
    return {
      id: item.id,
      type: "message",
      role: "assistant",
      status: "in_progress",
      content: [
        {
          type: "output_text",
          text: item.textContent,
          annotations: []
        }
      ]
    };
  }
  return void 0;
}
function handleFunctionCallDelta(event, itemsInProgress) {
  if (!isFunctionCallArgumentsDeltaEvent(event) || !event.delta) {
    return void 0;
  }
  const item = itemsInProgress.get(event.itemId);
  if (item?.type === "function_call") {
    item.argumentsAccumulated += event.delta;
    return {
      type: "function_call",
      // Include id if it differs from callId (means API provided an id)
      id: item.id !== item.callId ? item.id : void 0,
      callId: item.callId,
      name: item.name,
      arguments: item.argumentsAccumulated,
      status: "in_progress"
    };
  }
  return void 0;
}
function handleReasoningDelta(event, itemsInProgress) {
  if (!isReasoningDeltaEvent(event) || !event.delta) {
    return void 0;
  }
  const item = itemsInProgress.get(event.itemId);
  if (item?.type === "reasoning") {
    item.reasoningContent += event.delta;
    return {
      type: "reasoning",
      id: item.id,
      status: "in_progress",
      summary: [
        {
          type: "summary_text",
          text: item.reasoningContent
        }
      ]
    };
  }
  return void 0;
}
function handleOutputItemDone(event, itemsInProgress) {
  if (!isOutputItemDoneEvent(event) || !event.item) {
    return void 0;
  }
  const item = event.item;
  if (isOutputMessage(item)) {
    itemsInProgress.delete(item.id);
    return item;
  }
  if (isFunctionCallItem(item)) {
    itemsInProgress.delete(item.id ?? item.callId);
    return item;
  }
  if (isReasoningOutputItem(item)) {
    itemsInProgress.delete(item.id);
    return item;
  }
  if (isWebSearchCallOutputItem(item)) {
    return item;
  }
  if (isFileSearchCallOutputItem(item)) {
    return item;
  }
  if (isImageGenerationCallOutputItem(item)) {
    return item;
  }
  return void 0;
}
async function* buildItemsStream(stream) {
  const consumer = stream.createConsumer();
  const itemsInProgress = /* @__PURE__ */ new Map();
  for await (const event of consumer) {
    if (!("type" in event)) {
      continue;
    }
    if (streamTerminationEvents.has(event.type)) {
      return;
    }
    const handler = itemsStreamHandlers[event.type];
    if (handler) {
      const result = handler(event, itemsInProgress);
      if (result) {
        yield result;
      }
    }
  }
}
async function consumeStreamForCompletion(stream) {
  const consumer = stream.createConsumer();
  for await (const event of consumer) {
    if (!("type" in event)) {
      continue;
    }
    if (isResponseCompletedEvent(event)) {
      return event.response;
    }
    if (isResponseFailedEvent(event)) {
      throw new Error(`Response failed: ${JSON.stringify(event.response.error)}`);
    }
    if (isResponseIncompleteEvent(event)) {
      return event.response;
    }
  }
  throw new Error("Stream ended without completion event");
}
function convertToAssistantMessage(outputMessage) {
  const textContent = outputMessage.content.filter((part) => "type" in part && part.type === "output_text").map((part) => part.text).join("");
  return {
    role: "assistant",
    content: textContent || null
  };
}
function extractMessageFromResponse(response) {
  const messageItem = response.output.find((item) => "type" in item && item.type === "message");
  if (!messageItem) {
    throw new Error("No message found in response output");
  }
  return convertToAssistantMessage(messageItem);
}
function extractResponsesMessageFromResponse(response) {
  const messageItem = response.output.find((item) => "type" in item && item.type === "message");
  if (!messageItem) {
    throw new Error("No message found in response output");
  }
  return messageItem;
}
function extractTextFromResponse(response) {
  if (response.outputText) {
    return response.outputText;
  }
  const hasMessage = response.output.some((item) => "type" in item && item.type === "message");
  if (!hasMessage) {
    return "";
  }
  const message = extractMessageFromResponse(response);
  if (typeof message.content === "string") {
    return message.content;
  }
  return "";
}
function extractToolCallsFromResponse(response) {
  const toolCalls = [];
  for (const item of response.output) {
    if (isFunctionCallItem(item)) {
      try {
        const parsedArguments = JSON.parse(item.arguments);
        toolCalls.push({
          id: item.callId,
          name: item.name,
          arguments: parsedArguments
        });
      } catch (error48) {
        console.warn(`Failed to parse tool call arguments for ${item.name}:`, error48 instanceof Error ? error48.message : String(error48), `
Arguments: ${item.arguments.substring(0, 100)}${item.arguments.length > 100 ? "..." : ""}`);
        toolCalls.push({
          id: item.callId,
          name: item.name,
          arguments: item.arguments
          // Keep as string if parsing fails
        });
      }
    }
  }
  return toolCalls;
}
async function* buildToolCallStream(stream) {
  const consumer = stream.createConsumer();
  const toolCallsInProgress = /* @__PURE__ */ new Map();
  for await (const event of consumer) {
    if (!("type" in event)) {
      continue;
    }
    switch (event.type) {
      case "response.output_item.added": {
        if (isOutputItemAddedEvent(event) && event.item && isFunctionCallItem(event.item)) {
          toolCallsInProgress.set(event.item.callId, {
            id: event.item.callId,
            name: event.item.name,
            argumentsAccumulated: ""
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        if (isFunctionCallArgumentsDeltaEvent(event)) {
          const toolCall = toolCallsInProgress.get(event.itemId);
          if (toolCall && event.delta) {
            toolCall.argumentsAccumulated += event.delta;
          }
        }
        break;
      }
      case "response.function_call_arguments.done": {
        if (isFunctionCallArgumentsDoneEvent(event)) {
          const toolCall = toolCallsInProgress.get(event.itemId);
          if (toolCall) {
            try {
              const parsedArguments = JSON.parse(event.arguments);
              yield {
                id: toolCall.id,
                name: event.name,
                arguments: parsedArguments
              };
            } catch (error48) {
              console.warn(`Failed to parse tool call arguments for ${event.name}:`, error48 instanceof Error ? error48.message : String(error48), `
Arguments: ${event.arguments.substring(0, 100)}${event.arguments.length > 100 ? "..." : ""}`);
              yield {
                id: toolCall.id,
                name: event.name,
                arguments: event.arguments
              };
            }
            toolCallsInProgress.delete(event.itemId);
          }
        }
        break;
      }
      case "response.output_item.done": {
        if (isOutputItemDoneEvent(event) && event.item && isFunctionCallItem(event.item)) {
          if (toolCallsInProgress.has(event.item.callId)) {
            try {
              const parsedArguments = JSON.parse(event.item.arguments);
              yield {
                id: event.item.callId,
                name: event.item.name,
                arguments: parsedArguments
              };
            } catch (_error) {
              yield {
                id: event.item.callId,
                name: event.item.name,
                arguments: event.item.arguments
              };
            }
            toolCallsInProgress.delete(event.item.callId);
          }
        }
        break;
      }
    }
  }
}
var itemsStreamHandlers, streamTerminationEvents;
var init_stream_transformers = __esm({
  "node_modules/@openrouter/sdk/esm/lib/stream-transformers.js"() {
    init_stream_type_guards();
    itemsStreamHandlers = {
      "response.output_item.added": handleOutputItemAdded,
      "response.output_text.delta": handleTextDelta,
      "response.function_call_arguments.delta": handleFunctionCallDelta,
      "response.reasoning_text.delta": handleReasoningDelta,
      "response.output_item.done": handleOutputItemDone
    };
    streamTerminationEvents = /* @__PURE__ */ new Set([
      "response.completed",
      "response.failed",
      "response.incomplete"
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/lib/async-params.js
function isParameterFunction(value) {
  return typeof value === "function";
}
function buildResolvedRequest(entries) {
  const obj = Object.fromEntries(entries);
  return obj;
}
async function resolveAsyncFunctions(input, context) {
  const resolvedEntries = [];
  const clientOnlyFields = /* @__PURE__ */ new Set([
    "stopWhen",
    // Handled separately in ModelResult
    "state",
    // Client-side state management
    "requireApproval",
    // Client-side approval check function
    "approveToolCalls",
    // Client-side approval decisions
    "rejectToolCalls"
    // Client-side rejection decisions
  ]);
  for (const [key, value] of Object.entries(input)) {
    if (clientOnlyFields.has(key)) {
      continue;
    }
    if (isParameterFunction(value)) {
      try {
        const result = await Promise.resolve(value(context));
        resolvedEntries.push([key, result]);
      } catch (error48) {
        throw new Error(`Failed to resolve async function for field "${key}": ${error48 instanceof Error ? error48.message : String(error48)}`);
      }
    } else {
      resolvedEntries.push([key, value]);
    }
  }
  return buildResolvedRequest(resolvedEntries);
}
function hasAsyncFunctions(input) {
  if (!input || typeof input !== "object") {
    return false;
  }
  return Object.values(input).some((value) => typeof value === "function");
}
var init_async_params = __esm({
  "node_modules/@openrouter/sdk/esm/lib/async-params.js"() {
  }
});

// node_modules/@openrouter/sdk/esm/lib/url.js
function pathToFunc(pathPattern, options) {
  const paramRE = /\{([a-zA-Z0-9_][a-zA-Z0-9_-]*?)\}/g;
  return function buildURLPath(params = {}) {
    return pathPattern.replace(paramRE, function(_, placeholder) {
      if (!hasOwn.call(params, placeholder)) {
        throw new Error(`Parameter '${placeholder}' is required`);
      }
      const value = params[placeholder];
      if (typeof value !== "string" && typeof value !== "number") {
        throw new Error(`Parameter '${placeholder}' must be a string or number`);
      }
      return options?.charEncoding === "percent" ? encodeURIComponent(`${value}`) : `${value}`;
    });
  };
}
var hasOwn;
var init_url = __esm({
  "node_modules/@openrouter/sdk/esm/lib/url.js"() {
    hasOwn = Object.prototype.hasOwnProperty;
  }
});

// node_modules/@openrouter/sdk/esm/lib/config.js
function serverURLFromOptions(options) {
  let serverURL = options.serverURL;
  const params = {};
  if (!serverURL) {
    const server = options.server ?? ServerProduction;
    serverURL = ServerList[server] || "";
  }
  const u = pathToFunc(serverURL)(params);
  return new URL(u);
}
var ServerProduction, ServerList, SDK_METADATA;
var init_config = __esm({
  "node_modules/@openrouter/sdk/esm/lib/config.js"() {
    init_url();
    ServerProduction = "production";
    ServerList = {
      [ServerProduction]: "https://openrouter.ai/api/v1"
    };
    SDK_METADATA = {
      language: "typescript",
      openapiDocVersion: "1.0.0",
      sdkVersion: "0.8.0",
      genVersion: "2.788.4",
      userAgent: "speakeasy-sdk/typescript 0.8.0 2.788.4 1.0.0 @openrouter/sdk"
    };
  }
});

// node_modules/@openrouter/sdk/esm/lib/files.js
var init_files = __esm({
  "node_modules/@openrouter/sdk/esm/lib/files.js"() {
  }
});

// node_modules/@openrouter/sdk/esm/lib/http.js
function matchContentType(response, pattern) {
  if (pattern === "*") {
    return true;
  }
  let contentType = response.headers.get("content-type")?.trim() || "application/octet-stream";
  contentType = contentType.toLowerCase();
  const wantParts = pattern.toLowerCase().trim().split(mediaParamSeparator);
  const [wantType = "", ...wantParams] = wantParts;
  if (wantType.split("/").length !== 2) {
    return false;
  }
  const gotParts = contentType.split(mediaParamSeparator);
  const [gotType = "", ...gotParams] = gotParts;
  const [type = "", subtype = ""] = gotType.split("/");
  if (!type || !subtype) {
    return false;
  }
  if (wantType !== "*/*" && gotType !== wantType && `${type}/*` !== wantType && `*/${subtype}` !== wantType) {
    return false;
  }
  if (gotParams.length < wantParams.length) {
    return false;
  }
  const params = new Set(gotParams);
  for (const wantParam of wantParams) {
    if (!params.has(wantParam)) {
      return false;
    }
  }
  return true;
}
function matchStatusCode(response, codes) {
  const actual = `${response.status}`;
  const expectedCodes = Array.isArray(codes) ? codes : [codes];
  if (!expectedCodes.length) {
    return false;
  }
  return expectedCodes.some((ec) => {
    const code = `${ec}`;
    if (code === "default") {
      return true;
    }
    if (!codeRangeRE.test(`${code}`)) {
      return code === actual;
    }
    const expectFamily = code.charAt(0);
    if (!expectFamily) {
      throw new Error("Invalid status code range");
    }
    const actualFamily = actual.charAt(0);
    if (!actualFamily) {
      throw new Error(`Invalid response status code: ${actual}`);
    }
    return actualFamily === expectFamily;
  });
}
function matchResponse(response, code, contentTypePattern) {
  return matchStatusCode(response, code) && matchContentType(response, contentTypePattern);
}
function isConnectionError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isBrowserErr = err instanceof TypeError && err.message.toLowerCase().startsWith("failed to fetch");
  const isNodeErr = err instanceof TypeError && err.message.toLowerCase().startsWith("fetch failed");
  const isBunErr = "name" in err && err.name === "ConnectionError";
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnreset";
  return isBrowserErr || isNodeErr || isGenericErr || isBunErr;
}
function isTimeoutError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isNative = "name" in err && err.name === "TimeoutError";
  const isLegacyNative = "code" in err && err.code === 23;
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
  return isNative || isLegacyNative || isGenericErr;
}
function isAbortError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isNative = "name" in err && err.name === "AbortError";
  const isLegacyNative = "code" in err && err.code === 20;
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
  return isNative || isLegacyNative || isGenericErr;
}
var DEFAULT_FETCHER, HTTPClient, mediaParamSeparator, codeRangeRE;
var init_http = __esm({
  "node_modules/@openrouter/sdk/esm/lib/http.js"() {
    DEFAULT_FETCHER = (input, init) => {
      if (init == null) {
        return fetch(input);
      } else {
        return fetch(input, init);
      }
    };
    HTTPClient = class _HTTPClient {
      constructor(options = {}) {
        this.options = options;
        this.requestHooks = [];
        this.requestErrorHooks = [];
        this.responseHooks = [];
        this.fetcher = options.fetcher || DEFAULT_FETCHER;
      }
      async request(request) {
        let req = request;
        for (const hook of this.requestHooks) {
          const nextRequest = await hook(req);
          if (nextRequest) {
            req = nextRequest;
          }
        }
        try {
          const res = await this.fetcher(req);
          for (const hook of this.responseHooks) {
            await hook(res, req);
          }
          return res;
        } catch (err) {
          for (const hook of this.requestErrorHooks) {
            await hook(err, req);
          }
          throw err;
        }
      }
      addHook(...args) {
        if (args[0] === "beforeRequest") {
          this.requestHooks.push(args[1]);
        } else if (args[0] === "requestError") {
          this.requestErrorHooks.push(args[1]);
        } else if (args[0] === "response") {
          this.responseHooks.push(args[1]);
        } else {
          throw new Error(`Invalid hook type: ${args[0]}`);
        }
        return this;
      }
      removeHook(...args) {
        let target;
        if (args[0] === "beforeRequest") {
          target = this.requestHooks;
        } else if (args[0] === "requestError") {
          target = this.requestErrorHooks;
        } else if (args[0] === "response") {
          target = this.responseHooks;
        } else {
          throw new Error(`Invalid hook type: ${args[0]}`);
        }
        const index = target.findIndex((v) => v === args[1]);
        if (index >= 0) {
          target.splice(index, 1);
        }
        return this;
      }
      clone() {
        const child = new _HTTPClient(this.options);
        child.requestHooks = this.requestHooks.slice();
        child.requestErrorHooks = this.requestErrorHooks.slice();
        child.responseHooks = this.responseHooks.slice();
        return child;
      }
    };
    mediaParamSeparator = /\s*;\s*/g;
    codeRangeRE = new RegExp("^[0-9]xx$", "i");
  }
});

// node_modules/@openrouter/sdk/esm/lib/next-turn-params.js
function isRecord(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function buildNextTurnParamsContext(request) {
  return {
    input: request.input ?? [],
    model: request.model ?? "",
    models: request.models ?? [],
    temperature: request.temperature ?? null,
    maxOutputTokens: request.maxOutputTokens ?? null,
    topP: request.topP ?? null,
    topK: request.topK,
    instructions: request.instructions ?? null
  };
}
async function executeNextTurnParamsFunctions(toolCalls, tools, currentRequest) {
  const context = buildNextTurnParamsContext(currentRequest);
  const result = {};
  const workingContext = { ...context };
  for (const tool of tools) {
    if (!tool.function.nextTurnParams) {
      continue;
    }
    const callsForTool = toolCalls.filter((tc) => tc.name === tool.function.name);
    for (const call of callsForTool) {
      const nextParams = tool.function.nextTurnParams;
      if (!isRecord(call.arguments)) {
        const typeStr = Array.isArray(call.arguments) ? "array" : typeof call.arguments;
        throw new Error(`Tool call arguments for ${tool.function.name} must be an object, got ${typeStr}`);
      }
      await processNextTurnParamsForCall(nextParams, call.arguments, workingContext, result, tool.function.name);
    }
  }
  return result;
}
async function processNextTurnParamsForCall(nextParams, params, workingContext, result, toolName) {
  for (const paramKey of Object.keys(nextParams)) {
    const fn = nextParams[paramKey];
    if (typeof fn !== "function") {
      continue;
    }
    if (!isValidNextTurnParamKey(paramKey)) {
      if (process.env["NODE_ENV"] !== "production") {
        console.warn(`Invalid nextTurnParams key "${paramKey}" in tool "${toolName}". Valid keys: input, model, models, temperature, maxOutputTokens, topP, topK, instructions`);
      }
      continue;
    }
    const newValue = await Promise.resolve(fn(params, workingContext));
    setNextTurnParam(result, paramKey, newValue);
    setNextTurnParam(workingContext, paramKey, newValue);
  }
}
function isValidNextTurnParamKey(key) {
  const validKeys = /* @__PURE__ */ new Set([
    "input",
    "model",
    "models",
    "temperature",
    "maxOutputTokens",
    "topP",
    "topK",
    "instructions"
  ]);
  return validKeys.has(key);
}
function setNextTurnParam(target, key, value) {
  target[key] = value;
}
function applyNextTurnParamsToRequest(request, computedParams) {
  return {
    ...request,
    ...computedParams
  };
}
var init_next_turn_params = __esm({
  "node_modules/@openrouter/sdk/esm/lib/next-turn-params.js"() {
  }
});

// node_modules/@openrouter/sdk/esm/lib/stop-conditions.js
function stepCountIs(stepCount) {
  return ({ steps }) => steps.length >= stepCount;
}
async function isStopConditionMet(options) {
  const { stopConditions, steps } = options;
  const results = await Promise.all(stopConditions.map((condition) => Promise.resolve(condition({
    steps
  }))));
  return results.some((result) => result === true);
}
var init_stop_conditions = __esm({
  "node_modules/@openrouter/sdk/esm/lib/stop-conditions.js"() {
  }
});

// node_modules/@openrouter/sdk/esm/lib/tool-types.js
function hasExecuteFunction(tool) {
  return "execute" in tool.function && typeof tool.function.execute === "function";
}
function isGeneratorTool(tool) {
  return "eventSchema" in tool.function;
}
function isRegularExecuteTool(tool) {
  return hasExecuteFunction(tool) && !isGeneratorTool(tool);
}
var ToolType;
var init_tool_types = __esm({
  "node_modules/@openrouter/sdk/esm/lib/tool-types.js"() {
    (function(ToolType2) {
      ToolType2["Function"] = "function";
    })(ToolType || (ToolType = {}));
  }
});

// node_modules/@openrouter/sdk/esm/models/activityitem.js
var ActivityItem$inboundSchema;
var init_activityitem = __esm({
  "node_modules/@openrouter/sdk/esm/models/activityitem.js"() {
    init_v4();
    init_primitives();
    ActivityItem$inboundSchema = object({
      date: string2(),
      model: string2(),
      model_permaslug: string2(),
      endpoint_id: string2(),
      provider_name: string2(),
      usage: number2(),
      byok_usage_inference: number2(),
      requests: number2(),
      prompt_tokens: number2(),
      completion_tokens: number2(),
      reasoning_tokens: number2()
    }).transform((v) => {
      return remap(v, {
        "model_permaslug": "modelPermaslug",
        "endpoint_id": "endpointId",
        "provider_name": "providerName",
        "byok_usage_inference": "byokUsageInference",
        "prompt_tokens": "promptTokens",
        "completion_tokens": "completionTokens",
        "reasoning_tokens": "reasoningTokens"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatmessagecontentitemaudio.js
var ChatMessageContentItemAudioInputAudio$inboundSchema, ChatMessageContentItemAudioInputAudio$outboundSchema, ChatMessageContentItemAudio$inboundSchema, ChatMessageContentItemAudio$outboundSchema;
var init_chatmessagecontentitemaudio = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatmessagecontentitemaudio.js"() {
    init_v4();
    init_primitives();
    ChatMessageContentItemAudioInputAudio$inboundSchema = object({
      data: string2(),
      format: string2()
    });
    ChatMessageContentItemAudioInputAudio$outboundSchema = object({
      data: string2(),
      format: string2()
    });
    ChatMessageContentItemAudio$inboundSchema = object({
      type: literal("input_audio"),
      input_audio: lazy(() => ChatMessageContentItemAudioInputAudio$inboundSchema)
    }).transform((v) => {
      return remap(v, {
        "input_audio": "inputAudio"
      });
    });
    ChatMessageContentItemAudio$outboundSchema = object({
      type: literal("input_audio"),
      inputAudio: lazy(() => ChatMessageContentItemAudioInputAudio$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        inputAudio: "input_audio"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatmessagecontentitemimage.js
var ChatMessageContentItemImageDetail, ChatMessageContentItemImageDetail$inboundSchema, ChatMessageContentItemImageDetail$outboundSchema, ChatMessageContentItemImageImageUrl$inboundSchema, ChatMessageContentItemImageImageUrl$outboundSchema, ChatMessageContentItemImage$inboundSchema, ChatMessageContentItemImage$outboundSchema;
var init_chatmessagecontentitemimage = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatmessagecontentitemimage.js"() {
    init_v4();
    init_primitives();
    init_enums();
    ChatMessageContentItemImageDetail = {
      Auto: "auto",
      Low: "low",
      High: "high"
    };
    ChatMessageContentItemImageDetail$inboundSchema = inboundSchema(ChatMessageContentItemImageDetail);
    ChatMessageContentItemImageDetail$outboundSchema = outboundSchema(ChatMessageContentItemImageDetail);
    ChatMessageContentItemImageImageUrl$inboundSchema = object({
      url: string2(),
      detail: ChatMessageContentItemImageDetail$inboundSchema.optional()
    });
    ChatMessageContentItemImageImageUrl$outboundSchema = object({
      url: string2(),
      detail: ChatMessageContentItemImageDetail$outboundSchema.optional()
    });
    ChatMessageContentItemImage$inboundSchema = object({
      type: literal("image_url"),
      image_url: lazy(() => ChatMessageContentItemImageImageUrl$inboundSchema)
    }).transform((v) => {
      return remap(v, {
        "image_url": "imageUrl"
      });
    });
    ChatMessageContentItemImage$outboundSchema = object({
      type: literal("image_url"),
      imageUrl: lazy(() => ChatMessageContentItemImageImageUrl$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        imageUrl: "image_url"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatmessagecontentitemcachecontrol.js
var Ttl, Ttl$inboundSchema, Ttl$outboundSchema, ChatMessageContentItemCacheControl$inboundSchema, ChatMessageContentItemCacheControl$outboundSchema;
var init_chatmessagecontentitemcachecontrol = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatmessagecontentitemcachecontrol.js"() {
    init_v4();
    init_enums();
    Ttl = {
      Fivem: "5m",
      Oneh: "1h"
    };
    Ttl$inboundSchema = inboundSchema(Ttl);
    Ttl$outboundSchema = outboundSchema(Ttl);
    ChatMessageContentItemCacheControl$inboundSchema = object({
      type: literal("ephemeral"),
      ttl: Ttl$inboundSchema.optional()
    });
    ChatMessageContentItemCacheControl$outboundSchema = object({
      type: literal("ephemeral"),
      ttl: Ttl$outboundSchema.optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatmessagecontentitemtext.js
var ChatMessageContentItemText$inboundSchema, ChatMessageContentItemText$outboundSchema;
var init_chatmessagecontentitemtext = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatmessagecontentitemtext.js"() {
    init_v4();
    init_primitives();
    init_chatmessagecontentitemcachecontrol();
    ChatMessageContentItemText$inboundSchema = object({
      type: literal("text"),
      text: string2(),
      cache_control: ChatMessageContentItemCacheControl$inboundSchema.optional()
    }).transform((v) => {
      return remap(v, {
        "cache_control": "cacheControl"
      });
    });
    ChatMessageContentItemText$outboundSchema = object({
      type: literal("text"),
      text: string2(),
      cacheControl: ChatMessageContentItemCacheControl$outboundSchema.optional()
    }).transform((v) => {
      return remap(v, {
        cacheControl: "cache_control"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatmessagecontentitemvideo.js
var VideoUrl2$inboundSchema, VideoUrl2$outboundSchema, ChatMessageContentItemVideoVideoURL$inboundSchema, ChatMessageContentItemVideoVideoURL$outboundSchema, VideoUrl1$inboundSchema, VideoUrl1$outboundSchema, ChatMessageContentItemVideoInputVideo$inboundSchema, ChatMessageContentItemVideoInputVideo$outboundSchema, ChatMessageContentItemVideo$inboundSchema, ChatMessageContentItemVideo$outboundSchema;
var init_chatmessagecontentitemvideo = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatmessagecontentitemvideo.js"() {
    init_v4();
    init_primitives();
    VideoUrl2$inboundSchema = object({
      url: string2()
    });
    VideoUrl2$outboundSchema = object({
      url: string2()
    });
    ChatMessageContentItemVideoVideoURL$inboundSchema = object({
      type: literal("video_url"),
      video_url: lazy(() => VideoUrl2$inboundSchema)
    }).transform((v) => {
      return remap(v, {
        "video_url": "videoUrl"
      });
    });
    ChatMessageContentItemVideoVideoURL$outboundSchema = object({
      type: literal("video_url"),
      videoUrl: lazy(() => VideoUrl2$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        videoUrl: "video_url"
      });
    });
    VideoUrl1$inboundSchema = object({
      url: string2()
    });
    VideoUrl1$outboundSchema = object({
      url: string2()
    });
    ChatMessageContentItemVideoInputVideo$inboundSchema = object({
      type: literal("input_video"),
      video_url: lazy(() => VideoUrl1$inboundSchema)
    }).transform((v) => {
      return remap(v, {
        "video_url": "videoUrl"
      });
    });
    ChatMessageContentItemVideoInputVideo$outboundSchema = object({
      type: literal("input_video"),
      videoUrl: lazy(() => VideoUrl1$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        videoUrl: "video_url"
      });
    });
    ChatMessageContentItemVideo$inboundSchema = union([
      lazy(() => ChatMessageContentItemVideoInputVideo$inboundSchema),
      lazy(() => ChatMessageContentItemVideoVideoURL$inboundSchema)
    ]);
    ChatMessageContentItemVideo$outboundSchema = union([
      lazy(() => ChatMessageContentItemVideoInputVideo$outboundSchema),
      lazy(() => ChatMessageContentItemVideoVideoURL$outboundSchema)
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/chatmessagecontentitem.js
var ChatMessageContentItem$inboundSchema, ChatMessageContentItem$outboundSchema;
var init_chatmessagecontentitem = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatmessagecontentitem.js"() {
    init_v4();
    init_chatmessagecontentitemaudio();
    init_chatmessagecontentitemimage();
    init_chatmessagecontentitemtext();
    init_chatmessagecontentitemvideo();
    ChatMessageContentItem$inboundSchema = union([
      ChatMessageContentItemText$inboundSchema,
      ChatMessageContentItemImage$inboundSchema,
      ChatMessageContentItemAudio$inboundSchema,
      ChatMessageContentItemVideo$inboundSchema.and(object({ type: literal("input_video") })),
      lazy(() => ChatMessageContentItemVideo$inboundSchema).and(object({ type: literal("video_url") }))
    ]);
    ChatMessageContentItem$outboundSchema = union([
      ChatMessageContentItemText$outboundSchema,
      ChatMessageContentItemImage$outboundSchema,
      ChatMessageContentItemAudio$outboundSchema,
      ChatMessageContentItemVideo$outboundSchema.and(object({ type: literal("input_video") })),
      lazy(() => ChatMessageContentItemVideo$outboundSchema).and(object({ type: literal("video_url") }))
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/chatmessagetoolcall.js
var ChatMessageToolCallFunction$inboundSchema, ChatMessageToolCallFunction$outboundSchema, ChatMessageToolCall$inboundSchema, ChatMessageToolCall$outboundSchema;
var init_chatmessagetoolcall = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatmessagetoolcall.js"() {
    init_v4();
    ChatMessageToolCallFunction$inboundSchema = object({
      name: string2(),
      arguments: string2()
    });
    ChatMessageToolCallFunction$outboundSchema = object({
      name: string2(),
      arguments: string2()
    });
    ChatMessageToolCall$inboundSchema = object({
      id: string2(),
      type: literal("function"),
      function: lazy(() => ChatMessageToolCallFunction$inboundSchema)
    });
    ChatMessageToolCall$outboundSchema = object({
      id: string2(),
      type: literal("function"),
      function: lazy(() => ChatMessageToolCallFunction$outboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/schema19.js
var Schema21, Schema21$inboundSchema, Schema21$outboundSchema, Schema19ReasoningText$inboundSchema, Schema19ReasoningText$outboundSchema, Schema19ReasoningEncrypted$inboundSchema, Schema19ReasoningEncrypted$outboundSchema, Schema19ReasoningSummary$inboundSchema, Schema19ReasoningSummary$outboundSchema, Schema19$inboundSchema, Schema19$outboundSchema;
var init_schema19 = __esm({
  "node_modules/@openrouter/sdk/esm/models/schema19.js"() {
    init_v4();
    init_enums();
    Schema21 = {
      Unknown: "unknown",
      OpenaiResponsesV1: "openai-responses-v1",
      AzureOpenaiResponsesV1: "azure-openai-responses-v1",
      XaiResponsesV1: "xai-responses-v1",
      AnthropicClaudeV1: "anthropic-claude-v1",
      GoogleGeminiV1: "google-gemini-v1"
    };
    Schema21$inboundSchema = inboundSchema(Schema21);
    Schema21$outboundSchema = outboundSchema(Schema21);
    Schema19ReasoningText$inboundSchema = object({
      type: literal("reasoning.text"),
      text: nullable(string2()).optional(),
      signature: nullable(string2()).optional(),
      id: nullable(string2()).optional(),
      format: nullable(Schema21$inboundSchema).optional(),
      index: number2().optional()
    });
    Schema19ReasoningText$outboundSchema = object({
      type: literal("reasoning.text"),
      text: nullable(string2()).optional(),
      signature: nullable(string2()).optional(),
      id: nullable(string2()).optional(),
      format: nullable(Schema21$outboundSchema).optional(),
      index: number2().optional()
    });
    Schema19ReasoningEncrypted$inboundSchema = object({
      type: literal("reasoning.encrypted"),
      data: string2(),
      id: nullable(string2()).optional(),
      format: nullable(Schema21$inboundSchema).optional(),
      index: number2().optional()
    });
    Schema19ReasoningEncrypted$outboundSchema = object({
      type: literal("reasoning.encrypted"),
      data: string2(),
      id: nullable(string2()).optional(),
      format: nullable(Schema21$outboundSchema).optional(),
      index: number2().optional()
    });
    Schema19ReasoningSummary$inboundSchema = object({
      type: literal("reasoning.summary"),
      summary: string2(),
      id: nullable(string2()).optional(),
      format: nullable(Schema21$inboundSchema).optional(),
      index: number2().optional()
    });
    Schema19ReasoningSummary$outboundSchema = object({
      type: literal("reasoning.summary"),
      summary: string2(),
      id: nullable(string2()).optional(),
      format: nullable(Schema21$outboundSchema).optional(),
      index: number2().optional()
    });
    Schema19$inboundSchema = union([
      lazy(() => Schema19ReasoningSummary$inboundSchema),
      lazy(() => Schema19ReasoningEncrypted$inboundSchema),
      lazy(() => Schema19ReasoningText$inboundSchema)
    ]);
    Schema19$outboundSchema = union([
      lazy(() => Schema19ReasoningSummary$outboundSchema),
      lazy(() => Schema19ReasoningEncrypted$outboundSchema),
      lazy(() => Schema19ReasoningText$outboundSchema)
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/assistantmessage.js
var AssistantMessageContent$inboundSchema, AssistantMessageContent$outboundSchema, AssistantMessageImageUrl$inboundSchema, AssistantMessageImageUrl$outboundSchema, Image$inboundSchema, Image$outboundSchema, AssistantMessage$inboundSchema, AssistantMessage$outboundSchema;
var init_assistantmessage = __esm({
  "node_modules/@openrouter/sdk/esm/models/assistantmessage.js"() {
    init_v4();
    init_primitives();
    init_chatmessagecontentitem();
    init_chatmessagetoolcall();
    init_schema19();
    AssistantMessageContent$inboundSchema = union([string2(), array(ChatMessageContentItem$inboundSchema)]);
    AssistantMessageContent$outboundSchema = union([string2(), array(ChatMessageContentItem$outboundSchema)]);
    AssistantMessageImageUrl$inboundSchema = object({
      url: string2()
    });
    AssistantMessageImageUrl$outboundSchema = object({
      url: string2()
    });
    Image$inboundSchema = object({
      image_url: lazy(() => AssistantMessageImageUrl$inboundSchema)
    }).transform((v) => {
      return remap(v, {
        "image_url": "imageUrl"
      });
    });
    Image$outboundSchema = object({
      imageUrl: lazy(() => AssistantMessageImageUrl$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        imageUrl: "image_url"
      });
    });
    AssistantMessage$inboundSchema = object({
      role: literal("assistant"),
      content: nullable(union([string2(), array(ChatMessageContentItem$inboundSchema)])).optional(),
      name: string2().optional(),
      tool_calls: array(ChatMessageToolCall$inboundSchema).optional(),
      refusal: nullable(string2()).optional(),
      reasoning: nullable(string2()).optional(),
      reasoning_details: array(Schema19$inboundSchema).optional(),
      images: array(lazy(() => Image$inboundSchema)).optional()
    }).transform((v) => {
      return remap(v, {
        "tool_calls": "toolCalls",
        "reasoning_details": "reasoningDetails"
      });
    });
    AssistantMessage$outboundSchema = object({
      role: literal("assistant"),
      content: nullable(union([string2(), array(ChatMessageContentItem$outboundSchema)])).optional(),
      name: string2().optional(),
      toolCalls: array(ChatMessageToolCall$outboundSchema).optional(),
      refusal: nullable(string2()).optional(),
      reasoning: nullable(string2()).optional(),
      reasoningDetails: array(Schema19$outboundSchema).optional(),
      images: array(lazy(() => Image$outboundSchema)).optional()
    }).transform((v) => {
      return remap(v, {
        toolCalls: "tool_calls",
        reasoningDetails: "reasoning_details"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/badgatewayresponseerrordata.js
var BadGatewayResponseErrorData$inboundSchema;
var init_badgatewayresponseerrordata = __esm({
  "node_modules/@openrouter/sdk/esm/models/badgatewayresponseerrordata.js"() {
    init_v4();
    BadGatewayResponseErrorData$inboundSchema = object({
      code: int(),
      message: string2(),
      metadata: nullable(record(string2(), nullable(any()))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/badrequestresponseerrordata.js
var BadRequestResponseErrorData$inboundSchema;
var init_badrequestresponseerrordata = __esm({
  "node_modules/@openrouter/sdk/esm/models/badrequestresponseerrordata.js"() {
    init_v4();
    BadRequestResponseErrorData$inboundSchema = object({
      code: int(),
      message: string2(),
      metadata: nullable(record(string2(), nullable(any()))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatcompletionfinishreason.js
var ChatCompletionFinishReason, ChatCompletionFinishReason$inboundSchema;
var init_chatcompletionfinishreason = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatcompletionfinishreason.js"() {
    init_enums();
    ChatCompletionFinishReason = {
      ToolCalls: "tool_calls",
      Stop: "stop",
      Length: "length",
      ContentFilter: "content_filter",
      Error: "error"
    };
    ChatCompletionFinishReason$inboundSchema = inboundSchema(ChatCompletionFinishReason);
  }
});

// node_modules/@openrouter/sdk/esm/models/chaterror.js
var Code$inboundSchema, ChatErrorError$inboundSchema;
var init_chaterror = __esm({
  "node_modules/@openrouter/sdk/esm/models/chaterror.js"() {
    init_v4();
    Code$inboundSchema = union([
      string2(),
      number2()
    ]);
    ChatErrorError$inboundSchema = object({
      code: nullable(union([string2(), number2()])),
      message: string2(),
      param: nullable(string2()).optional(),
      type: nullable(string2()).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatstreamoptions.js
var ChatStreamOptions$outboundSchema;
var init_chatstreamoptions = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatstreamoptions.js"() {
    init_v4();
    init_primitives();
    ChatStreamOptions$outboundSchema = object({
      includeUsage: boolean2().optional()
    }).transform((v) => {
      return remap(v, {
        includeUsage: "include_usage"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/developermessage.js
var DeveloperMessageContent$outboundSchema, DeveloperMessage$outboundSchema;
var init_developermessage = __esm({
  "node_modules/@openrouter/sdk/esm/models/developermessage.js"() {
    init_v4();
    init_chatmessagecontentitemtext();
    DeveloperMessageContent$outboundSchema = union([string2(), array(ChatMessageContentItemText$outboundSchema)]);
    DeveloperMessage$outboundSchema = object({
      role: literal("developer"),
      content: union([
        string2(),
        array(ChatMessageContentItemText$outboundSchema)
      ]),
      name: string2().optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/systemmessage.js
var SystemMessageContent$outboundSchema, SystemMessage$outboundSchema;
var init_systemmessage = __esm({
  "node_modules/@openrouter/sdk/esm/models/systemmessage.js"() {
    init_v4();
    init_chatmessagecontentitemtext();
    SystemMessageContent$outboundSchema = union([string2(), array(ChatMessageContentItemText$outboundSchema)]);
    SystemMessage$outboundSchema = object({
      role: literal("system"),
      content: union([
        string2(),
        array(ChatMessageContentItemText$outboundSchema)
      ]),
      name: string2().optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/toolresponsemessage.js
var ToolResponseMessageContent$outboundSchema, ToolResponseMessage$outboundSchema;
var init_toolresponsemessage = __esm({
  "node_modules/@openrouter/sdk/esm/models/toolresponsemessage.js"() {
    init_v4();
    init_primitives();
    init_chatmessagecontentitem();
    ToolResponseMessageContent$outboundSchema = union([string2(), array(ChatMessageContentItem$outboundSchema)]);
    ToolResponseMessage$outboundSchema = object({
      role: literal("tool"),
      content: union([
        string2(),
        array(ChatMessageContentItem$outboundSchema)
      ]),
      toolCallId: string2()
    }).transform((v) => {
      return remap(v, {
        toolCallId: "tool_call_id"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/usermessage.js
var UserMessageContent$outboundSchema, UserMessage$outboundSchema;
var init_usermessage = __esm({
  "node_modules/@openrouter/sdk/esm/models/usermessage.js"() {
    init_v4();
    init_chatmessagecontentitem();
    UserMessageContent$outboundSchema = union([string2(), array(ChatMessageContentItem$outboundSchema)]);
    UserMessage$outboundSchema = object({
      role: literal("user"),
      content: union([
        string2(),
        array(ChatMessageContentItem$outboundSchema)
      ]),
      name: string2().optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/message.js
var Message$outboundSchema;
var init_message = __esm({
  "node_modules/@openrouter/sdk/esm/models/message.js"() {
    init_v4();
    init_assistantmessage();
    init_developermessage();
    init_systemmessage();
    init_toolresponsemessage();
    init_usermessage();
    Message$outboundSchema = union([
      SystemMessage$outboundSchema,
      UserMessage$outboundSchema,
      DeveloperMessage$outboundSchema,
      AssistantMessage$outboundSchema,
      ToolResponseMessage$outboundSchema
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/providersort.js
var ProviderSort, ProviderSort$outboundSchema;
var init_providersort = __esm({
  "node_modules/@openrouter/sdk/esm/models/providersort.js"() {
    init_enums();
    ProviderSort = {
      Price: "price",
      Throughput: "throughput",
      Latency: "latency"
    };
    ProviderSort$outboundSchema = outboundSchema(ProviderSort);
  }
});

// node_modules/@openrouter/sdk/esm/models/providersortconfig.js
var Partition, Partition$outboundSchema, ProviderSortConfig$outboundSchema;
var init_providersortconfig = __esm({
  "node_modules/@openrouter/sdk/esm/models/providersortconfig.js"() {
    init_v4();
    init_enums();
    init_providersort();
    Partition = {
      Model: "model",
      None: "none"
    };
    Partition$outboundSchema = outboundSchema(Partition);
    ProviderSortConfig$outboundSchema = object({
      by: nullable(ProviderSort$outboundSchema).optional(),
      partition: nullable(Partition$outboundSchema).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/providersortunion.js
var ProviderSortUnion$outboundSchema;
var init_providersortunion = __esm({
  "node_modules/@openrouter/sdk/esm/models/providersortunion.js"() {
    init_v4();
    init_providersort();
    init_providersortconfig();
    ProviderSortUnion$outboundSchema = union([ProviderSort$outboundSchema, ProviderSortConfig$outboundSchema]);
  }
});

// node_modules/@openrouter/sdk/esm/models/reasoningsummaryverbosity.js
var ReasoningSummaryVerbosity, ReasoningSummaryVerbosity$inboundSchema, ReasoningSummaryVerbosity$outboundSchema;
var init_reasoningsummaryverbosity = __esm({
  "node_modules/@openrouter/sdk/esm/models/reasoningsummaryverbosity.js"() {
    init_enums();
    ReasoningSummaryVerbosity = {
      Auto: "auto",
      Concise: "concise",
      Detailed: "detailed"
    };
    ReasoningSummaryVerbosity$inboundSchema = inboundSchema(ReasoningSummaryVerbosity);
    ReasoningSummaryVerbosity$outboundSchema = outboundSchema(ReasoningSummaryVerbosity);
  }
});

// node_modules/@openrouter/sdk/esm/models/jsonschemaconfig.js
var JSONSchemaConfig$outboundSchema;
var init_jsonschemaconfig = __esm({
  "node_modules/@openrouter/sdk/esm/models/jsonschemaconfig.js"() {
    init_v4();
    JSONSchemaConfig$outboundSchema = object({
      name: string2(),
      description: string2().optional(),
      schema: record(string2(), any()).optional(),
      strict: nullable(boolean2()).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responseformatjsonschema.js
var ResponseFormatJSONSchema$outboundSchema;
var init_responseformatjsonschema = __esm({
  "node_modules/@openrouter/sdk/esm/models/responseformatjsonschema.js"() {
    init_v4();
    init_primitives();
    init_jsonschemaconfig();
    ResponseFormatJSONSchema$outboundSchema = object({
      type: literal("json_schema"),
      jsonSchema: JSONSchemaConfig$outboundSchema
    }).transform((v) => {
      return remap(v, {
        jsonSchema: "json_schema"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responseformattextgrammar.js
var ResponseFormatTextGrammar$outboundSchema;
var init_responseformattextgrammar = __esm({
  "node_modules/@openrouter/sdk/esm/models/responseformattextgrammar.js"() {
    init_v4();
    ResponseFormatTextGrammar$outboundSchema = object({
      type: literal("grammar"),
      grammar: string2()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/schema14.js
var Schema14$outboundSchema;
var init_schema14 = __esm({
  "node_modules/@openrouter/sdk/esm/models/schema14.js"() {
    init_v4();
    Schema14$outboundSchema = union([number2(), string2(), any()]);
  }
});

// node_modules/@openrouter/sdk/esm/models/schema10.js
var Prompt$outboundSchema, Completion$outboundSchema, Schema10$outboundSchema;
var init_schema10 = __esm({
  "node_modules/@openrouter/sdk/esm/models/schema10.js"() {
    init_v4();
    init_schema14();
    Prompt$outboundSchema = union([number2(), string2(), any()]);
    Completion$outboundSchema = union([number2(), string2(), any()]);
    Schema10$outboundSchema = object({
      prompt: union([number2(), string2(), any()]).optional(),
      completion: union([number2(), string2(), any()]).optional(),
      image: Schema14$outboundSchema.optional(),
      audio: Schema14$outboundSchema.optional(),
      request: Schema14$outboundSchema.optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/schema17.js
var PdfEngine, Engine, Schema17ResponseHealing$outboundSchema, PdfEngine$outboundSchema, Pdf$outboundSchema, Schema17FileParser$outboundSchema, Engine$outboundSchema, Schema17Web$outboundSchema, Schema17Moderation$outboundSchema, Schema17AutoRouter$outboundSchema, Schema17$outboundSchema;
var init_schema17 = __esm({
  "node_modules/@openrouter/sdk/esm/models/schema17.js"() {
    init_v4();
    init_primitives();
    init_enums();
    PdfEngine = {
      MistralOcr: "mistral-ocr",
      PdfText: "pdf-text",
      Native: "native"
    };
    Engine = {
      Native: "native",
      Exa: "exa"
    };
    Schema17ResponseHealing$outboundSchema = object({
      id: literal("response-healing"),
      enabled: boolean2().optional()
    });
    PdfEngine$outboundSchema = outboundSchema(PdfEngine);
    Pdf$outboundSchema = object({
      engine: PdfEngine$outboundSchema.optional()
    });
    Schema17FileParser$outboundSchema = object({
      id: literal("file-parser"),
      enabled: boolean2().optional(),
      pdf: lazy(() => Pdf$outboundSchema).optional()
    });
    Engine$outboundSchema = outboundSchema(Engine);
    Schema17Web$outboundSchema = object({
      id: literal("web"),
      enabled: boolean2().optional(),
      maxResults: number2().optional(),
      searchPrompt: string2().optional(),
      engine: Engine$outboundSchema.optional()
    }).transform((v) => {
      return remap(v, {
        maxResults: "max_results",
        searchPrompt: "search_prompt"
      });
    });
    Schema17Moderation$outboundSchema = object({
      id: literal("moderation")
    });
    Schema17AutoRouter$outboundSchema = object({
      id: literal("auto-router"),
      enabled: boolean2().optional(),
      allowedModels: array(string2()).optional()
    }).transform((v) => {
      return remap(v, {
        allowedModels: "allowed_models"
      });
    });
    Schema17$outboundSchema = union([
      lazy(() => Schema17AutoRouter$outboundSchema),
      lazy(() => Schema17Moderation$outboundSchema),
      lazy(() => Schema17Web$outboundSchema),
      lazy(() => Schema17FileParser$outboundSchema),
      lazy(() => Schema17ResponseHealing$outboundSchema)
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/schema5.js
var Schema5Enum, Schema5Enum$outboundSchema, Schema5$outboundSchema;
var init_schema5 = __esm({
  "node_modules/@openrouter/sdk/esm/models/schema5.js"() {
    init_v4();
    init_enums();
    Schema5Enum = {
      Ai21: "AI21",
      AionLabs: "AionLabs",
      Alibaba: "Alibaba",
      Ambient: "Ambient",
      AmazonBedrock: "Amazon Bedrock",
      AmazonNova: "Amazon Nova",
      Anthropic: "Anthropic",
      ArceeAI: "Arcee AI",
      AtlasCloud: "AtlasCloud",
      Avian: "Avian",
      Azure: "Azure",
      BaseTen: "BaseTen",
      BytePlus: "BytePlus",
      BlackForestLabs: "Black Forest Labs",
      Cerebras: "Cerebras",
      Chutes: "Chutes",
      Cirrascale: "Cirrascale",
      Clarifai: "Clarifai",
      Cloudflare: "Cloudflare",
      Cohere: "Cohere",
      Crusoe: "Crusoe",
      DeepInfra: "DeepInfra",
      DeepSeek: "DeepSeek",
      Featherless: "Featherless",
      Fireworks: "Fireworks",
      Friendli: "Friendli",
      GMICloud: "GMICloud",
      Google: "Google",
      GoogleAIStudio: "Google AI Studio",
      Groq: "Groq",
      Hyperbolic: "Hyperbolic",
      Inception: "Inception",
      Inceptron: "Inceptron",
      InferenceNet: "InferenceNet",
      Infermatic: "Infermatic",
      Inflection: "Inflection",
      Liquid: "Liquid",
      Mara: "Mara",
      Mancer2: "Mancer 2",
      Minimax: "Minimax",
      ModelRun: "ModelRun",
      Mistral: "Mistral",
      Modular: "Modular",
      MoonshotAI: "Moonshot AI",
      Morph: "Morph",
      NCompass: "NCompass",
      Nebius: "Nebius",
      NextBit: "NextBit",
      Novita: "Novita",
      Nvidia: "Nvidia",
      OpenAI: "OpenAI",
      OpenInference: "OpenInference",
      Parasail: "Parasail",
      Perplexity: "Perplexity",
      Phala: "Phala",
      Relace: "Relace",
      SambaNova: "SambaNova",
      Seed: "Seed",
      SiliconFlow: "SiliconFlow",
      Sourceful: "Sourceful",
      StepFun: "StepFun",
      Stealth: "Stealth",
      StreamLake: "StreamLake",
      Switchpoint: "Switchpoint",
      Together: "Together",
      Upstage: "Upstage",
      Venice: "Venice",
      WandB: "WandB",
      Xiaomi: "Xiaomi",
      XAI: "xAI",
      ZAi: "Z.AI",
      FakeProvider: "FakeProvider"
    };
    Schema5Enum$outboundSchema = outboundSchema(Schema5Enum);
    Schema5$outboundSchema = union([Schema5Enum$outboundSchema, string2()]);
  }
});

// node_modules/@openrouter/sdk/esm/models/tooldefinitionjson.js
var ToolDefinitionJsonFunction$outboundSchema, ToolDefinitionJson$outboundSchema;
var init_tooldefinitionjson = __esm({
  "node_modules/@openrouter/sdk/esm/models/tooldefinitionjson.js"() {
    init_v4();
    ToolDefinitionJsonFunction$outboundSchema = object({
      name: string2(),
      description: string2().optional(),
      parameters: record(string2(), any()).optional(),
      strict: nullable(boolean2()).optional()
    });
    ToolDefinitionJson$outboundSchema = object({
      type: literal("function"),
      function: lazy(() => ToolDefinitionJsonFunction$outboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatgenerationparams.js
var Schema3, Schema8, Route, Effort, Modality, Schema3$outboundSchema, Schema8$outboundSchema, Schema15$outboundSchema, Schema15Union$outboundSchema, Schema0$outboundSchema, Route$outboundSchema, Effort$outboundSchema, Reasoning$outboundSchema, ResponseFormatPython$outboundSchema, ResponseFormatJSONObject$outboundSchema, ResponseFormatText$outboundSchema, ResponseFormat$outboundSchema, Stop$outboundSchema, Debug$outboundSchema, ChatGenerationParamsImageConfig$outboundSchema, Modality$outboundSchema, ChatGenerationParams$outboundSchema;
var init_chatgenerationparams = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatgenerationparams.js"() {
    init_v4();
    init_primitives();
    init_enums();
    init_chatstreamoptions();
    init_message();
    init_providersortunion();
    init_reasoningsummaryverbosity();
    init_responseformatjsonschema();
    init_responseformattextgrammar();
    init_schema10();
    init_schema17();
    init_schema5();
    init_tooldefinitionjson();
    Schema3 = {
      Deny: "deny",
      Allow: "allow"
    };
    Schema8 = {
      Int4: "int4",
      Int8: "int8",
      Fp4: "fp4",
      Fp6: "fp6",
      Fp8: "fp8",
      Fp16: "fp16",
      Bf16: "bf16",
      Fp32: "fp32",
      Unknown: "unknown"
    };
    Route = {
      Fallback: "fallback",
      Sort: "sort"
    };
    Effort = {
      Xhigh: "xhigh",
      High: "high",
      Medium: "medium",
      Low: "low",
      Minimal: "minimal",
      None: "none"
    };
    Modality = {
      Text: "text",
      Image: "image"
    };
    Schema3$outboundSchema = outboundSchema(Schema3);
    Schema8$outboundSchema = outboundSchema(Schema8);
    Schema15$outboundSchema = object({
      p50: nullable(number2()).optional(),
      p75: nullable(number2()).optional(),
      p90: nullable(number2()).optional(),
      p99: nullable(number2()).optional()
    });
    Schema15Union$outboundSchema = union([number2(), lazy(() => Schema15$outboundSchema)]);
    Schema0$outboundSchema = object({
      allowFallbacks: nullable(boolean2()).optional(),
      requireParameters: nullable(boolean2()).optional(),
      dataCollection: nullable(Schema3$outboundSchema).optional(),
      zdr: nullable(boolean2()).optional(),
      enforceDistillableText: nullable(boolean2()).optional(),
      order: nullable(array(Schema5$outboundSchema)).optional(),
      only: nullable(array(Schema5$outboundSchema)).optional(),
      ignore: nullable(array(Schema5$outboundSchema)).optional(),
      quantizations: nullable(array(Schema8$outboundSchema)).optional(),
      sort: nullable(ProviderSortUnion$outboundSchema).optional(),
      maxPrice: Schema10$outboundSchema.optional(),
      preferredMinThroughput: nullable(union([number2(), lazy(() => Schema15$outboundSchema)])).optional(),
      preferredMaxLatency: nullable(union([number2(), lazy(() => Schema15$outboundSchema)])).optional()
    }).transform((v) => {
      return remap(v, {
        allowFallbacks: "allow_fallbacks",
        requireParameters: "require_parameters",
        dataCollection: "data_collection",
        enforceDistillableText: "enforce_distillable_text",
        maxPrice: "max_price",
        preferredMinThroughput: "preferred_min_throughput",
        preferredMaxLatency: "preferred_max_latency"
      });
    });
    Route$outboundSchema = outboundSchema(Route);
    Effort$outboundSchema = outboundSchema(Effort);
    Reasoning$outboundSchema = object({
      effort: nullable(Effort$outboundSchema).optional(),
      summary: nullable(ReasoningSummaryVerbosity$outboundSchema).optional()
    });
    ResponseFormatPython$outboundSchema = object({
      type: literal("python")
    });
    ResponseFormatJSONObject$outboundSchema = object({
      type: literal("json_object")
    });
    ResponseFormatText$outboundSchema = object({
      type: literal("text")
    });
    ResponseFormat$outboundSchema = union([
      lazy(() => ResponseFormatText$outboundSchema),
      lazy(() => ResponseFormatJSONObject$outboundSchema),
      ResponseFormatJSONSchema$outboundSchema,
      ResponseFormatTextGrammar$outboundSchema,
      lazy(() => ResponseFormatPython$outboundSchema)
    ]);
    Stop$outboundSchema = union([
      string2(),
      array(string2())
    ]);
    Debug$outboundSchema = object({
      echoUpstreamBody: boolean2().optional()
    }).transform((v) => {
      return remap(v, {
        echoUpstreamBody: "echo_upstream_body"
      });
    });
    ChatGenerationParamsImageConfig$outboundSchema = union([string2(), number2(), array(any())]);
    Modality$outboundSchema = outboundSchema(Modality);
    ChatGenerationParams$outboundSchema = object({
      provider: nullable(lazy(() => Schema0$outboundSchema)).optional(),
      plugins: array(Schema17$outboundSchema).optional(),
      route: nullable(Route$outboundSchema).optional(),
      user: string2().optional(),
      sessionId: string2().optional(),
      messages: array(Message$outboundSchema),
      model: string2().optional(),
      models: array(string2()).optional(),
      frequencyPenalty: nullable(number2()).optional(),
      logitBias: nullable(record(string2(), number2())).optional(),
      logprobs: nullable(boolean2()).optional(),
      topLogprobs: nullable(number2()).optional(),
      maxCompletionTokens: nullable(number2()).optional(),
      maxTokens: nullable(number2()).optional(),
      metadata: record(string2(), string2()).optional(),
      presencePenalty: nullable(number2()).optional(),
      reasoning: lazy(() => Reasoning$outboundSchema).optional(),
      responseFormat: union([
        lazy(() => ResponseFormatText$outboundSchema),
        lazy(() => ResponseFormatJSONObject$outboundSchema),
        ResponseFormatJSONSchema$outboundSchema,
        ResponseFormatTextGrammar$outboundSchema,
        lazy(() => ResponseFormatPython$outboundSchema)
      ]).optional(),
      seed: nullable(int()).optional(),
      stop: nullable(union([string2(), array(string2())])).optional(),
      stream: boolean2().default(false),
      streamOptions: nullable(ChatStreamOptions$outboundSchema).optional(),
      temperature: nullable(number2()).optional(),
      toolChoice: any().optional(),
      tools: array(ToolDefinitionJson$outboundSchema).optional(),
      topP: nullable(number2()).optional(),
      debug: lazy(() => Debug$outboundSchema).optional(),
      imageConfig: record(string2(), union([string2(), number2(), array(any())])).optional(),
      modalities: array(Modality$outboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        sessionId: "session_id",
        frequencyPenalty: "frequency_penalty",
        logitBias: "logit_bias",
        topLogprobs: "top_logprobs",
        maxCompletionTokens: "max_completion_tokens",
        maxTokens: "max_tokens",
        presencePenalty: "presence_penalty",
        responseFormat: "response_format",
        streamOptions: "stream_options",
        toolChoice: "tool_choice",
        topP: "top_p",
        imageConfig: "image_config"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatgenerationtokenusage.js
var CompletionTokensDetails$inboundSchema, PromptTokensDetails$inboundSchema, ChatGenerationTokenUsage$inboundSchema;
var init_chatgenerationtokenusage = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatgenerationtokenusage.js"() {
    init_v4();
    init_primitives();
    CompletionTokensDetails$inboundSchema = object({
      reasoning_tokens: nullable(number2()).optional(),
      audio_tokens: nullable(number2()).optional(),
      accepted_prediction_tokens: nullable(number2()).optional(),
      rejected_prediction_tokens: nullable(number2()).optional()
    }).transform((v) => {
      return remap(v, {
        "reasoning_tokens": "reasoningTokens",
        "audio_tokens": "audioTokens",
        "accepted_prediction_tokens": "acceptedPredictionTokens",
        "rejected_prediction_tokens": "rejectedPredictionTokens"
      });
    });
    PromptTokensDetails$inboundSchema = object({
      cached_tokens: number2().optional(),
      cache_write_tokens: number2().optional(),
      audio_tokens: number2().optional(),
      video_tokens: number2().optional()
    }).transform((v) => {
      return remap(v, {
        "cached_tokens": "cachedTokens",
        "cache_write_tokens": "cacheWriteTokens",
        "audio_tokens": "audioTokens",
        "video_tokens": "videoTokens"
      });
    });
    ChatGenerationTokenUsage$inboundSchema = object({
      completion_tokens: number2(),
      prompt_tokens: number2(),
      total_tokens: number2(),
      completion_tokens_details: nullable(lazy(() => CompletionTokensDetails$inboundSchema)).optional(),
      prompt_tokens_details: nullable(lazy(() => PromptTokensDetails$inboundSchema)).optional()
    }).transform((v) => {
      return remap(v, {
        "completion_tokens": "completionTokens",
        "prompt_tokens": "promptTokens",
        "total_tokens": "totalTokens",
        "completion_tokens_details": "completionTokensDetails",
        "prompt_tokens_details": "promptTokensDetails"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatmessagetokenlogprob.js
var ChatMessageTokenLogprobTopLogprob$inboundSchema, ChatMessageTokenLogprob$inboundSchema;
var init_chatmessagetokenlogprob = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatmessagetokenlogprob.js"() {
    init_v4();
    init_primitives();
    ChatMessageTokenLogprobTopLogprob$inboundSchema = object({
      token: string2(),
      logprob: number2(),
      bytes: nullable(array(number2()))
    });
    ChatMessageTokenLogprob$inboundSchema = object({
      token: string2(),
      logprob: number2(),
      bytes: nullable(array(number2())),
      top_logprobs: array(lazy(() => ChatMessageTokenLogprobTopLogprob$inboundSchema))
    }).transform((v) => {
      return remap(v, {
        "top_logprobs": "topLogprobs"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatmessagetokenlogprobs.js
var ChatMessageTokenLogprobs$inboundSchema;
var init_chatmessagetokenlogprobs = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatmessagetokenlogprobs.js"() {
    init_v4();
    init_chatmessagetokenlogprob();
    ChatMessageTokenLogprobs$inboundSchema = object({
      content: nullable(array(ChatMessageTokenLogprob$inboundSchema)),
      refusal: nullable(array(ChatMessageTokenLogprob$inboundSchema))
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatresponsechoice.js
var ChatResponseChoice$inboundSchema;
var init_chatresponsechoice = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatresponsechoice.js"() {
    init_v4();
    init_primitives();
    init_assistantmessage();
    init_chatcompletionfinishreason();
    init_chatmessagetokenlogprobs();
    ChatResponseChoice$inboundSchema = object({
      finish_reason: nullable(ChatCompletionFinishReason$inboundSchema),
      index: number2(),
      message: AssistantMessage$inboundSchema,
      logprobs: nullable(ChatMessageTokenLogprobs$inboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        "finish_reason": "finishReason"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatresponse.js
var ChatResponse$inboundSchema;
var init_chatresponse = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatresponse.js"() {
    init_v4();
    init_primitives();
    init_chatgenerationtokenusage();
    init_chatresponsechoice();
    ChatResponse$inboundSchema = object({
      id: string2(),
      choices: array(ChatResponseChoice$inboundSchema),
      created: number2(),
      model: string2(),
      object: literal("chat.completion"),
      system_fingerprint: nullable(string2()).optional(),
      usage: ChatGenerationTokenUsage$inboundSchema.optional()
    }).transform((v) => {
      return remap(v, {
        "system_fingerprint": "systemFingerprint"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatstreamingmessagetoolcall.js
var ChatStreamingMessageToolCallFunction$inboundSchema, ChatStreamingMessageToolCall$inboundSchema;
var init_chatstreamingmessagetoolcall = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatstreamingmessagetoolcall.js"() {
    init_v4();
    ChatStreamingMessageToolCallFunction$inboundSchema = object({
      name: string2().optional(),
      arguments: string2().optional()
    });
    ChatStreamingMessageToolCall$inboundSchema = object({
      index: number2(),
      id: string2().optional(),
      type: literal("function").optional(),
      function: lazy(() => ChatStreamingMessageToolCallFunction$inboundSchema).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatstreamingmessagechunk.js
var ChatStreamingMessageChunkRole, ChatStreamingMessageChunkRole$inboundSchema, ChatStreamingMessageChunk$inboundSchema;
var init_chatstreamingmessagechunk = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatstreamingmessagechunk.js"() {
    init_v4();
    init_primitives();
    init_chatstreamingmessagetoolcall();
    init_schema19();
    ChatStreamingMessageChunkRole = {
      Assistant: "assistant"
    };
    ChatStreamingMessageChunkRole$inboundSchema = _enum2(ChatStreamingMessageChunkRole);
    ChatStreamingMessageChunk$inboundSchema = object({
      role: ChatStreamingMessageChunkRole$inboundSchema.optional(),
      content: nullable(string2()).optional(),
      reasoning: nullable(string2()).optional(),
      refusal: nullable(string2()).optional(),
      tool_calls: array(ChatStreamingMessageToolCall$inboundSchema).optional(),
      reasoning_details: array(Schema19$inboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        "tool_calls": "toolCalls",
        "reasoning_details": "reasoningDetails"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatstreamingchoice.js
var ChatStreamingChoice$inboundSchema;
var init_chatstreamingchoice = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatstreamingchoice.js"() {
    init_v4();
    init_primitives();
    init_chatcompletionfinishreason();
    init_chatmessagetokenlogprobs();
    init_chatstreamingmessagechunk();
    ChatStreamingChoice$inboundSchema = object({
      delta: ChatStreamingMessageChunk$inboundSchema,
      finish_reason: nullable(ChatCompletionFinishReason$inboundSchema),
      index: number2(),
      logprobs: nullable(ChatMessageTokenLogprobs$inboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        "finish_reason": "finishReason"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/chatstreamingresponsechunk.js
var ChatStreamingResponseChunkError$inboundSchema, ChatStreamingResponseChunkData$inboundSchema, ChatStreamingResponseChunk$inboundSchema;
var init_chatstreamingresponsechunk = __esm({
  "node_modules/@openrouter/sdk/esm/models/chatstreamingresponsechunk.js"() {
    init_v4();
    init_primitives();
    init_chatgenerationtokenusage();
    init_chatstreamingchoice();
    ChatStreamingResponseChunkError$inboundSchema = object({
      message: string2(),
      code: number2()
    });
    ChatStreamingResponseChunkData$inboundSchema = object({
      id: string2(),
      choices: array(ChatStreamingChoice$inboundSchema),
      created: number2(),
      model: string2(),
      object: literal("chat.completion.chunk"),
      system_fingerprint: nullable(string2()).optional(),
      error: lazy(() => ChatStreamingResponseChunkError$inboundSchema).optional(),
      usage: ChatGenerationTokenUsage$inboundSchema.optional()
    }).transform((v) => {
      return remap(v, {
        "system_fingerprint": "systemFingerprint"
      });
    });
    ChatStreamingResponseChunk$inboundSchema = object({
      data: string2().transform((v, ctx) => {
        try {
          return JSON.parse(v);
        } catch (err) {
          ctx.addIssue({
            input: v,
            code: "custom",
            message: `malformed json: ${err}`
          });
          return NEVER;
        }
      }).pipe(lazy(() => ChatStreamingResponseChunkData$inboundSchema))
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/createchargerequest.js
var ChainId, ChainId$outboundSchema, CreateChargeRequest$outboundSchema;
var init_createchargerequest = __esm({
  "node_modules/@openrouter/sdk/esm/models/createchargerequest.js"() {
    init_v4();
    init_primitives();
    init_enums();
    ChainId = {
      One: 1,
      OneHundredAndThirtySeven: 137,
      EightThousandFourHundredAndFiftyThree: 8453
    };
    ChainId$outboundSchema = outboundSchemaInt(ChainId);
    CreateChargeRequest$outboundSchema = object({
      amount: number2(),
      sender: string2(),
      chainId: ChainId$outboundSchema
    }).transform((v) => {
      return remap(v, {
        chainId: "chain_id"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/datacollection.js
var DataCollection, DataCollection$outboundSchema;
var init_datacollection = __esm({
  "node_modules/@openrouter/sdk/esm/models/datacollection.js"() {
    init_enums();
    DataCollection = {
      Deny: "deny",
      Allow: "allow"
    };
    DataCollection$outboundSchema = outboundSchema(DataCollection);
  }
});

// node_modules/@openrouter/sdk/esm/models/defaultparameters.js
var DefaultParameters$inboundSchema;
var init_defaultparameters = __esm({
  "node_modules/@openrouter/sdk/esm/models/defaultparameters.js"() {
    init_v4();
    init_primitives();
    DefaultParameters$inboundSchema = object({
      temperature: nullable(number2()).optional(),
      top_p: nullable(number2()).optional(),
      frequency_penalty: nullable(number2()).optional()
    }).transform((v) => {
      return remap(v, {
        "top_p": "topP",
        "frequency_penalty": "frequencyPenalty"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/edgenetworktimeoutresponseerrordata.js
var EdgeNetworkTimeoutResponseErrorData$inboundSchema;
var init_edgenetworktimeoutresponseerrordata = __esm({
  "node_modules/@openrouter/sdk/esm/models/edgenetworktimeoutresponseerrordata.js"() {
    init_v4();
    EdgeNetworkTimeoutResponseErrorData$inboundSchema = object({
      code: int(),
      message: string2(),
      metadata: nullable(record(string2(), nullable(any()))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/endpointstatus.js
var EndpointStatus, EndpointStatus$inboundSchema;
var init_endpointstatus = __esm({
  "node_modules/@openrouter/sdk/esm/models/endpointstatus.js"() {
    init_enums();
    EndpointStatus = {
      Zero: 0,
      Minus1: -1,
      Minus2: -2,
      Minus3: -3,
      Minus5: -5,
      Minus10: -10
    };
    EndpointStatus$inboundSchema = inboundSchemaInt(EndpointStatus);
  }
});

// node_modules/@openrouter/sdk/esm/models/filecitation.js
var FileCitation$inboundSchema, FileCitation$outboundSchema;
var init_filecitation = __esm({
  "node_modules/@openrouter/sdk/esm/models/filecitation.js"() {
    init_v4();
    init_primitives();
    FileCitation$inboundSchema = object({
      type: literal("file_citation"),
      file_id: string2(),
      filename: string2(),
      index: number2()
    }).transform((v) => {
      return remap(v, {
        "file_id": "fileId"
      });
    });
    FileCitation$outboundSchema = object({
      type: literal("file_citation"),
      fileId: string2(),
      filename: string2(),
      index: number2()
    }).transform((v) => {
      return remap(v, {
        fileId: "file_id"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/filepath.js
var FilePath$inboundSchema, FilePath$outboundSchema;
var init_filepath = __esm({
  "node_modules/@openrouter/sdk/esm/models/filepath.js"() {
    init_v4();
    init_primitives();
    FilePath$inboundSchema = object({
      type: literal("file_path"),
      file_id: string2(),
      index: number2()
    }).transform((v) => {
      return remap(v, {
        "file_id": "fileId"
      });
    });
    FilePath$outboundSchema = object({
      type: literal("file_path"),
      fileId: string2(),
      index: number2()
    }).transform((v) => {
      return remap(v, {
        fileId: "file_id"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/forbiddenresponseerrordata.js
var ForbiddenResponseErrorData$inboundSchema;
var init_forbiddenresponseerrordata = __esm({
  "node_modules/@openrouter/sdk/esm/models/forbiddenresponseerrordata.js"() {
    init_v4();
    ForbiddenResponseErrorData$inboundSchema = object({
      code: int(),
      message: string2(),
      metadata: nullable(record(string2(), nullable(any()))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/imagegenerationstatus.js
var ImageGenerationStatus, ImageGenerationStatus$inboundSchema, ImageGenerationStatus$outboundSchema;
var init_imagegenerationstatus = __esm({
  "node_modules/@openrouter/sdk/esm/models/imagegenerationstatus.js"() {
    init_enums();
    ImageGenerationStatus = {
      InProgress: "in_progress",
      Completed: "completed",
      Generating: "generating",
      Failed: "failed"
    };
    ImageGenerationStatus$inboundSchema = inboundSchema(ImageGenerationStatus);
    ImageGenerationStatus$outboundSchema = outboundSchema(ImageGenerationStatus);
  }
});

// node_modules/@openrouter/sdk/esm/models/inputmodality.js
var InputModality, InputModality$inboundSchema;
var init_inputmodality = __esm({
  "node_modules/@openrouter/sdk/esm/models/inputmodality.js"() {
    init_enums();
    InputModality = {
      Text: "text",
      Image: "image",
      File: "file",
      Audio: "audio",
      Video: "video"
    };
    InputModality$inboundSchema = inboundSchema(InputModality);
  }
});

// node_modules/@openrouter/sdk/esm/models/instructtype.js
var InstructType, InstructType$inboundSchema;
var init_instructtype = __esm({
  "node_modules/@openrouter/sdk/esm/models/instructtype.js"() {
    init_enums();
    InstructType = {
      None: "none",
      Airoboros: "airoboros",
      Alpaca: "alpaca",
      AlpacaModif: "alpaca-modif",
      Chatml: "chatml",
      Claude: "claude",
      CodeLlama: "code-llama",
      Gemma: "gemma",
      Llama2: "llama2",
      Llama3: "llama3",
      Mistral: "mistral",
      Nemotron: "nemotron",
      Neural: "neural",
      Openchat: "openchat",
      Phi3: "phi3",
      Rwkv: "rwkv",
      Vicuna: "vicuna",
      Zephyr: "zephyr",
      DeepseekR1: "deepseek-r1",
      DeepseekV31: "deepseek-v3.1",
      Qwq: "qwq",
      Qwen3: "qwen3"
    };
    InstructType$inboundSchema = inboundSchema(InstructType);
  }
});

// node_modules/@openrouter/sdk/esm/models/internalserverresponseerrordata.js
var InternalServerResponseErrorData$inboundSchema;
var init_internalserverresponseerrordata = __esm({
  "node_modules/@openrouter/sdk/esm/models/internalserverresponseerrordata.js"() {
    init_v4();
    InternalServerResponseErrorData$inboundSchema = object({
      code: int(),
      message: string2(),
      metadata: nullable(record(string2(), nullable(any()))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/outputmodality.js
var OutputModality, OutputModality$inboundSchema;
var init_outputmodality = __esm({
  "node_modules/@openrouter/sdk/esm/models/outputmodality.js"() {
    init_enums();
    OutputModality = {
      Text: "text",
      Image: "image",
      Embeddings: "embeddings",
      Audio: "audio"
    };
    OutputModality$inboundSchema = inboundSchema(OutputModality);
  }
});

// node_modules/@openrouter/sdk/esm/models/parameter.js
var Parameter, Parameter$inboundSchema;
var init_parameter = __esm({
  "node_modules/@openrouter/sdk/esm/models/parameter.js"() {
    init_enums();
    Parameter = {
      Temperature: "temperature",
      TopP: "top_p",
      TopK: "top_k",
      MinP: "min_p",
      TopA: "top_a",
      FrequencyPenalty: "frequency_penalty",
      PresencePenalty: "presence_penalty",
      RepetitionPenalty: "repetition_penalty",
      MaxTokens: "max_tokens",
      LogitBias: "logit_bias",
      Logprobs: "logprobs",
      TopLogprobs: "top_logprobs",
      Seed: "seed",
      ResponseFormat: "response_format",
      StructuredOutputs: "structured_outputs",
      Stop: "stop",
      Tools: "tools",
      ToolChoice: "tool_choice",
      ParallelToolCalls: "parallel_tool_calls",
      IncludeReasoning: "include_reasoning",
      Reasoning: "reasoning",
      ReasoningEffort: "reasoning_effort",
      WebSearchOptions: "web_search_options",
      Verbosity: "verbosity"
    };
    Parameter$inboundSchema = inboundSchema(Parameter);
  }
});

// node_modules/@openrouter/sdk/esm/models/percentilestats.js
var PercentileStats$inboundSchema;
var init_percentilestats = __esm({
  "node_modules/@openrouter/sdk/esm/models/percentilestats.js"() {
    init_v4();
    PercentileStats$inboundSchema = object({
      p50: number2(),
      p75: number2(),
      p90: number2(),
      p99: number2()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/providername.js
var ProviderName, ProviderName$inboundSchema, ProviderName$outboundSchema;
var init_providername = __esm({
  "node_modules/@openrouter/sdk/esm/models/providername.js"() {
    init_enums();
    ProviderName = {
      Ai21: "AI21",
      AionLabs: "AionLabs",
      Alibaba: "Alibaba",
      Ambient: "Ambient",
      AmazonBedrock: "Amazon Bedrock",
      AmazonNova: "Amazon Nova",
      Anthropic: "Anthropic",
      ArceeAI: "Arcee AI",
      AtlasCloud: "AtlasCloud",
      Avian: "Avian",
      Azure: "Azure",
      BaseTen: "BaseTen",
      BytePlus: "BytePlus",
      BlackForestLabs: "Black Forest Labs",
      Cerebras: "Cerebras",
      Chutes: "Chutes",
      Cirrascale: "Cirrascale",
      Clarifai: "Clarifai",
      Cloudflare: "Cloudflare",
      Cohere: "Cohere",
      Crusoe: "Crusoe",
      DeepInfra: "DeepInfra",
      DeepSeek: "DeepSeek",
      Featherless: "Featherless",
      Fireworks: "Fireworks",
      Friendli: "Friendli",
      GMICloud: "GMICloud",
      Google: "Google",
      GoogleAIStudio: "Google AI Studio",
      Groq: "Groq",
      Hyperbolic: "Hyperbolic",
      Inception: "Inception",
      Inceptron: "Inceptron",
      InferenceNet: "InferenceNet",
      Infermatic: "Infermatic",
      Inflection: "Inflection",
      Liquid: "Liquid",
      Mara: "Mara",
      Mancer2: "Mancer 2",
      Minimax: "Minimax",
      ModelRun: "ModelRun",
      Mistral: "Mistral",
      Modular: "Modular",
      MoonshotAI: "Moonshot AI",
      Morph: "Morph",
      NCompass: "NCompass",
      Nebius: "Nebius",
      NextBit: "NextBit",
      Novita: "Novita",
      Nvidia: "Nvidia",
      OpenAI: "OpenAI",
      OpenInference: "OpenInference",
      Parasail: "Parasail",
      Perplexity: "Perplexity",
      Phala: "Phala",
      Relace: "Relace",
      SambaNova: "SambaNova",
      Seed: "Seed",
      SiliconFlow: "SiliconFlow",
      Sourceful: "Sourceful",
      StepFun: "StepFun",
      Stealth: "Stealth",
      StreamLake: "StreamLake",
      Switchpoint: "Switchpoint",
      Together: "Together",
      Upstage: "Upstage",
      Venice: "Venice",
      WandB: "WandB",
      Xiaomi: "Xiaomi",
      XAI: "xAI",
      ZAi: "Z.AI",
      FakeProvider: "FakeProvider"
    };
    ProviderName$inboundSchema = inboundSchema(ProviderName);
    ProviderName$outboundSchema = outboundSchema(ProviderName);
  }
});

// node_modules/@openrouter/sdk/esm/models/publicendpoint.js
var PublicEndpointQuantization, Pricing$inboundSchema, PublicEndpointQuantization$inboundSchema, PublicEndpoint$inboundSchema;
var init_publicendpoint = __esm({
  "node_modules/@openrouter/sdk/esm/models/publicendpoint.js"() {
    init_v4();
    init_primitives();
    init_enums();
    init_endpointstatus();
    init_parameter();
    init_percentilestats();
    init_providername();
    PublicEndpointQuantization = {
      Int4: "int4",
      Int8: "int8",
      Fp4: "fp4",
      Fp6: "fp6",
      Fp8: "fp8",
      Fp16: "fp16",
      Bf16: "bf16",
      Fp32: "fp32",
      Unknown: "unknown"
    };
    Pricing$inboundSchema = object({
      prompt: string2(),
      completion: string2(),
      request: string2().optional(),
      image: string2().optional(),
      image_token: string2().optional(),
      image_output: string2().optional(),
      audio: string2().optional(),
      audio_output: string2().optional(),
      input_audio_cache: string2().optional(),
      web_search: string2().optional(),
      internal_reasoning: string2().optional(),
      input_cache_read: string2().optional(),
      input_cache_write: string2().optional(),
      discount: number2().optional()
    }).transform((v) => {
      return remap(v, {
        "image_token": "imageToken",
        "image_output": "imageOutput",
        "audio_output": "audioOutput",
        "input_audio_cache": "inputAudioCache",
        "web_search": "webSearch",
        "internal_reasoning": "internalReasoning",
        "input_cache_read": "inputCacheRead",
        "input_cache_write": "inputCacheWrite"
      });
    });
    PublicEndpointQuantization$inboundSchema = inboundSchema(PublicEndpointQuantization);
    PublicEndpoint$inboundSchema = object({
      name: string2(),
      model_id: string2(),
      model_name: string2(),
      context_length: number2(),
      pricing: lazy(() => Pricing$inboundSchema),
      provider_name: ProviderName$inboundSchema,
      tag: string2(),
      quantization: nullable(PublicEndpointQuantization$inboundSchema),
      max_completion_tokens: nullable(number2()),
      max_prompt_tokens: nullable(number2()),
      supported_parameters: array(Parameter$inboundSchema),
      status: EndpointStatus$inboundSchema.optional(),
      uptime_last_30m: nullable(number2()),
      supports_implicit_caching: boolean2(),
      latency_last_30m: nullable(PercentileStats$inboundSchema),
      throughput_last_30m: nullable(PercentileStats$inboundSchema)
    }).transform((v) => {
      return remap(v, {
        "model_id": "modelId",
        "model_name": "modelName",
        "context_length": "contextLength",
        "provider_name": "providerName",
        "max_completion_tokens": "maxCompletionTokens",
        "max_prompt_tokens": "maxPromptTokens",
        "supported_parameters": "supportedParameters",
        "uptime_last_30m": "uptimeLast30m",
        "supports_implicit_caching": "supportsImplicitCaching",
        "latency_last_30m": "latencyLast30m",
        "throughput_last_30m": "throughputLast30m"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/listendpointsresponse.js
var Tokenizer, Tokenizer$inboundSchema, Architecture$inboundSchema, ListEndpointsResponse$inboundSchema;
var init_listendpointsresponse = __esm({
  "node_modules/@openrouter/sdk/esm/models/listendpointsresponse.js"() {
    init_v4();
    init_primitives();
    init_enums();
    init_inputmodality();
    init_instructtype();
    init_outputmodality();
    init_publicendpoint();
    Tokenizer = {
      Router: "Router",
      Media: "Media",
      Other: "Other",
      Gpt: "GPT",
      Claude: "Claude",
      Gemini: "Gemini",
      Grok: "Grok",
      Cohere: "Cohere",
      Nova: "Nova",
      Qwen: "Qwen",
      Yi: "Yi",
      DeepSeek: "DeepSeek",
      Mistral: "Mistral",
      Llama2: "Llama2",
      Llama3: "Llama3",
      Llama4: "Llama4",
      PaLM: "PaLM",
      Rwkv: "RWKV",
      Qwen3: "Qwen3"
    };
    Tokenizer$inboundSchema = inboundSchema(Tokenizer);
    Architecture$inboundSchema = object({
      tokenizer: nullable(Tokenizer$inboundSchema),
      instruct_type: nullable(InstructType$inboundSchema),
      modality: nullable(string2()),
      input_modalities: array(InputModality$inboundSchema),
      output_modalities: array(OutputModality$inboundSchema)
    }).transform((v) => {
      return remap(v, {
        "instruct_type": "instructType",
        "input_modalities": "inputModalities",
        "output_modalities": "outputModalities"
      });
    });
    ListEndpointsResponse$inboundSchema = object({
      id: string2(),
      name: string2(),
      created: number2(),
      description: string2(),
      architecture: lazy(() => Architecture$inboundSchema),
      endpoints: array(PublicEndpoint$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/modelgroup.js
var ModelGroup, ModelGroup$inboundSchema;
var init_modelgroup = __esm({
  "node_modules/@openrouter/sdk/esm/models/modelgroup.js"() {
    init_enums();
    ModelGroup = {
      Router: "Router",
      Media: "Media",
      Other: "Other",
      Gpt: "GPT",
      Claude: "Claude",
      Gemini: "Gemini",
      Grok: "Grok",
      Cohere: "Cohere",
      Nova: "Nova",
      Qwen: "Qwen",
      Yi: "Yi",
      DeepSeek: "DeepSeek",
      Mistral: "Mistral",
      Llama2: "Llama2",
      Llama3: "Llama3",
      Llama4: "Llama4",
      PaLM: "PaLM",
      Rwkv: "RWKV",
      Qwen3: "Qwen3"
    };
    ModelGroup$inboundSchema = inboundSchema(ModelGroup);
  }
});

// node_modules/@openrouter/sdk/esm/models/modelarchitecture.js
var ModelArchitectureInstructType, ModelArchitectureInstructType$inboundSchema, ModelArchitecture$inboundSchema;
var init_modelarchitecture = __esm({
  "node_modules/@openrouter/sdk/esm/models/modelarchitecture.js"() {
    init_v4();
    init_primitives();
    init_enums();
    init_inputmodality();
    init_modelgroup();
    init_outputmodality();
    ModelArchitectureInstructType = {
      None: "none",
      Airoboros: "airoboros",
      Alpaca: "alpaca",
      AlpacaModif: "alpaca-modif",
      Chatml: "chatml",
      Claude: "claude",
      CodeLlama: "code-llama",
      Gemma: "gemma",
      Llama2: "llama2",
      Llama3: "llama3",
      Mistral: "mistral",
      Nemotron: "nemotron",
      Neural: "neural",
      Openchat: "openchat",
      Phi3: "phi3",
      Rwkv: "rwkv",
      Vicuna: "vicuna",
      Zephyr: "zephyr",
      DeepseekR1: "deepseek-r1",
      DeepseekV31: "deepseek-v3.1",
      Qwq: "qwq",
      Qwen3: "qwen3"
    };
    ModelArchitectureInstructType$inboundSchema = inboundSchema(ModelArchitectureInstructType);
    ModelArchitecture$inboundSchema = object({
      tokenizer: ModelGroup$inboundSchema.optional(),
      instruct_type: nullable(ModelArchitectureInstructType$inboundSchema).optional(),
      modality: nullable(string2()),
      input_modalities: array(InputModality$inboundSchema),
      output_modalities: array(OutputModality$inboundSchema)
    }).transform((v) => {
      return remap(v, {
        "instruct_type": "instructType",
        "input_modalities": "inputModalities",
        "output_modalities": "outputModalities"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/perrequestlimits.js
var PerRequestLimits$inboundSchema;
var init_perrequestlimits = __esm({
  "node_modules/@openrouter/sdk/esm/models/perrequestlimits.js"() {
    init_v4();
    init_primitives();
    PerRequestLimits$inboundSchema = object({
      prompt_tokens: number2(),
      completion_tokens: number2()
    }).transform((v) => {
      return remap(v, {
        "prompt_tokens": "promptTokens",
        "completion_tokens": "completionTokens"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/publicpricing.js
var PublicPricing$inboundSchema;
var init_publicpricing = __esm({
  "node_modules/@openrouter/sdk/esm/models/publicpricing.js"() {
    init_v4();
    init_primitives();
    PublicPricing$inboundSchema = object({
      prompt: string2(),
      completion: string2(),
      request: string2().optional(),
      image: string2().optional(),
      image_token: string2().optional(),
      image_output: string2().optional(),
      audio: string2().optional(),
      audio_output: string2().optional(),
      input_audio_cache: string2().optional(),
      web_search: string2().optional(),
      internal_reasoning: string2().optional(),
      input_cache_read: string2().optional(),
      input_cache_write: string2().optional(),
      discount: number2().optional()
    }).transform((v) => {
      return remap(v, {
        "image_token": "imageToken",
        "image_output": "imageOutput",
        "audio_output": "audioOutput",
        "input_audio_cache": "inputAudioCache",
        "web_search": "webSearch",
        "internal_reasoning": "internalReasoning",
        "input_cache_read": "inputCacheRead",
        "input_cache_write": "inputCacheWrite"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/topproviderinfo.js
var TopProviderInfo$inboundSchema;
var init_topproviderinfo = __esm({
  "node_modules/@openrouter/sdk/esm/models/topproviderinfo.js"() {
    init_v4();
    init_primitives();
    TopProviderInfo$inboundSchema = object({
      context_length: nullable(number2()).optional(),
      max_completion_tokens: nullable(number2()).optional(),
      is_moderated: boolean2()
    }).transform((v) => {
      return remap(v, {
        "context_length": "contextLength",
        "max_completion_tokens": "maxCompletionTokens",
        "is_moderated": "isModerated"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/model.js
var Model$inboundSchema;
var init_model = __esm({
  "node_modules/@openrouter/sdk/esm/models/model.js"() {
    init_v4();
    init_primitives();
    init_defaultparameters();
    init_modelarchitecture();
    init_parameter();
    init_perrequestlimits();
    init_publicpricing();
    init_topproviderinfo();
    Model$inboundSchema = object({
      id: string2(),
      canonical_slug: string2(),
      hugging_face_id: nullable(string2()).optional(),
      name: string2(),
      created: number2(),
      description: string2().optional(),
      pricing: PublicPricing$inboundSchema,
      context_length: nullable(number2()),
      architecture: ModelArchitecture$inboundSchema,
      top_provider: TopProviderInfo$inboundSchema,
      per_request_limits: nullable(PerRequestLimits$inboundSchema),
      supported_parameters: array(Parameter$inboundSchema),
      default_parameters: nullable(DefaultParameters$inboundSchema),
      expiration_date: nullable(string2()).optional()
    }).transform((v) => {
      return remap(v, {
        "canonical_slug": "canonicalSlug",
        "hugging_face_id": "huggingFaceId",
        "context_length": "contextLength",
        "top_provider": "topProvider",
        "per_request_limits": "perRequestLimits",
        "supported_parameters": "supportedParameters",
        "default_parameters": "defaultParameters",
        "expiration_date": "expirationDate"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/modelscountresponse.js
var ModelsCountResponseData$inboundSchema, ModelsCountResponse$inboundSchema;
var init_modelscountresponse = __esm({
  "node_modules/@openrouter/sdk/esm/models/modelscountresponse.js"() {
    init_v4();
    ModelsCountResponseData$inboundSchema = object({
      count: number2()
    });
    ModelsCountResponse$inboundSchema = object({
      data: lazy(() => ModelsCountResponseData$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/modelslistresponse.js
var ModelsListResponse$inboundSchema;
var init_modelslistresponse = __esm({
  "node_modules/@openrouter/sdk/esm/models/modelslistresponse.js"() {
    init_v4();
    init_model();
    ModelsListResponse$inboundSchema = object({
      data: array(Model$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/namedtoolchoice.js
var NamedToolChoiceFunction$outboundSchema, NamedToolChoice$outboundSchema;
var init_namedtoolchoice = __esm({
  "node_modules/@openrouter/sdk/esm/models/namedtoolchoice.js"() {
    init_v4();
    NamedToolChoiceFunction$outboundSchema = object({
      name: string2()
    });
    NamedToolChoice$outboundSchema = object({
      type: literal("function"),
      function: lazy(() => NamedToolChoiceFunction$outboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/notfoundresponseerrordata.js
var NotFoundResponseErrorData$inboundSchema;
var init_notfoundresponseerrordata = __esm({
  "node_modules/@openrouter/sdk/esm/models/notfoundresponseerrordata.js"() {
    init_v4();
    NotFoundResponseErrorData$inboundSchema = object({
      code: int(),
      message: string2(),
      metadata: nullable(record(string2(), nullable(any()))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/urlcitation.js
var URLCitation$inboundSchema, URLCitation$outboundSchema;
var init_urlcitation = __esm({
  "node_modules/@openrouter/sdk/esm/models/urlcitation.js"() {
    init_v4();
    init_primitives();
    URLCitation$inboundSchema = object({
      type: literal("url_citation"),
      url: string2(),
      title: string2(),
      start_index: number2(),
      end_index: number2()
    }).transform((v) => {
      return remap(v, {
        "start_index": "startIndex",
        "end_index": "endIndex"
      });
    });
    URLCitation$outboundSchema = object({
      type: literal("url_citation"),
      url: string2(),
      title: string2(),
      startIndex: number2(),
      endIndex: number2()
    }).transform((v) => {
      return remap(v, {
        startIndex: "start_index",
        endIndex: "end_index"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openairesponsesannotation.js
var OpenAIResponsesAnnotation$inboundSchema, OpenAIResponsesAnnotation$outboundSchema;
var init_openairesponsesannotation = __esm({
  "node_modules/@openrouter/sdk/esm/models/openairesponsesannotation.js"() {
    init_v4();
    init_filecitation();
    init_filepath();
    init_urlcitation();
    OpenAIResponsesAnnotation$inboundSchema = union([
      FileCitation$inboundSchema,
      URLCitation$inboundSchema,
      FilePath$inboundSchema
    ]);
    OpenAIResponsesAnnotation$outboundSchema = union([
      FileCitation$outboundSchema,
      URLCitation$outboundSchema,
      FilePath$outboundSchema
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/openairesponsesincludable.js
var OpenAIResponsesIncludable, OpenAIResponsesIncludable$outboundSchema;
var init_openairesponsesincludable = __esm({
  "node_modules/@openrouter/sdk/esm/models/openairesponsesincludable.js"() {
    init_enums();
    OpenAIResponsesIncludable = {
      FileSearchCallResults: "file_search_call.results",
      MessageInputImageImageUrl: "message.input_image.image_url",
      ComputerCallOutputOutputImageUrl: "computer_call_output.output.image_url",
      ReasoningEncryptedContent: "reasoning.encrypted_content",
      CodeInterpreterCallOutputs: "code_interpreter_call.outputs"
    };
    OpenAIResponsesIncludable$outboundSchema = outboundSchema(OpenAIResponsesIncludable);
  }
});

// node_modules/@openrouter/sdk/esm/models/openairesponsesincompletedetails.js
var Reason, Reason$inboundSchema, OpenAIResponsesIncompleteDetails$inboundSchema;
var init_openairesponsesincompletedetails = __esm({
  "node_modules/@openrouter/sdk/esm/models/openairesponsesincompletedetails.js"() {
    init_v4();
    init_enums();
    Reason = {
      MaxOutputTokens: "max_output_tokens",
      ContentFilter: "content_filter"
    };
    Reason$inboundSchema = inboundSchema(Reason);
    OpenAIResponsesIncompleteDetails$inboundSchema = object({
      reason: Reason$inboundSchema.optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/outputitemimagegenerationcall.js
var OutputItemImageGenerationCallType, OutputItemImageGenerationCallType$inboundSchema, OutputItemImageGenerationCall$inboundSchema;
var init_outputitemimagegenerationcall = __esm({
  "node_modules/@openrouter/sdk/esm/models/outputitemimagegenerationcall.js"() {
    init_v4();
    init_imagegenerationstatus();
    OutputItemImageGenerationCallType = {
      ImageGenerationCall: "image_generation_call"
    };
    OutputItemImageGenerationCallType$inboundSchema = _enum2(OutputItemImageGenerationCallType);
    OutputItemImageGenerationCall$inboundSchema = object({
      type: OutputItemImageGenerationCallType$inboundSchema,
      id: string2(),
      result: nullable(string2()).default(null),
      status: ImageGenerationStatus$inboundSchema
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openairesponsesrefusalcontent.js
var OpenAIResponsesRefusalContent$inboundSchema, OpenAIResponsesRefusalContent$outboundSchema;
var init_openairesponsesrefusalcontent = __esm({
  "node_modules/@openrouter/sdk/esm/models/openairesponsesrefusalcontent.js"() {
    init_v4();
    OpenAIResponsesRefusalContent$inboundSchema = object({
      type: literal("refusal"),
      refusal: string2()
    });
    OpenAIResponsesRefusalContent$outboundSchema = object({
      type: literal("refusal"),
      refusal: string2()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responseoutputtext.js
var ResponseOutputTextTopLogprob$inboundSchema, ResponseOutputTextTopLogprob$outboundSchema, Logprob$inboundSchema, Logprob$outboundSchema, ResponseOutputText$inboundSchema, ResponseOutputText$outboundSchema;
var init_responseoutputtext = __esm({
  "node_modules/@openrouter/sdk/esm/models/responseoutputtext.js"() {
    init_v4();
    init_primitives();
    init_openairesponsesannotation();
    ResponseOutputTextTopLogprob$inboundSchema = object({
      token: string2(),
      bytes: array(number2()),
      logprob: number2()
    });
    ResponseOutputTextTopLogprob$outboundSchema = object({
      token: string2(),
      bytes: array(number2()),
      logprob: number2()
    });
    Logprob$inboundSchema = object({
      token: string2(),
      bytes: array(number2()),
      logprob: number2(),
      top_logprobs: array(lazy(() => ResponseOutputTextTopLogprob$inboundSchema))
    }).transform((v) => {
      return remap(v, {
        "top_logprobs": "topLogprobs"
      });
    });
    Logprob$outboundSchema = object({
      token: string2(),
      bytes: array(number2()),
      logprob: number2(),
      topLogprobs: array(lazy(() => ResponseOutputTextTopLogprob$outboundSchema))
    }).transform((v) => {
      return remap(v, {
        topLogprobs: "top_logprobs"
      });
    });
    ResponseOutputText$inboundSchema = object({
      type: literal("output_text"),
      text: string2(),
      annotations: array(OpenAIResponsesAnnotation$inboundSchema).optional(),
      logprobs: array(lazy(() => Logprob$inboundSchema)).optional()
    });
    ResponseOutputText$outboundSchema = object({
      type: literal("output_text"),
      text: string2(),
      annotations: array(OpenAIResponsesAnnotation$outboundSchema).optional(),
      logprobs: array(lazy(() => Logprob$outboundSchema)).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/outputmessage.js
var OutputMessageRole, OutputMessageType, OutputMessageStatusInProgress, OutputMessageStatusIncomplete, OutputMessageStatusCompleted, OutputMessageRole$inboundSchema, OutputMessageType$inboundSchema, OutputMessageStatusInProgress$inboundSchema, OutputMessageStatusIncomplete$inboundSchema, OutputMessageStatusCompleted$inboundSchema, OutputMessageStatusUnion$inboundSchema, OutputMessageContent$inboundSchema, OutputMessage$inboundSchema;
var init_outputmessage = __esm({
  "node_modules/@openrouter/sdk/esm/models/outputmessage.js"() {
    init_v4();
    init_openairesponsesrefusalcontent();
    init_responseoutputtext();
    OutputMessageRole = {
      Assistant: "assistant"
    };
    OutputMessageType = {
      Message: "message"
    };
    OutputMessageStatusInProgress = {
      InProgress: "in_progress"
    };
    OutputMessageStatusIncomplete = {
      Incomplete: "incomplete"
    };
    OutputMessageStatusCompleted = {
      Completed: "completed"
    };
    OutputMessageRole$inboundSchema = _enum2(OutputMessageRole);
    OutputMessageType$inboundSchema = _enum2(OutputMessageType);
    OutputMessageStatusInProgress$inboundSchema = _enum2(OutputMessageStatusInProgress);
    OutputMessageStatusIncomplete$inboundSchema = _enum2(OutputMessageStatusIncomplete);
    OutputMessageStatusCompleted$inboundSchema = _enum2(OutputMessageStatusCompleted);
    OutputMessageStatusUnion$inboundSchema = union([
      OutputMessageStatusCompleted$inboundSchema,
      OutputMessageStatusIncomplete$inboundSchema,
      OutputMessageStatusInProgress$inboundSchema
    ]);
    OutputMessageContent$inboundSchema = union([
      ResponseOutputText$inboundSchema,
      OpenAIResponsesRefusalContent$inboundSchema
    ]);
    OutputMessage$inboundSchema = object({
      id: string2(),
      role: OutputMessageRole$inboundSchema,
      type: OutputMessageType$inboundSchema,
      status: union([
        OutputMessageStatusCompleted$inboundSchema,
        OutputMessageStatusIncomplete$inboundSchema,
        OutputMessageStatusInProgress$inboundSchema
      ]).optional(),
      content: array(union([
        ResponseOutputText$inboundSchema,
        OpenAIResponsesRefusalContent$inboundSchema
      ]))
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responseinputimage.js
var ResponseInputImageType, ResponseInputImageDetail, ResponseInputImageType$inboundSchema, ResponseInputImageType$outboundSchema, ResponseInputImageDetail$inboundSchema, ResponseInputImageDetail$outboundSchema, ResponseInputImage$inboundSchema, ResponseInputImage$outboundSchema;
var init_responseinputimage = __esm({
  "node_modules/@openrouter/sdk/esm/models/responseinputimage.js"() {
    init_v4();
    init_primitives();
    init_enums();
    ResponseInputImageType = {
      InputImage: "input_image"
    };
    ResponseInputImageDetail = {
      Auto: "auto",
      High: "high",
      Low: "low"
    };
    ResponseInputImageType$inboundSchema = _enum2(ResponseInputImageType);
    ResponseInputImageType$outboundSchema = ResponseInputImageType$inboundSchema;
    ResponseInputImageDetail$inboundSchema = inboundSchema(ResponseInputImageDetail);
    ResponseInputImageDetail$outboundSchema = outboundSchema(ResponseInputImageDetail);
    ResponseInputImage$inboundSchema = object({
      type: ResponseInputImageType$inboundSchema,
      detail: ResponseInputImageDetail$inboundSchema,
      image_url: nullable(string2()).optional()
    }).transform((v) => {
      return remap(v, {
        "image_url": "imageUrl"
      });
    });
    ResponseInputImage$outboundSchema = object({
      type: ResponseInputImageType$outboundSchema,
      detail: ResponseInputImageDetail$outboundSchema,
      imageUrl: nullable(string2()).optional()
    }).transform((v) => {
      return remap(v, {
        imageUrl: "image_url"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openairesponsesinputunion.js
var OpenAIResponsesInputTypeFunctionCall, OpenAIResponsesInputTypeFunctionCallOutput, OpenAIResponsesInputTypeMessage2, OpenAIResponsesInputRoleDeveloper2, OpenAIResponsesInputRoleSystem2, OpenAIResponsesInputRoleUser2, OpenAIResponsesInputTypeMessage1, OpenAIResponsesInputRoleDeveloper1, OpenAIResponsesInputRoleAssistant, OpenAIResponsesInputRoleSystem1, OpenAIResponsesInputRoleUser1, OpenAIResponsesInputTypeFunctionCall$inboundSchema, OpenAIResponsesInputFunctionCall$inboundSchema, OpenAIResponsesInputTypeFunctionCallOutput$inboundSchema, OpenAIResponsesInputFunctionCallOutput$inboundSchema, OpenAIResponsesInputTypeMessage2$inboundSchema, OpenAIResponsesInputRoleDeveloper2$inboundSchema, OpenAIResponsesInputRoleSystem2$inboundSchema, OpenAIResponsesInputRoleUser2$inboundSchema, OpenAIResponsesInputRoleUnion2$inboundSchema, OpenAIResponsesInputContent3$inboundSchema, OpenAIResponsesInputMessage2$inboundSchema, OpenAIResponsesInputTypeMessage1$inboundSchema, OpenAIResponsesInputRoleDeveloper1$inboundSchema, OpenAIResponsesInputRoleAssistant$inboundSchema, OpenAIResponsesInputRoleSystem1$inboundSchema, OpenAIResponsesInputRoleUser1$inboundSchema, OpenAIResponsesInputRoleUnion1$inboundSchema, OpenAIResponsesInputContent1$inboundSchema, OpenAIResponsesInputContent2$inboundSchema, OpenAIResponsesInputMessage1$inboundSchema, OpenAIResponsesInputUnion1$inboundSchema, OpenAIResponsesInputUnion$inboundSchema;
var init_openairesponsesinputunion = __esm({
  "node_modules/@openrouter/sdk/esm/models/openairesponsesinputunion.js"() {
    init_v4();
    init_primitives();
    init_outputitemimagegenerationcall();
    init_outputmessage();
    init_responseinputaudio();
    init_responseinputfile();
    init_responseinputimage();
    init_responseinputtext();
    init_toolcallstatus();
    OpenAIResponsesInputTypeFunctionCall = {
      FunctionCall: "function_call"
    };
    OpenAIResponsesInputTypeFunctionCallOutput = {
      FunctionCallOutput: "function_call_output"
    };
    OpenAIResponsesInputTypeMessage2 = {
      Message: "message"
    };
    OpenAIResponsesInputRoleDeveloper2 = {
      Developer: "developer"
    };
    OpenAIResponsesInputRoleSystem2 = {
      System: "system"
    };
    OpenAIResponsesInputRoleUser2 = {
      User: "user"
    };
    OpenAIResponsesInputTypeMessage1 = {
      Message: "message"
    };
    OpenAIResponsesInputRoleDeveloper1 = {
      Developer: "developer"
    };
    OpenAIResponsesInputRoleAssistant = {
      Assistant: "assistant"
    };
    OpenAIResponsesInputRoleSystem1 = {
      System: "system"
    };
    OpenAIResponsesInputRoleUser1 = {
      User: "user"
    };
    OpenAIResponsesInputTypeFunctionCall$inboundSchema = _enum2(OpenAIResponsesInputTypeFunctionCall);
    OpenAIResponsesInputFunctionCall$inboundSchema = object({
      type: OpenAIResponsesInputTypeFunctionCall$inboundSchema,
      call_id: string2(),
      name: string2(),
      arguments: string2(),
      id: string2().optional(),
      status: nullable(ToolCallStatus$inboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        "call_id": "callId"
      });
    });
    OpenAIResponsesInputTypeFunctionCallOutput$inboundSchema = _enum2(OpenAIResponsesInputTypeFunctionCallOutput);
    OpenAIResponsesInputFunctionCallOutput$inboundSchema = object({
      type: OpenAIResponsesInputTypeFunctionCallOutput$inboundSchema,
      id: nullable(string2()).optional(),
      call_id: string2(),
      output: string2(),
      status: nullable(ToolCallStatus$inboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        "call_id": "callId"
      });
    });
    OpenAIResponsesInputTypeMessage2$inboundSchema = _enum2(OpenAIResponsesInputTypeMessage2);
    OpenAIResponsesInputRoleDeveloper2$inboundSchema = _enum2(OpenAIResponsesInputRoleDeveloper2);
    OpenAIResponsesInputRoleSystem2$inboundSchema = _enum2(OpenAIResponsesInputRoleSystem2);
    OpenAIResponsesInputRoleUser2$inboundSchema = _enum2(OpenAIResponsesInputRoleUser2);
    OpenAIResponsesInputRoleUnion2$inboundSchema = union([
      OpenAIResponsesInputRoleUser2$inboundSchema,
      OpenAIResponsesInputRoleSystem2$inboundSchema,
      OpenAIResponsesInputRoleDeveloper2$inboundSchema
    ]);
    OpenAIResponsesInputContent3$inboundSchema = union([
      ResponseInputText$inboundSchema,
      ResponseInputImage$inboundSchema.and(object({ type: literal("input_image") })),
      ResponseInputFile$inboundSchema,
      ResponseInputAudio$inboundSchema
    ]);
    OpenAIResponsesInputMessage2$inboundSchema = object({
      id: string2(),
      type: OpenAIResponsesInputTypeMessage2$inboundSchema.optional(),
      role: union([
        OpenAIResponsesInputRoleUser2$inboundSchema,
        OpenAIResponsesInputRoleSystem2$inboundSchema,
        OpenAIResponsesInputRoleDeveloper2$inboundSchema
      ]),
      content: array(union([
        ResponseInputText$inboundSchema,
        ResponseInputImage$inboundSchema.and(object({ type: literal("input_image") })),
        ResponseInputFile$inboundSchema,
        ResponseInputAudio$inboundSchema
      ]))
    });
    OpenAIResponsesInputTypeMessage1$inboundSchema = _enum2(OpenAIResponsesInputTypeMessage1);
    OpenAIResponsesInputRoleDeveloper1$inboundSchema = _enum2(OpenAIResponsesInputRoleDeveloper1);
    OpenAIResponsesInputRoleAssistant$inboundSchema = _enum2(OpenAIResponsesInputRoleAssistant);
    OpenAIResponsesInputRoleSystem1$inboundSchema = _enum2(OpenAIResponsesInputRoleSystem1);
    OpenAIResponsesInputRoleUser1$inboundSchema = _enum2(OpenAIResponsesInputRoleUser1);
    OpenAIResponsesInputRoleUnion1$inboundSchema = union([
      OpenAIResponsesInputRoleUser1$inboundSchema,
      OpenAIResponsesInputRoleSystem1$inboundSchema,
      OpenAIResponsesInputRoleAssistant$inboundSchema,
      OpenAIResponsesInputRoleDeveloper1$inboundSchema
    ]);
    OpenAIResponsesInputContent1$inboundSchema = union([
      ResponseInputText$inboundSchema,
      ResponseInputImage$inboundSchema.and(object({ type: literal("input_image") })),
      ResponseInputFile$inboundSchema,
      ResponseInputAudio$inboundSchema
    ]);
    OpenAIResponsesInputContent2$inboundSchema = union([
      array(union([
        ResponseInputText$inboundSchema,
        ResponseInputImage$inboundSchema.and(object({ type: literal("input_image") })),
        ResponseInputFile$inboundSchema,
        ResponseInputAudio$inboundSchema
      ])),
      string2()
    ]);
    OpenAIResponsesInputMessage1$inboundSchema = object({
      type: OpenAIResponsesInputTypeMessage1$inboundSchema.optional(),
      role: union([
        OpenAIResponsesInputRoleUser1$inboundSchema,
        OpenAIResponsesInputRoleSystem1$inboundSchema,
        OpenAIResponsesInputRoleAssistant$inboundSchema,
        OpenAIResponsesInputRoleDeveloper1$inboundSchema
      ]),
      content: union([
        array(union([
          ResponseInputText$inboundSchema,
          ResponseInputImage$inboundSchema.and(object({ type: literal("input_image") })),
          ResponseInputFile$inboundSchema,
          ResponseInputAudio$inboundSchema
        ])),
        string2()
      ])
    });
    OpenAIResponsesInputUnion1$inboundSchema = union([
      lazy(() => OpenAIResponsesInputFunctionCall$inboundSchema),
      OutputMessage$inboundSchema,
      lazy(() => OpenAIResponsesInputMessage2$inboundSchema),
      lazy(() => OpenAIResponsesInputFunctionCallOutput$inboundSchema),
      OutputItemImageGenerationCall$inboundSchema,
      lazy(() => OpenAIResponsesInputMessage1$inboundSchema)
    ]);
    OpenAIResponsesInputUnion$inboundSchema = union([
      string2(),
      array(union([
        lazy(() => OpenAIResponsesInputFunctionCall$inboundSchema),
        OutputMessage$inboundSchema,
        lazy(() => OpenAIResponsesInputMessage2$inboundSchema),
        lazy(() => OpenAIResponsesInputFunctionCallOutput$inboundSchema),
        OutputItemImageGenerationCall$inboundSchema,
        lazy(() => OpenAIResponsesInputMessage1$inboundSchema)
      ])),
      any()
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/openairesponsesprompt.js
var Variables$inboundSchema, Variables$outboundSchema, OpenAIResponsesPrompt$inboundSchema, OpenAIResponsesPrompt$outboundSchema;
var init_openairesponsesprompt = __esm({
  "node_modules/@openrouter/sdk/esm/models/openairesponsesprompt.js"() {
    init_v4();
    init_responseinputfile();
    init_responseinputimage();
    init_responseinputtext();
    Variables$inboundSchema = union([
      ResponseInputText$inboundSchema,
      ResponseInputImage$inboundSchema,
      ResponseInputFile$inboundSchema,
      string2()
    ]);
    Variables$outboundSchema = union([
      ResponseInputText$outboundSchema,
      ResponseInputImage$outboundSchema,
      ResponseInputFile$outboundSchema,
      string2()
    ]);
    OpenAIResponsesPrompt$inboundSchema = object({
      id: string2(),
      variables: nullable(record(string2(), union([
        ResponseInputText$inboundSchema,
        ResponseInputImage$inboundSchema,
        ResponseInputFile$inboundSchema,
        string2()
      ]))).optional()
    });
    OpenAIResponsesPrompt$outboundSchema = object({
      id: string2(),
      variables: nullable(record(string2(), union([
        ResponseInputText$outboundSchema,
        ResponseInputImage$outboundSchema,
        ResponseInputFile$outboundSchema,
        string2()
      ]))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openairesponsesreasoningeffort.js
var OpenAIResponsesReasoningEffort, OpenAIResponsesReasoningEffort$inboundSchema, OpenAIResponsesReasoningEffort$outboundSchema;
var init_openairesponsesreasoningeffort = __esm({
  "node_modules/@openrouter/sdk/esm/models/openairesponsesreasoningeffort.js"() {
    init_enums();
    OpenAIResponsesReasoningEffort = {
      Xhigh: "xhigh",
      High: "high",
      Medium: "medium",
      Low: "low",
      Minimal: "minimal",
      None: "none"
    };
    OpenAIResponsesReasoningEffort$inboundSchema = inboundSchema(OpenAIResponsesReasoningEffort);
    OpenAIResponsesReasoningEffort$outboundSchema = outboundSchema(OpenAIResponsesReasoningEffort);
  }
});

// node_modules/@openrouter/sdk/esm/models/openairesponsesreasoningconfig.js
var OpenAIResponsesReasoningConfig$inboundSchema;
var init_openairesponsesreasoningconfig = __esm({
  "node_modules/@openrouter/sdk/esm/models/openairesponsesreasoningconfig.js"() {
    init_v4();
    init_openairesponsesreasoningeffort();
    init_reasoningsummaryverbosity();
    OpenAIResponsesReasoningConfig$inboundSchema = object({
      effort: nullable(OpenAIResponsesReasoningEffort$inboundSchema).optional(),
      summary: ReasoningSummaryVerbosity$inboundSchema.optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openairesponsesresponsestatus.js
var OpenAIResponsesResponseStatus, OpenAIResponsesResponseStatus$inboundSchema;
var init_openairesponsesresponsestatus = __esm({
  "node_modules/@openrouter/sdk/esm/models/openairesponsesresponsestatus.js"() {
    init_enums();
    OpenAIResponsesResponseStatus = {
      Completed: "completed",
      Incomplete: "incomplete",
      InProgress: "in_progress",
      Failed: "failed",
      Cancelled: "cancelled",
      Queued: "queued"
    };
    OpenAIResponsesResponseStatus$inboundSchema = inboundSchema(OpenAIResponsesResponseStatus);
  }
});

// node_modules/@openrouter/sdk/esm/models/openairesponsesservicetier.js
var OpenAIResponsesServiceTier, OpenAIResponsesServiceTier$inboundSchema;
var init_openairesponsesservicetier = __esm({
  "node_modules/@openrouter/sdk/esm/models/openairesponsesservicetier.js"() {
    init_enums();
    OpenAIResponsesServiceTier = {
      Auto: "auto",
      Default: "default",
      Flex: "flex",
      Priority: "priority",
      Scale: "scale"
    };
    OpenAIResponsesServiceTier$inboundSchema = inboundSchema(OpenAIResponsesServiceTier);
  }
});

// node_modules/@openrouter/sdk/esm/models/openairesponsestoolchoiceunion.js
var OpenAIResponsesToolChoiceTypeWebSearchPreview, OpenAIResponsesToolChoiceTypeWebSearchPreview20250311, OpenAIResponsesToolChoiceTypeFunction, OpenAIResponsesToolChoiceRequired, OpenAIResponsesToolChoiceNone, OpenAIResponsesToolChoiceAuto, OpenAIResponsesToolChoiceTypeWebSearchPreview$inboundSchema, OpenAIResponsesToolChoiceTypeWebSearchPreview$outboundSchema, OpenAIResponsesToolChoiceTypeWebSearchPreview20250311$inboundSchema, OpenAIResponsesToolChoiceTypeWebSearchPreview20250311$outboundSchema, Type$inboundSchema, Type$outboundSchema, OpenAIResponsesToolChoice$inboundSchema, OpenAIResponsesToolChoice$outboundSchema, OpenAIResponsesToolChoiceTypeFunction$inboundSchema, OpenAIResponsesToolChoiceTypeFunction$outboundSchema, OpenAIResponsesToolChoiceFunction$inboundSchema, OpenAIResponsesToolChoiceFunction$outboundSchema, OpenAIResponsesToolChoiceRequired$inboundSchema, OpenAIResponsesToolChoiceRequired$outboundSchema, OpenAIResponsesToolChoiceNone$inboundSchema, OpenAIResponsesToolChoiceNone$outboundSchema, OpenAIResponsesToolChoiceAuto$inboundSchema, OpenAIResponsesToolChoiceAuto$outboundSchema, OpenAIResponsesToolChoiceUnion$inboundSchema, OpenAIResponsesToolChoiceUnion$outboundSchema;
var init_openairesponsestoolchoiceunion = __esm({
  "node_modules/@openrouter/sdk/esm/models/openairesponsestoolchoiceunion.js"() {
    init_v4();
    OpenAIResponsesToolChoiceTypeWebSearchPreview = {
      WebSearchPreview: "web_search_preview"
    };
    OpenAIResponsesToolChoiceTypeWebSearchPreview20250311 = {
      WebSearchPreview20250311: "web_search_preview_2025_03_11"
    };
    OpenAIResponsesToolChoiceTypeFunction = {
      Function: "function"
    };
    OpenAIResponsesToolChoiceRequired = {
      Required: "required"
    };
    OpenAIResponsesToolChoiceNone = {
      None: "none"
    };
    OpenAIResponsesToolChoiceAuto = {
      Auto: "auto"
    };
    OpenAIResponsesToolChoiceTypeWebSearchPreview$inboundSchema = _enum2(OpenAIResponsesToolChoiceTypeWebSearchPreview);
    OpenAIResponsesToolChoiceTypeWebSearchPreview$outboundSchema = OpenAIResponsesToolChoiceTypeWebSearchPreview$inboundSchema;
    OpenAIResponsesToolChoiceTypeWebSearchPreview20250311$inboundSchema = _enum2(OpenAIResponsesToolChoiceTypeWebSearchPreview20250311);
    OpenAIResponsesToolChoiceTypeWebSearchPreview20250311$outboundSchema = OpenAIResponsesToolChoiceTypeWebSearchPreview20250311$inboundSchema;
    Type$inboundSchema = union([
      OpenAIResponsesToolChoiceTypeWebSearchPreview20250311$inboundSchema,
      OpenAIResponsesToolChoiceTypeWebSearchPreview$inboundSchema
    ]);
    Type$outboundSchema = union([
      OpenAIResponsesToolChoiceTypeWebSearchPreview20250311$outboundSchema,
      OpenAIResponsesToolChoiceTypeWebSearchPreview$outboundSchema
    ]);
    OpenAIResponsesToolChoice$inboundSchema = object({
      type: union([
        OpenAIResponsesToolChoiceTypeWebSearchPreview20250311$inboundSchema,
        OpenAIResponsesToolChoiceTypeWebSearchPreview$inboundSchema
      ])
    });
    OpenAIResponsesToolChoice$outboundSchema = object({
      type: union([
        OpenAIResponsesToolChoiceTypeWebSearchPreview20250311$outboundSchema,
        OpenAIResponsesToolChoiceTypeWebSearchPreview$outboundSchema
      ])
    });
    OpenAIResponsesToolChoiceTypeFunction$inboundSchema = _enum2(OpenAIResponsesToolChoiceTypeFunction);
    OpenAIResponsesToolChoiceTypeFunction$outboundSchema = OpenAIResponsesToolChoiceTypeFunction$inboundSchema;
    OpenAIResponsesToolChoiceFunction$inboundSchema = object({
      type: OpenAIResponsesToolChoiceTypeFunction$inboundSchema,
      name: string2()
    });
    OpenAIResponsesToolChoiceFunction$outboundSchema = object({
      type: OpenAIResponsesToolChoiceTypeFunction$outboundSchema,
      name: string2()
    });
    OpenAIResponsesToolChoiceRequired$inboundSchema = _enum2(OpenAIResponsesToolChoiceRequired);
    OpenAIResponsesToolChoiceRequired$outboundSchema = OpenAIResponsesToolChoiceRequired$inboundSchema;
    OpenAIResponsesToolChoiceNone$inboundSchema = _enum2(OpenAIResponsesToolChoiceNone);
    OpenAIResponsesToolChoiceNone$outboundSchema = OpenAIResponsesToolChoiceNone$inboundSchema;
    OpenAIResponsesToolChoiceAuto$inboundSchema = _enum2(OpenAIResponsesToolChoiceAuto);
    OpenAIResponsesToolChoiceAuto$outboundSchema = OpenAIResponsesToolChoiceAuto$inboundSchema;
    OpenAIResponsesToolChoiceUnion$inboundSchema = union([
      lazy(() => OpenAIResponsesToolChoiceFunction$inboundSchema),
      lazy(() => OpenAIResponsesToolChoice$inboundSchema),
      OpenAIResponsesToolChoiceAuto$inboundSchema,
      OpenAIResponsesToolChoiceNone$inboundSchema,
      OpenAIResponsesToolChoiceRequired$inboundSchema
    ]);
    OpenAIResponsesToolChoiceUnion$outboundSchema = union([
      lazy(() => OpenAIResponsesToolChoiceFunction$outboundSchema),
      lazy(() => OpenAIResponsesToolChoice$outboundSchema),
      OpenAIResponsesToolChoiceAuto$outboundSchema,
      OpenAIResponsesToolChoiceNone$outboundSchema,
      OpenAIResponsesToolChoiceRequired$outboundSchema
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/openairesponsestruncation.js
var OpenAIResponsesTruncation, OpenAIResponsesTruncation$inboundSchema;
var init_openairesponsestruncation = __esm({
  "node_modules/@openrouter/sdk/esm/models/openairesponsestruncation.js"() {
    init_enums();
    OpenAIResponsesTruncation = {
      Auto: "auto",
      Disabled: "disabled"
    };
    OpenAIResponsesTruncation$inboundSchema = inboundSchema(OpenAIResponsesTruncation);
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponseserrorevent.js
var OpenResponsesErrorEvent$inboundSchema;
var init_openresponseserrorevent = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponseserrorevent.js"() {
    init_v4();
    init_primitives();
    OpenResponsesErrorEvent$inboundSchema = object({
      type: literal("error"),
      code: nullable(string2()),
      message: string2(),
      param: nullable(string2()),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "sequence_number": "sequenceNumber"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesfunctiontoolcall.js
var OpenResponsesFunctionToolCallType, OpenResponsesFunctionToolCallType$outboundSchema, OpenResponsesFunctionToolCall$outboundSchema;
var init_openresponsesfunctiontoolcall = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesfunctiontoolcall.js"() {
    init_v4();
    init_primitives();
    init_toolcallstatus();
    OpenResponsesFunctionToolCallType = {
      FunctionCall: "function_call"
    };
    OpenResponsesFunctionToolCallType$outboundSchema = _enum2(OpenResponsesFunctionToolCallType);
    OpenResponsesFunctionToolCall$outboundSchema = object({
      type: OpenResponsesFunctionToolCallType$outboundSchema,
      callId: string2(),
      name: string2(),
      arguments: string2(),
      id: string2(),
      status: nullable(ToolCallStatus$outboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        callId: "call_id"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesimagegencallcompleted.js
var OpenResponsesImageGenCallCompleted$inboundSchema;
var init_openresponsesimagegencallcompleted = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesimagegencallcompleted.js"() {
    init_v4();
    init_primitives();
    OpenResponsesImageGenCallCompleted$inboundSchema = object({
      type: literal("response.image_generation_call.completed"),
      item_id: string2(),
      output_index: number2(),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "item_id": "itemId",
        "output_index": "outputIndex",
        "sequence_number": "sequenceNumber"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesimagegencallgenerating.js
var OpenResponsesImageGenCallGenerating$inboundSchema;
var init_openresponsesimagegencallgenerating = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesimagegencallgenerating.js"() {
    init_v4();
    init_primitives();
    OpenResponsesImageGenCallGenerating$inboundSchema = object({
      type: literal("response.image_generation_call.generating"),
      item_id: string2(),
      output_index: number2(),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "item_id": "itemId",
        "output_index": "outputIndex",
        "sequence_number": "sequenceNumber"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesimagegencallinprogress.js
var OpenResponsesImageGenCallInProgress$inboundSchema;
var init_openresponsesimagegencallinprogress = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesimagegencallinprogress.js"() {
    init_v4();
    init_primitives();
    OpenResponsesImageGenCallInProgress$inboundSchema = object({
      type: literal("response.image_generation_call.in_progress"),
      item_id: string2(),
      output_index: number2(),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "item_id": "itemId",
        "output_index": "outputIndex",
        "sequence_number": "sequenceNumber"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesimagegencallpartialimage.js
var OpenResponsesImageGenCallPartialImage$inboundSchema;
var init_openresponsesimagegencallpartialimage = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesimagegencallpartialimage.js"() {
    init_v4();
    init_primitives();
    OpenResponsesImageGenCallPartialImage$inboundSchema = object({
      type: literal("response.image_generation_call.partial_image"),
      item_id: string2(),
      output_index: number2(),
      sequence_number: number2(),
      partial_image_b64: string2(),
      partial_image_index: number2()
    }).transform((v) => {
      return remap(v, {
        "item_id": "itemId",
        "output_index": "outputIndex",
        "sequence_number": "sequenceNumber",
        "partial_image_b64": "partialImageB64",
        "partial_image_index": "partialImageIndex"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/reasoningsummarytext.js
var ReasoningSummaryTextType, ReasoningSummaryTextType$inboundSchema, ReasoningSummaryTextType$outboundSchema, ReasoningSummaryText$inboundSchema, ReasoningSummaryText$outboundSchema;
var init_reasoningsummarytext = __esm({
  "node_modules/@openrouter/sdk/esm/models/reasoningsummarytext.js"() {
    init_v4();
    ReasoningSummaryTextType = {
      SummaryText: "summary_text"
    };
    ReasoningSummaryTextType$inboundSchema = _enum2(ReasoningSummaryTextType);
    ReasoningSummaryTextType$outboundSchema = ReasoningSummaryTextType$inboundSchema;
    ReasoningSummaryText$inboundSchema = object({
      type: ReasoningSummaryTextType$inboundSchema,
      text: string2()
    });
    ReasoningSummaryText$outboundSchema = object({
      type: ReasoningSummaryTextType$outboundSchema,
      text: string2()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/reasoningtextcontent.js
var ReasoningTextContentType, ReasoningTextContentType$inboundSchema, ReasoningTextContentType$outboundSchema, ReasoningTextContent$inboundSchema, ReasoningTextContent$outboundSchema;
var init_reasoningtextcontent = __esm({
  "node_modules/@openrouter/sdk/esm/models/reasoningtextcontent.js"() {
    init_v4();
    ReasoningTextContentType = {
      ReasoningText: "reasoning_text"
    };
    ReasoningTextContentType$inboundSchema = _enum2(ReasoningTextContentType);
    ReasoningTextContentType$outboundSchema = ReasoningTextContentType$inboundSchema;
    ReasoningTextContent$inboundSchema = object({
      type: ReasoningTextContentType$inboundSchema,
      text: string2()
    });
    ReasoningTextContent$outboundSchema = object({
      type: ReasoningTextContentType$outboundSchema,
      text: string2()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesreasoning.js
var OpenResponsesReasoningType, OpenResponsesReasoningStatusInProgress, OpenResponsesReasoningStatusIncomplete, OpenResponsesReasoningStatusCompleted, OpenResponsesReasoningFormat, OpenResponsesReasoningType$outboundSchema, OpenResponsesReasoningStatusInProgress$outboundSchema, OpenResponsesReasoningStatusIncomplete$outboundSchema, OpenResponsesReasoningStatusCompleted$outboundSchema, OpenResponsesReasoningStatusUnion$outboundSchema, OpenResponsesReasoningFormat$outboundSchema, OpenResponsesReasoning$outboundSchema;
var init_openresponsesreasoning = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesreasoning.js"() {
    init_v4();
    init_primitives();
    init_enums();
    init_reasoningsummarytext();
    init_reasoningtextcontent();
    OpenResponsesReasoningType = {
      Reasoning: "reasoning"
    };
    OpenResponsesReasoningStatusInProgress = {
      InProgress: "in_progress"
    };
    OpenResponsesReasoningStatusIncomplete = {
      Incomplete: "incomplete"
    };
    OpenResponsesReasoningStatusCompleted = {
      Completed: "completed"
    };
    OpenResponsesReasoningFormat = {
      Unknown: "unknown",
      OpenaiResponsesV1: "openai-responses-v1",
      AzureOpenaiResponsesV1: "azure-openai-responses-v1",
      XaiResponsesV1: "xai-responses-v1",
      AnthropicClaudeV1: "anthropic-claude-v1",
      GoogleGeminiV1: "google-gemini-v1"
    };
    OpenResponsesReasoningType$outboundSchema = _enum2(OpenResponsesReasoningType);
    OpenResponsesReasoningStatusInProgress$outboundSchema = _enum2(OpenResponsesReasoningStatusInProgress);
    OpenResponsesReasoningStatusIncomplete$outboundSchema = _enum2(OpenResponsesReasoningStatusIncomplete);
    OpenResponsesReasoningStatusCompleted$outboundSchema = _enum2(OpenResponsesReasoningStatusCompleted);
    OpenResponsesReasoningStatusUnion$outboundSchema = union([
      OpenResponsesReasoningStatusCompleted$outboundSchema,
      OpenResponsesReasoningStatusIncomplete$outboundSchema,
      OpenResponsesReasoningStatusInProgress$outboundSchema
    ]);
    OpenResponsesReasoningFormat$outboundSchema = outboundSchema(OpenResponsesReasoningFormat);
    OpenResponsesReasoning$outboundSchema = object({
      type: OpenResponsesReasoningType$outboundSchema,
      id: string2(),
      content: array(ReasoningTextContent$outboundSchema).optional(),
      summary: array(ReasoningSummaryText$outboundSchema),
      encryptedContent: nullable(string2()).optional(),
      status: union([
        OpenResponsesReasoningStatusCompleted$outboundSchema,
        OpenResponsesReasoningStatusIncomplete$outboundSchema,
        OpenResponsesReasoningStatusInProgress$outboundSchema
      ]).optional(),
      signature: nullable(string2()).optional(),
      format: nullable(OpenResponsesReasoningFormat$outboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        encryptedContent: "encrypted_content"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responsesimagegenerationcall.js
var ResponsesImageGenerationCallType, ResponsesImageGenerationCallType$inboundSchema, ResponsesImageGenerationCallType$outboundSchema, ResponsesImageGenerationCall$inboundSchema, ResponsesImageGenerationCall$outboundSchema;
var init_responsesimagegenerationcall = __esm({
  "node_modules/@openrouter/sdk/esm/models/responsesimagegenerationcall.js"() {
    init_v4();
    init_imagegenerationstatus();
    ResponsesImageGenerationCallType = {
      ImageGenerationCall: "image_generation_call"
    };
    ResponsesImageGenerationCallType$inboundSchema = _enum2(ResponsesImageGenerationCallType);
    ResponsesImageGenerationCallType$outboundSchema = ResponsesImageGenerationCallType$inboundSchema;
    ResponsesImageGenerationCall$inboundSchema = object({
      type: ResponsesImageGenerationCallType$inboundSchema,
      id: string2(),
      result: nullable(string2()).default(null),
      status: ImageGenerationStatus$inboundSchema
    });
    ResponsesImageGenerationCall$outboundSchema = object({
      type: ResponsesImageGenerationCallType$outboundSchema,
      id: string2(),
      result: nullable(string2()).default(null),
      status: ImageGenerationStatus$outboundSchema
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/websearchstatus.js
var WebSearchStatus, WebSearchStatus$inboundSchema, WebSearchStatus$outboundSchema;
var init_websearchstatus = __esm({
  "node_modules/@openrouter/sdk/esm/models/websearchstatus.js"() {
    init_enums();
    WebSearchStatus = {
      Completed: "completed",
      Searching: "searching",
      InProgress: "in_progress",
      Failed: "failed"
    };
    WebSearchStatus$inboundSchema = inboundSchema(WebSearchStatus);
    WebSearchStatus$outboundSchema = outboundSchema(WebSearchStatus);
  }
});

// node_modules/@openrouter/sdk/esm/models/responsesoutputitemfilesearchcall.js
var ResponsesOutputItemFileSearchCallType, ResponsesOutputItemFileSearchCallType$inboundSchema, ResponsesOutputItemFileSearchCallType$outboundSchema, ResponsesOutputItemFileSearchCall$inboundSchema, ResponsesOutputItemFileSearchCall$outboundSchema;
var init_responsesoutputitemfilesearchcall = __esm({
  "node_modules/@openrouter/sdk/esm/models/responsesoutputitemfilesearchcall.js"() {
    init_v4();
    init_websearchstatus();
    ResponsesOutputItemFileSearchCallType = {
      FileSearchCall: "file_search_call"
    };
    ResponsesOutputItemFileSearchCallType$inboundSchema = _enum2(ResponsesOutputItemFileSearchCallType);
    ResponsesOutputItemFileSearchCallType$outboundSchema = ResponsesOutputItemFileSearchCallType$inboundSchema;
    ResponsesOutputItemFileSearchCall$inboundSchema = object({
      type: ResponsesOutputItemFileSearchCallType$inboundSchema,
      id: string2(),
      queries: array(string2()),
      status: WebSearchStatus$inboundSchema
    });
    ResponsesOutputItemFileSearchCall$outboundSchema = object({
      type: ResponsesOutputItemFileSearchCallType$outboundSchema,
      id: string2(),
      queries: array(string2()),
      status: WebSearchStatus$outboundSchema
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responsesoutputitemfunctioncall.js
var ResponsesOutputItemFunctionCallType, ResponsesOutputItemFunctionCallStatusInProgress, ResponsesOutputItemFunctionCallStatusIncomplete, ResponsesOutputItemFunctionCallStatusCompleted, ResponsesOutputItemFunctionCallType$inboundSchema, ResponsesOutputItemFunctionCallType$outboundSchema, ResponsesOutputItemFunctionCallStatusInProgress$inboundSchema, ResponsesOutputItemFunctionCallStatusInProgress$outboundSchema, ResponsesOutputItemFunctionCallStatusIncomplete$inboundSchema, ResponsesOutputItemFunctionCallStatusIncomplete$outboundSchema, ResponsesOutputItemFunctionCallStatusCompleted$inboundSchema, ResponsesOutputItemFunctionCallStatusCompleted$outboundSchema, ResponsesOutputItemFunctionCallStatusUnion$inboundSchema, ResponsesOutputItemFunctionCallStatusUnion$outboundSchema, ResponsesOutputItemFunctionCall$inboundSchema, ResponsesOutputItemFunctionCall$outboundSchema;
var init_responsesoutputitemfunctioncall = __esm({
  "node_modules/@openrouter/sdk/esm/models/responsesoutputitemfunctioncall.js"() {
    init_v4();
    init_primitives();
    ResponsesOutputItemFunctionCallType = {
      FunctionCall: "function_call"
    };
    ResponsesOutputItemFunctionCallStatusInProgress = {
      InProgress: "in_progress"
    };
    ResponsesOutputItemFunctionCallStatusIncomplete = {
      Incomplete: "incomplete"
    };
    ResponsesOutputItemFunctionCallStatusCompleted = {
      Completed: "completed"
    };
    ResponsesOutputItemFunctionCallType$inboundSchema = _enum2(ResponsesOutputItemFunctionCallType);
    ResponsesOutputItemFunctionCallType$outboundSchema = ResponsesOutputItemFunctionCallType$inboundSchema;
    ResponsesOutputItemFunctionCallStatusInProgress$inboundSchema = _enum2(ResponsesOutputItemFunctionCallStatusInProgress);
    ResponsesOutputItemFunctionCallStatusInProgress$outboundSchema = ResponsesOutputItemFunctionCallStatusInProgress$inboundSchema;
    ResponsesOutputItemFunctionCallStatusIncomplete$inboundSchema = _enum2(ResponsesOutputItemFunctionCallStatusIncomplete);
    ResponsesOutputItemFunctionCallStatusIncomplete$outboundSchema = ResponsesOutputItemFunctionCallStatusIncomplete$inboundSchema;
    ResponsesOutputItemFunctionCallStatusCompleted$inboundSchema = _enum2(ResponsesOutputItemFunctionCallStatusCompleted);
    ResponsesOutputItemFunctionCallStatusCompleted$outboundSchema = ResponsesOutputItemFunctionCallStatusCompleted$inboundSchema;
    ResponsesOutputItemFunctionCallStatusUnion$inboundSchema = union([
      ResponsesOutputItemFunctionCallStatusCompleted$inboundSchema,
      ResponsesOutputItemFunctionCallStatusIncomplete$inboundSchema,
      ResponsesOutputItemFunctionCallStatusInProgress$inboundSchema
    ]);
    ResponsesOutputItemFunctionCallStatusUnion$outboundSchema = union([
      ResponsesOutputItemFunctionCallStatusCompleted$outboundSchema,
      ResponsesOutputItemFunctionCallStatusIncomplete$outboundSchema,
      ResponsesOutputItemFunctionCallStatusInProgress$outboundSchema
    ]);
    ResponsesOutputItemFunctionCall$inboundSchema = object({
      type: ResponsesOutputItemFunctionCallType$inboundSchema,
      id: string2().optional(),
      name: string2(),
      arguments: string2(),
      call_id: string2(),
      status: union([
        ResponsesOutputItemFunctionCallStatusCompleted$inboundSchema,
        ResponsesOutputItemFunctionCallStatusIncomplete$inboundSchema,
        ResponsesOutputItemFunctionCallStatusInProgress$inboundSchema
      ]).optional()
    }).transform((v) => {
      return remap(v, {
        "call_id": "callId"
      });
    });
    ResponsesOutputItemFunctionCall$outboundSchema = object({
      type: ResponsesOutputItemFunctionCallType$outboundSchema,
      id: string2().optional(),
      name: string2(),
      arguments: string2(),
      callId: string2(),
      status: union([
        ResponsesOutputItemFunctionCallStatusCompleted$outboundSchema,
        ResponsesOutputItemFunctionCallStatusIncomplete$outboundSchema,
        ResponsesOutputItemFunctionCallStatusInProgress$outboundSchema
      ]).optional()
    }).transform((v) => {
      return remap(v, {
        callId: "call_id"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responsesoutputitemreasoning.js
var ResponsesOutputItemReasoningType, ResponsesOutputItemReasoningStatusInProgress, ResponsesOutputItemReasoningStatusIncomplete, ResponsesOutputItemReasoningStatusCompleted, ResponsesOutputItemReasoningFormat, ResponsesOutputItemReasoningType$inboundSchema, ResponsesOutputItemReasoningType$outboundSchema, ResponsesOutputItemReasoningStatusInProgress$inboundSchema, ResponsesOutputItemReasoningStatusInProgress$outboundSchema, ResponsesOutputItemReasoningStatusIncomplete$inboundSchema, ResponsesOutputItemReasoningStatusIncomplete$outboundSchema, ResponsesOutputItemReasoningStatusCompleted$inboundSchema, ResponsesOutputItemReasoningStatusCompleted$outboundSchema, ResponsesOutputItemReasoningStatusUnion$inboundSchema, ResponsesOutputItemReasoningStatusUnion$outboundSchema, ResponsesOutputItemReasoningFormat$inboundSchema, ResponsesOutputItemReasoningFormat$outboundSchema, ResponsesOutputItemReasoning$inboundSchema, ResponsesOutputItemReasoning$outboundSchema;
var init_responsesoutputitemreasoning = __esm({
  "node_modules/@openrouter/sdk/esm/models/responsesoutputitemreasoning.js"() {
    init_v4();
    init_primitives();
    init_enums();
    init_reasoningsummarytext();
    init_reasoningtextcontent();
    ResponsesOutputItemReasoningType = {
      Reasoning: "reasoning"
    };
    ResponsesOutputItemReasoningStatusInProgress = {
      InProgress: "in_progress"
    };
    ResponsesOutputItemReasoningStatusIncomplete = {
      Incomplete: "incomplete"
    };
    ResponsesOutputItemReasoningStatusCompleted = {
      Completed: "completed"
    };
    ResponsesOutputItemReasoningFormat = {
      Unknown: "unknown",
      OpenaiResponsesV1: "openai-responses-v1",
      AzureOpenaiResponsesV1: "azure-openai-responses-v1",
      XaiResponsesV1: "xai-responses-v1",
      AnthropicClaudeV1: "anthropic-claude-v1",
      GoogleGeminiV1: "google-gemini-v1"
    };
    ResponsesOutputItemReasoningType$inboundSchema = _enum2(ResponsesOutputItemReasoningType);
    ResponsesOutputItemReasoningType$outboundSchema = ResponsesOutputItemReasoningType$inboundSchema;
    ResponsesOutputItemReasoningStatusInProgress$inboundSchema = _enum2(ResponsesOutputItemReasoningStatusInProgress);
    ResponsesOutputItemReasoningStatusInProgress$outboundSchema = ResponsesOutputItemReasoningStatusInProgress$inboundSchema;
    ResponsesOutputItemReasoningStatusIncomplete$inboundSchema = _enum2(ResponsesOutputItemReasoningStatusIncomplete);
    ResponsesOutputItemReasoningStatusIncomplete$outboundSchema = ResponsesOutputItemReasoningStatusIncomplete$inboundSchema;
    ResponsesOutputItemReasoningStatusCompleted$inboundSchema = _enum2(ResponsesOutputItemReasoningStatusCompleted);
    ResponsesOutputItemReasoningStatusCompleted$outboundSchema = ResponsesOutputItemReasoningStatusCompleted$inboundSchema;
    ResponsesOutputItemReasoningStatusUnion$inboundSchema = union([
      ResponsesOutputItemReasoningStatusCompleted$inboundSchema,
      ResponsesOutputItemReasoningStatusIncomplete$inboundSchema,
      ResponsesOutputItemReasoningStatusInProgress$inboundSchema
    ]);
    ResponsesOutputItemReasoningStatusUnion$outboundSchema = union([
      ResponsesOutputItemReasoningStatusCompleted$outboundSchema,
      ResponsesOutputItemReasoningStatusIncomplete$outboundSchema,
      ResponsesOutputItemReasoningStatusInProgress$outboundSchema
    ]);
    ResponsesOutputItemReasoningFormat$inboundSchema = inboundSchema(ResponsesOutputItemReasoningFormat);
    ResponsesOutputItemReasoningFormat$outboundSchema = outboundSchema(ResponsesOutputItemReasoningFormat);
    ResponsesOutputItemReasoning$inboundSchema = object({
      type: ResponsesOutputItemReasoningType$inboundSchema,
      id: string2(),
      content: array(ReasoningTextContent$inboundSchema).optional(),
      summary: array(ReasoningSummaryText$inboundSchema),
      encrypted_content: nullable(string2()).optional(),
      status: union([
        ResponsesOutputItemReasoningStatusCompleted$inboundSchema,
        ResponsesOutputItemReasoningStatusIncomplete$inboundSchema,
        ResponsesOutputItemReasoningStatusInProgress$inboundSchema
      ]).optional(),
      signature: nullable(string2()).optional(),
      format: nullable(ResponsesOutputItemReasoningFormat$inboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        "encrypted_content": "encryptedContent"
      });
    });
    ResponsesOutputItemReasoning$outboundSchema = object({
      type: ResponsesOutputItemReasoningType$outboundSchema,
      id: string2(),
      content: array(ReasoningTextContent$outboundSchema).optional(),
      summary: array(ReasoningSummaryText$outboundSchema),
      encryptedContent: nullable(string2()).optional(),
      status: union([
        ResponsesOutputItemReasoningStatusCompleted$outboundSchema,
        ResponsesOutputItemReasoningStatusIncomplete$outboundSchema,
        ResponsesOutputItemReasoningStatusInProgress$outboundSchema
      ]).optional(),
      signature: nullable(string2()).optional(),
      format: nullable(ResponsesOutputItemReasoningFormat$outboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        encryptedContent: "encrypted_content"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responsesoutputmessage.js
var ResponsesOutputMessageRole, ResponsesOutputMessageType, ResponsesOutputMessageStatusInProgress, ResponsesOutputMessageStatusIncomplete, ResponsesOutputMessageStatusCompleted, ResponsesOutputMessageRole$inboundSchema, ResponsesOutputMessageRole$outboundSchema, ResponsesOutputMessageType$inboundSchema, ResponsesOutputMessageType$outboundSchema, ResponsesOutputMessageStatusInProgress$inboundSchema, ResponsesOutputMessageStatusInProgress$outboundSchema, ResponsesOutputMessageStatusIncomplete$inboundSchema, ResponsesOutputMessageStatusIncomplete$outboundSchema, ResponsesOutputMessageStatusCompleted$inboundSchema, ResponsesOutputMessageStatusCompleted$outboundSchema, ResponsesOutputMessageStatusUnion$inboundSchema, ResponsesOutputMessageStatusUnion$outboundSchema, ResponsesOutputMessageContent$inboundSchema, ResponsesOutputMessageContent$outboundSchema, ResponsesOutputMessage$inboundSchema, ResponsesOutputMessage$outboundSchema;
var init_responsesoutputmessage = __esm({
  "node_modules/@openrouter/sdk/esm/models/responsesoutputmessage.js"() {
    init_v4();
    init_openairesponsesrefusalcontent();
    init_responseoutputtext();
    ResponsesOutputMessageRole = {
      Assistant: "assistant"
    };
    ResponsesOutputMessageType = {
      Message: "message"
    };
    ResponsesOutputMessageStatusInProgress = {
      InProgress: "in_progress"
    };
    ResponsesOutputMessageStatusIncomplete = {
      Incomplete: "incomplete"
    };
    ResponsesOutputMessageStatusCompleted = {
      Completed: "completed"
    };
    ResponsesOutputMessageRole$inboundSchema = _enum2(ResponsesOutputMessageRole);
    ResponsesOutputMessageRole$outboundSchema = ResponsesOutputMessageRole$inboundSchema;
    ResponsesOutputMessageType$inboundSchema = _enum2(ResponsesOutputMessageType);
    ResponsesOutputMessageType$outboundSchema = ResponsesOutputMessageType$inboundSchema;
    ResponsesOutputMessageStatusInProgress$inboundSchema = _enum2(ResponsesOutputMessageStatusInProgress);
    ResponsesOutputMessageStatusInProgress$outboundSchema = ResponsesOutputMessageStatusInProgress$inboundSchema;
    ResponsesOutputMessageStatusIncomplete$inboundSchema = _enum2(ResponsesOutputMessageStatusIncomplete);
    ResponsesOutputMessageStatusIncomplete$outboundSchema = ResponsesOutputMessageStatusIncomplete$inboundSchema;
    ResponsesOutputMessageStatusCompleted$inboundSchema = _enum2(ResponsesOutputMessageStatusCompleted);
    ResponsesOutputMessageStatusCompleted$outboundSchema = ResponsesOutputMessageStatusCompleted$inboundSchema;
    ResponsesOutputMessageStatusUnion$inboundSchema = union([
      ResponsesOutputMessageStatusCompleted$inboundSchema,
      ResponsesOutputMessageStatusIncomplete$inboundSchema,
      ResponsesOutputMessageStatusInProgress$inboundSchema
    ]);
    ResponsesOutputMessageStatusUnion$outboundSchema = union([
      ResponsesOutputMessageStatusCompleted$outboundSchema,
      ResponsesOutputMessageStatusIncomplete$outboundSchema,
      ResponsesOutputMessageStatusInProgress$outboundSchema
    ]);
    ResponsesOutputMessageContent$inboundSchema = union([
      ResponseOutputText$inboundSchema,
      OpenAIResponsesRefusalContent$inboundSchema
    ]);
    ResponsesOutputMessageContent$outboundSchema = union([
      ResponseOutputText$outboundSchema,
      OpenAIResponsesRefusalContent$outboundSchema
    ]);
    ResponsesOutputMessage$inboundSchema = object({
      id: string2(),
      role: ResponsesOutputMessageRole$inboundSchema,
      type: ResponsesOutputMessageType$inboundSchema,
      status: union([
        ResponsesOutputMessageStatusCompleted$inboundSchema,
        ResponsesOutputMessageStatusIncomplete$inboundSchema,
        ResponsesOutputMessageStatusInProgress$inboundSchema
      ]).optional(),
      content: array(union([
        ResponseOutputText$inboundSchema,
        OpenAIResponsesRefusalContent$inboundSchema
      ]))
    });
    ResponsesOutputMessage$outboundSchema = object({
      id: string2(),
      role: ResponsesOutputMessageRole$outboundSchema,
      type: ResponsesOutputMessageType$outboundSchema,
      status: union([
        ResponsesOutputMessageStatusCompleted$outboundSchema,
        ResponsesOutputMessageStatusIncomplete$outboundSchema,
        ResponsesOutputMessageStatusInProgress$outboundSchema
      ]).optional(),
      content: array(union([
        ResponseOutputText$outboundSchema,
        OpenAIResponsesRefusalContent$outboundSchema
      ]))
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responseswebsearchcalloutput.js
var ResponsesWebSearchCallOutputType, ResponsesWebSearchCallOutputType$inboundSchema, ResponsesWebSearchCallOutputType$outboundSchema, ResponsesWebSearchCallOutput$inboundSchema, ResponsesWebSearchCallOutput$outboundSchema;
var init_responseswebsearchcalloutput = __esm({
  "node_modules/@openrouter/sdk/esm/models/responseswebsearchcalloutput.js"() {
    init_v4();
    init_websearchstatus();
    ResponsesWebSearchCallOutputType = {
      WebSearchCall: "web_search_call"
    };
    ResponsesWebSearchCallOutputType$inboundSchema = _enum2(ResponsesWebSearchCallOutputType);
    ResponsesWebSearchCallOutputType$outboundSchema = ResponsesWebSearchCallOutputType$inboundSchema;
    ResponsesWebSearchCallOutput$inboundSchema = object({
      type: ResponsesWebSearchCallOutputType$inboundSchema,
      id: string2(),
      status: WebSearchStatus$inboundSchema
    });
    ResponsesWebSearchCallOutput$outboundSchema = object({
      type: ResponsesWebSearchCallOutputType$outboundSchema,
      id: string2(),
      status: WebSearchStatus$outboundSchema
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesinput.js
var OpenResponsesInput1$outboundSchema, OpenResponsesInput$outboundSchema;
var init_openresponsesinput = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesinput.js"() {
    init_v4();
    init_openresponseseasyinputmessage();
    init_openresponsesfunctioncalloutput();
    init_openresponsesfunctiontoolcall();
    init_openresponsesinputmessageitem();
    init_openresponsesreasoning();
    init_responsesimagegenerationcall();
    init_responsesoutputitemfilesearchcall();
    init_responsesoutputitemfunctioncall();
    init_responsesoutputitemreasoning();
    init_responsesoutputmessage();
    init_responseswebsearchcalloutput();
    OpenResponsesInput1$outboundSchema = union([
      OpenResponsesFunctionToolCall$outboundSchema,
      ResponsesOutputMessage$outboundSchema,
      ResponsesOutputItemFunctionCall$outboundSchema,
      ResponsesOutputItemFileSearchCall$outboundSchema,
      OpenResponsesReasoning$outboundSchema,
      OpenResponsesFunctionCallOutput$outboundSchema,
      ResponsesOutputItemReasoning$outboundSchema,
      ResponsesWebSearchCallOutput$outboundSchema,
      ResponsesImageGenerationCall$outboundSchema,
      OpenResponsesEasyInputMessage$outboundSchema,
      OpenResponsesInputMessageItem$outboundSchema
    ]);
    OpenResponsesInput$outboundSchema = union([
      string2(),
      array(union([
        OpenResponsesFunctionToolCall$outboundSchema,
        ResponsesOutputMessage$outboundSchema,
        ResponsesOutputItemFunctionCall$outboundSchema,
        ResponsesOutputItemFileSearchCall$outboundSchema,
        OpenResponsesReasoning$outboundSchema,
        OpenResponsesFunctionCallOutput$outboundSchema,
        ResponsesOutputItemReasoning$outboundSchema,
        ResponsesWebSearchCallOutput$outboundSchema,
        ResponsesImageGenerationCall$outboundSchema,
        OpenResponsesEasyInputMessage$outboundSchema,
        OpenResponsesInputMessageItem$outboundSchema
      ]))
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsestoplogprobs.js
var OpenResponsesTopLogprobs$inboundSchema;
var init_openresponsestoplogprobs = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsestoplogprobs.js"() {
    init_v4();
    OpenResponsesTopLogprobs$inboundSchema = object({
      token: string2().optional(),
      logprob: number2().optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponseslogprobs.js
var OpenResponsesLogProbs$inboundSchema;
var init_openresponseslogprobs = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponseslogprobs.js"() {
    init_v4();
    init_primitives();
    init_openresponsestoplogprobs();
    OpenResponsesLogProbs$inboundSchema = object({
      logprob: number2(),
      token: string2(),
      top_logprobs: array(OpenResponsesTopLogprobs$inboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        "top_logprobs": "topLogprobs"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesusage.js
var InputTokensDetails$inboundSchema, OutputTokensDetails$inboundSchema, CostDetails$inboundSchema, OpenResponsesUsage$inboundSchema;
var init_openresponsesusage = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesusage.js"() {
    init_v4();
    init_primitives();
    InputTokensDetails$inboundSchema = object({
      cached_tokens: number2()
    }).transform((v) => {
      return remap(v, {
        "cached_tokens": "cachedTokens"
      });
    });
    OutputTokensDetails$inboundSchema = object({
      reasoning_tokens: number2()
    }).transform((v) => {
      return remap(v, {
        "reasoning_tokens": "reasoningTokens"
      });
    });
    CostDetails$inboundSchema = object({
      upstream_inference_cost: nullable(number2()).optional(),
      upstream_inference_input_cost: number2(),
      upstream_inference_output_cost: number2()
    }).transform((v) => {
      return remap(v, {
        "upstream_inference_cost": "upstreamInferenceCost",
        "upstream_inference_input_cost": "upstreamInferenceInputCost",
        "upstream_inference_output_cost": "upstreamInferenceOutputCost"
      });
    });
    OpenResponsesUsage$inboundSchema = object({
      input_tokens: number2(),
      input_tokens_details: lazy(() => InputTokensDetails$inboundSchema),
      output_tokens: number2(),
      output_tokens_details: lazy(() => OutputTokensDetails$inboundSchema),
      total_tokens: number2(),
      cost: nullable(number2()).optional(),
      is_byok: boolean2().optional(),
      cost_details: lazy(() => CostDetails$inboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        "input_tokens": "inputTokens",
        "input_tokens_details": "inputTokensDetails",
        "output_tokens": "outputTokens",
        "output_tokens_details": "outputTokensDetails",
        "total_tokens": "totalTokens",
        "is_byok": "isByok",
        "cost_details": "costDetails"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responsessearchcontextsize.js
var ResponsesSearchContextSize, ResponsesSearchContextSize$inboundSchema, ResponsesSearchContextSize$outboundSchema;
var init_responsessearchcontextsize = __esm({
  "node_modules/@openrouter/sdk/esm/models/responsessearchcontextsize.js"() {
    init_enums();
    ResponsesSearchContextSize = {
      Low: "low",
      Medium: "medium",
      High: "high"
    };
    ResponsesSearchContextSize$inboundSchema = inboundSchema(ResponsesSearchContextSize);
    ResponsesSearchContextSize$outboundSchema = outboundSchema(ResponsesSearchContextSize);
  }
});

// node_modules/@openrouter/sdk/esm/models/responseswebsearchuserlocation.js
var ResponsesWebSearchUserLocationType, ResponsesWebSearchUserLocationType$inboundSchema, ResponsesWebSearchUserLocationType$outboundSchema, ResponsesWebSearchUserLocation$inboundSchema, ResponsesWebSearchUserLocation$outboundSchema;
var init_responseswebsearchuserlocation = __esm({
  "node_modules/@openrouter/sdk/esm/models/responseswebsearchuserlocation.js"() {
    init_v4();
    ResponsesWebSearchUserLocationType = {
      Approximate: "approximate"
    };
    ResponsesWebSearchUserLocationType$inboundSchema = _enum2(ResponsesWebSearchUserLocationType);
    ResponsesWebSearchUserLocationType$outboundSchema = ResponsesWebSearchUserLocationType$inboundSchema;
    ResponsesWebSearchUserLocation$inboundSchema = object({
      type: ResponsesWebSearchUserLocationType$inboundSchema.optional(),
      city: nullable(string2()).optional(),
      country: nullable(string2()).optional(),
      region: nullable(string2()).optional(),
      timezone: nullable(string2()).optional()
    });
    ResponsesWebSearchUserLocation$outboundSchema = object({
      type: ResponsesWebSearchUserLocationType$outboundSchema.optional(),
      city: nullable(string2()).optional(),
      country: nullable(string2()).optional(),
      region: nullable(string2()).optional(),
      timezone: nullable(string2()).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponseswebsearch20250826tool.js
var OpenResponsesWebSearch20250826ToolFilters$inboundSchema, OpenResponsesWebSearch20250826ToolFilters$outboundSchema, OpenResponsesWebSearch20250826Tool$inboundSchema, OpenResponsesWebSearch20250826Tool$outboundSchema;
var init_openresponseswebsearch20250826tool = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponseswebsearch20250826tool.js"() {
    init_v4();
    init_primitives();
    init_responsessearchcontextsize();
    init_responseswebsearchuserlocation();
    OpenResponsesWebSearch20250826ToolFilters$inboundSchema = object({
      allowed_domains: nullable(array(string2())).optional()
    }).transform((v) => {
      return remap(v, {
        "allowed_domains": "allowedDomains"
      });
    });
    OpenResponsesWebSearch20250826ToolFilters$outboundSchema = object({
      allowedDomains: nullable(array(string2())).optional()
    }).transform((v) => {
      return remap(v, {
        allowedDomains: "allowed_domains"
      });
    });
    OpenResponsesWebSearch20250826Tool$inboundSchema = object({
      type: literal("web_search_2025_08_26"),
      filters: nullable(lazy(() => OpenResponsesWebSearch20250826ToolFilters$inboundSchema)).optional(),
      search_context_size: ResponsesSearchContextSize$inboundSchema.optional(),
      user_location: nullable(ResponsesWebSearchUserLocation$inboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        "search_context_size": "searchContextSize",
        "user_location": "userLocation"
      });
    });
    OpenResponsesWebSearch20250826Tool$outboundSchema = object({
      type: literal("web_search_2025_08_26"),
      filters: nullable(lazy(() => OpenResponsesWebSearch20250826ToolFilters$outboundSchema)).optional(),
      searchContextSize: ResponsesSearchContextSize$outboundSchema.optional(),
      userLocation: nullable(ResponsesWebSearchUserLocation$outboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        searchContextSize: "search_context_size",
        userLocation: "user_location"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/websearchpreviewtooluserlocation.js
var WebSearchPreviewToolUserLocationType, WebSearchPreviewToolUserLocationType$inboundSchema, WebSearchPreviewToolUserLocationType$outboundSchema, WebSearchPreviewToolUserLocation$inboundSchema, WebSearchPreviewToolUserLocation$outboundSchema;
var init_websearchpreviewtooluserlocation = __esm({
  "node_modules/@openrouter/sdk/esm/models/websearchpreviewtooluserlocation.js"() {
    init_v4();
    WebSearchPreviewToolUserLocationType = {
      Approximate: "approximate"
    };
    WebSearchPreviewToolUserLocationType$inboundSchema = _enum2(WebSearchPreviewToolUserLocationType);
    WebSearchPreviewToolUserLocationType$outboundSchema = WebSearchPreviewToolUserLocationType$inboundSchema;
    WebSearchPreviewToolUserLocation$inboundSchema = object({
      type: WebSearchPreviewToolUserLocationType$inboundSchema,
      city: nullable(string2()).optional(),
      country: nullable(string2()).optional(),
      region: nullable(string2()).optional(),
      timezone: nullable(string2()).optional()
    });
    WebSearchPreviewToolUserLocation$outboundSchema = object({
      type: WebSearchPreviewToolUserLocationType$outboundSchema,
      city: nullable(string2()).optional(),
      country: nullable(string2()).optional(),
      region: nullable(string2()).optional(),
      timezone: nullable(string2()).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponseswebsearchpreview20250311tool.js
var OpenResponsesWebSearchPreview20250311Tool$inboundSchema, OpenResponsesWebSearchPreview20250311Tool$outboundSchema;
var init_openresponseswebsearchpreview20250311tool = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponseswebsearchpreview20250311tool.js"() {
    init_v4();
    init_primitives();
    init_responsessearchcontextsize();
    init_websearchpreviewtooluserlocation();
    OpenResponsesWebSearchPreview20250311Tool$inboundSchema = object({
      type: literal("web_search_preview_2025_03_11"),
      search_context_size: ResponsesSearchContextSize$inboundSchema.optional(),
      user_location: nullable(WebSearchPreviewToolUserLocation$inboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        "search_context_size": "searchContextSize",
        "user_location": "userLocation"
      });
    });
    OpenResponsesWebSearchPreview20250311Tool$outboundSchema = object({
      type: literal("web_search_preview_2025_03_11"),
      searchContextSize: ResponsesSearchContextSize$outboundSchema.optional(),
      userLocation: nullable(WebSearchPreviewToolUserLocation$outboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        searchContextSize: "search_context_size",
        userLocation: "user_location"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponseswebsearchpreviewtool.js
var OpenResponsesWebSearchPreviewTool$inboundSchema, OpenResponsesWebSearchPreviewTool$outboundSchema;
var init_openresponseswebsearchpreviewtool = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponseswebsearchpreviewtool.js"() {
    init_v4();
    init_primitives();
    init_responsessearchcontextsize();
    init_websearchpreviewtooluserlocation();
    OpenResponsesWebSearchPreviewTool$inboundSchema = object({
      type: literal("web_search_preview"),
      search_context_size: ResponsesSearchContextSize$inboundSchema.optional(),
      user_location: nullable(WebSearchPreviewToolUserLocation$inboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        "search_context_size": "searchContextSize",
        "user_location": "userLocation"
      });
    });
    OpenResponsesWebSearchPreviewTool$outboundSchema = object({
      type: literal("web_search_preview"),
      searchContextSize: ResponsesSearchContextSize$outboundSchema.optional(),
      userLocation: nullable(WebSearchPreviewToolUserLocation$outboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        searchContextSize: "search_context_size",
        userLocation: "user_location"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponseswebsearchtool.js
var OpenResponsesWebSearchToolFilters$inboundSchema, OpenResponsesWebSearchToolFilters$outboundSchema, OpenResponsesWebSearchTool$inboundSchema, OpenResponsesWebSearchTool$outboundSchema;
var init_openresponseswebsearchtool = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponseswebsearchtool.js"() {
    init_v4();
    init_primitives();
    init_responsessearchcontextsize();
    init_responseswebsearchuserlocation();
    OpenResponsesWebSearchToolFilters$inboundSchema = object({
      allowed_domains: nullable(array(string2())).optional()
    }).transform((v) => {
      return remap(v, {
        "allowed_domains": "allowedDomains"
      });
    });
    OpenResponsesWebSearchToolFilters$outboundSchema = object({
      allowedDomains: nullable(array(string2())).optional()
    }).transform((v) => {
      return remap(v, {
        allowedDomains: "allowed_domains"
      });
    });
    OpenResponsesWebSearchTool$inboundSchema = object({
      type: literal("web_search"),
      filters: nullable(lazy(() => OpenResponsesWebSearchToolFilters$inboundSchema)).optional(),
      search_context_size: ResponsesSearchContextSize$inboundSchema.optional(),
      user_location: nullable(ResponsesWebSearchUserLocation$inboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        "search_context_size": "searchContextSize",
        "user_location": "userLocation"
      });
    });
    OpenResponsesWebSearchTool$outboundSchema = object({
      type: literal("web_search"),
      filters: nullable(lazy(() => OpenResponsesWebSearchToolFilters$outboundSchema)).optional(),
      searchContextSize: ResponsesSearchContextSize$outboundSchema.optional(),
      userLocation: nullable(ResponsesWebSearchUserLocation$outboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        searchContextSize: "search_context_size",
        userLocation: "user_location"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responseserrorfield.js
var CodeEnum, CodeEnum$inboundSchema, ResponsesErrorField$inboundSchema;
var init_responseserrorfield = __esm({
  "node_modules/@openrouter/sdk/esm/models/responseserrorfield.js"() {
    init_v4();
    init_enums();
    CodeEnum = {
      ServerError: "server_error",
      RateLimitExceeded: "rate_limit_exceeded",
      InvalidPrompt: "invalid_prompt",
      VectorStoreTimeout: "vector_store_timeout",
      InvalidImage: "invalid_image",
      InvalidImageFormat: "invalid_image_format",
      InvalidBase64Image: "invalid_base64_image",
      InvalidImageUrl: "invalid_image_url",
      ImageTooLarge: "image_too_large",
      ImageTooSmall: "image_too_small",
      ImageParseError: "image_parse_error",
      ImageContentPolicyViolation: "image_content_policy_violation",
      InvalidImageMode: "invalid_image_mode",
      ImageFileTooLarge: "image_file_too_large",
      UnsupportedImageMediaType: "unsupported_image_media_type",
      EmptyImageFile: "empty_image_file",
      FailedToDownloadImage: "failed_to_download_image",
      ImageFileNotFound: "image_file_not_found"
    };
    CodeEnum$inboundSchema = inboundSchema(CodeEnum);
    ResponsesErrorField$inboundSchema = object({
      code: CodeEnum$inboundSchema,
      message: string2()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responsesoutputitem.js
var ResponsesOutputItem$inboundSchema;
var init_responsesoutputitem = __esm({
  "node_modules/@openrouter/sdk/esm/models/responsesoutputitem.js"() {
    init_v4();
    init_responsesimagegenerationcall();
    init_responsesoutputitemfilesearchcall();
    init_responsesoutputitemfunctioncall();
    init_responsesoutputitemreasoning();
    init_responsesoutputmessage();
    init_responseswebsearchcalloutput();
    ResponsesOutputItem$inboundSchema = union([
      ResponsesOutputMessage$inboundSchema.and(object({ type: literal("message") })),
      ResponsesOutputItemReasoning$inboundSchema.and(object({ type: literal("reasoning") })),
      ResponsesOutputItemFunctionCall$inboundSchema.and(object({ type: literal("function_call") })),
      ResponsesWebSearchCallOutput$inboundSchema.and(object({ type: literal("web_search_call") })),
      ResponsesOutputItemFileSearchCall$inboundSchema.and(object({ type: literal("file_search_call") })),
      ResponsesImageGenerationCall$inboundSchema.and(object({ type: literal("image_generation_call") }))
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/responsesformatjsonobject.js
var ResponsesFormatJSONObject$inboundSchema, ResponsesFormatJSONObject$outboundSchema;
var init_responsesformatjsonobject = __esm({
  "node_modules/@openrouter/sdk/esm/models/responsesformatjsonobject.js"() {
    init_v4();
    ResponsesFormatJSONObject$inboundSchema = object({
      type: literal("json_object")
    });
    ResponsesFormatJSONObject$outboundSchema = object({
      type: literal("json_object")
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responsesformattext.js
var ResponsesFormatText$inboundSchema, ResponsesFormatText$outboundSchema;
var init_responsesformattext = __esm({
  "node_modules/@openrouter/sdk/esm/models/responsesformattext.js"() {
    init_v4();
    ResponsesFormatText$inboundSchema = object({
      type: literal("text")
    });
    ResponsesFormatText$outboundSchema = object({
      type: literal("text")
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responsesformattextjsonschemaconfig.js
var ResponsesFormatTextJSONSchemaConfig$inboundSchema, ResponsesFormatTextJSONSchemaConfig$outboundSchema;
var init_responsesformattextjsonschemaconfig = __esm({
  "node_modules/@openrouter/sdk/esm/models/responsesformattextjsonschemaconfig.js"() {
    init_v4();
    ResponsesFormatTextJSONSchemaConfig$inboundSchema = object({
      type: literal("json_schema"),
      name: string2(),
      description: string2().optional(),
      strict: nullable(boolean2()).optional(),
      schema: record(string2(), nullable(any()))
    });
    ResponsesFormatTextJSONSchemaConfig$outboundSchema = object({
      type: literal("json_schema"),
      name: string2(),
      description: string2().optional(),
      strict: nullable(boolean2()).optional(),
      schema: record(string2(), nullable(any()))
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/responseformattextconfig.js
var ResponseFormatTextConfig$inboundSchema, ResponseFormatTextConfig$outboundSchema;
var init_responseformattextconfig = __esm({
  "node_modules/@openrouter/sdk/esm/models/responseformattextconfig.js"() {
    init_v4();
    init_responsesformatjsonobject();
    init_responsesformattext();
    init_responsesformattextjsonschemaconfig();
    ResponseFormatTextConfig$inboundSchema = union([
      ResponsesFormatText$inboundSchema,
      ResponsesFormatJSONObject$inboundSchema,
      ResponsesFormatTextJSONSchemaConfig$inboundSchema
    ]);
    ResponseFormatTextConfig$outboundSchema = union([
      ResponsesFormatText$outboundSchema,
      ResponsesFormatJSONObject$outboundSchema,
      ResponsesFormatTextJSONSchemaConfig$outboundSchema
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/responsetextconfig.js
var ResponseTextConfigVerbosity, ResponseTextConfigVerbosity$inboundSchema, ResponseTextConfig$inboundSchema;
var init_responsetextconfig = __esm({
  "node_modules/@openrouter/sdk/esm/models/responsetextconfig.js"() {
    init_v4();
    init_enums();
    init_responseformattextconfig();
    ResponseTextConfigVerbosity = {
      High: "high",
      Low: "low",
      Medium: "medium"
    };
    ResponseTextConfigVerbosity$inboundSchema = inboundSchema(ResponseTextConfigVerbosity);
    ResponseTextConfig$inboundSchema = object({
      format: ResponseFormatTextConfig$inboundSchema.optional(),
      verbosity: nullable(ResponseTextConfigVerbosity$inboundSchema).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesnonstreamingresponse.js
var ObjectT, ObjectT$inboundSchema, OpenResponsesNonStreamingResponseToolFunction$inboundSchema, OpenResponsesNonStreamingResponseToolUnion$inboundSchema, OpenResponsesNonStreamingResponse$inboundSchema;
var init_openresponsesnonstreamingresponse = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesnonstreamingresponse.js"() {
    init_v4();
    init_primitives();
    init_openairesponsesincompletedetails();
    init_openairesponsesinputunion();
    init_openairesponsesprompt();
    init_openairesponsesreasoningconfig();
    init_openairesponsesresponsestatus();
    init_openairesponsesservicetier();
    init_openairesponsestoolchoiceunion();
    init_openairesponsestruncation();
    init_openresponsesusage();
    init_openresponseswebsearch20250826tool();
    init_openresponseswebsearchpreview20250311tool();
    init_openresponseswebsearchpreviewtool();
    init_openresponseswebsearchtool();
    init_responseserrorfield();
    init_responsesoutputitem();
    init_responsetextconfig();
    ObjectT = {
      Response: "response"
    };
    ObjectT$inboundSchema = _enum2(ObjectT);
    OpenResponsesNonStreamingResponseToolFunction$inboundSchema = object({
      type: literal("function"),
      name: string2(),
      description: nullable(string2()).optional(),
      strict: nullable(boolean2()).optional(),
      parameters: nullable(record(string2(), nullable(any())))
    });
    OpenResponsesNonStreamingResponseToolUnion$inboundSchema = union([
      lazy(() => OpenResponsesNonStreamingResponseToolFunction$inboundSchema),
      OpenResponsesWebSearchPreviewTool$inboundSchema,
      OpenResponsesWebSearchPreview20250311Tool$inboundSchema,
      OpenResponsesWebSearchTool$inboundSchema,
      OpenResponsesWebSearch20250826Tool$inboundSchema
    ]);
    OpenResponsesNonStreamingResponse$inboundSchema = object({
      id: string2(),
      object: ObjectT$inboundSchema,
      created_at: number2(),
      model: string2(),
      status: OpenAIResponsesResponseStatus$inboundSchema,
      completed_at: nullable(number2()),
      output: array(ResponsesOutputItem$inboundSchema),
      user: nullable(string2()).optional(),
      output_text: string2().optional(),
      prompt_cache_key: nullable(string2()).optional(),
      safety_identifier: nullable(string2()).optional(),
      error: nullable(ResponsesErrorField$inboundSchema),
      incomplete_details: nullable(OpenAIResponsesIncompleteDetails$inboundSchema),
      usage: nullable(OpenResponsesUsage$inboundSchema).optional(),
      max_tool_calls: nullable(number2()).optional(),
      top_logprobs: number2().optional(),
      max_output_tokens: nullable(number2()).optional(),
      temperature: nullable(number2()),
      top_p: nullable(number2()),
      presence_penalty: nullable(number2()),
      frequency_penalty: nullable(number2()),
      instructions: nullable(OpenAIResponsesInputUnion$inboundSchema).optional(),
      metadata: nullable(record(string2(), string2())),
      tools: array(union([
        lazy(() => OpenResponsesNonStreamingResponseToolFunction$inboundSchema),
        OpenResponsesWebSearchPreviewTool$inboundSchema,
        OpenResponsesWebSearchPreview20250311Tool$inboundSchema,
        OpenResponsesWebSearchTool$inboundSchema,
        OpenResponsesWebSearch20250826Tool$inboundSchema
      ])),
      tool_choice: OpenAIResponsesToolChoiceUnion$inboundSchema,
      parallel_tool_calls: boolean2(),
      prompt: nullable(OpenAIResponsesPrompt$inboundSchema).optional(),
      background: nullable(boolean2()).optional(),
      previous_response_id: nullable(string2()).optional(),
      reasoning: nullable(OpenAIResponsesReasoningConfig$inboundSchema).optional(),
      service_tier: nullable(OpenAIResponsesServiceTier$inboundSchema).optional(),
      store: boolean2().optional(),
      truncation: nullable(OpenAIResponsesTruncation$inboundSchema).optional(),
      text: ResponseTextConfig$inboundSchema.optional()
    }).transform((v) => {
      return remap(v, {
        "created_at": "createdAt",
        "completed_at": "completedAt",
        "output_text": "outputText",
        "prompt_cache_key": "promptCacheKey",
        "safety_identifier": "safetyIdentifier",
        "incomplete_details": "incompleteDetails",
        "max_tool_calls": "maxToolCalls",
        "top_logprobs": "topLogprobs",
        "max_output_tokens": "maxOutputTokens",
        "top_p": "topP",
        "presence_penalty": "presencePenalty",
        "frequency_penalty": "frequencyPenalty",
        "tool_choice": "toolChoice",
        "parallel_tool_calls": "parallelToolCalls",
        "previous_response_id": "previousResponseId",
        "service_tier": "serviceTier"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesreasoningconfig.js
var OpenResponsesReasoningConfig$outboundSchema;
var init_openresponsesreasoningconfig = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesreasoningconfig.js"() {
    init_v4();
    init_primitives();
    init_openairesponsesreasoningeffort();
    init_reasoningsummaryverbosity();
    OpenResponsesReasoningConfig$outboundSchema = object({
      effort: nullable(OpenAIResponsesReasoningEffort$outboundSchema).optional(),
      summary: ReasoningSummaryVerbosity$outboundSchema.optional(),
      maxTokens: nullable(number2()).optional(),
      enabled: nullable(boolean2()).optional()
    }).transform((v) => {
      return remap(v, {
        maxTokens: "max_tokens"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesreasoningdeltaevent.js
var OpenResponsesReasoningDeltaEvent$inboundSchema;
var init_openresponsesreasoningdeltaevent = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesreasoningdeltaevent.js"() {
    init_v4();
    init_primitives();
    OpenResponsesReasoningDeltaEvent$inboundSchema = object({
      type: literal("response.reasoning_text.delta"),
      output_index: number2(),
      item_id: string2(),
      content_index: number2(),
      delta: string2(),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "output_index": "outputIndex",
        "item_id": "itemId",
        "content_index": "contentIndex",
        "sequence_number": "sequenceNumber"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesreasoningdoneevent.js
var OpenResponsesReasoningDoneEvent$inboundSchema;
var init_openresponsesreasoningdoneevent = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesreasoningdoneevent.js"() {
    init_v4();
    init_primitives();
    OpenResponsesReasoningDoneEvent$inboundSchema = object({
      type: literal("response.reasoning_text.done"),
      output_index: number2(),
      item_id: string2(),
      content_index: number2(),
      text: string2(),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "output_index": "outputIndex",
        "item_id": "itemId",
        "content_index": "contentIndex",
        "sequence_number": "sequenceNumber"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesreasoningsummarypartaddedevent.js
var OpenResponsesReasoningSummaryPartAddedEvent$inboundSchema;
var init_openresponsesreasoningsummarypartaddedevent = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesreasoningsummarypartaddedevent.js"() {
    init_v4();
    init_primitives();
    init_reasoningsummarytext();
    OpenResponsesReasoningSummaryPartAddedEvent$inboundSchema = object({
      type: literal("response.reasoning_summary_part.added"),
      output_index: number2(),
      item_id: string2(),
      summary_index: number2(),
      part: ReasoningSummaryText$inboundSchema,
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "output_index": "outputIndex",
        "item_id": "itemId",
        "summary_index": "summaryIndex",
        "sequence_number": "sequenceNumber"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesreasoningsummarytextdeltaevent.js
var OpenResponsesReasoningSummaryTextDeltaEvent$inboundSchema;
var init_openresponsesreasoningsummarytextdeltaevent = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesreasoningsummarytextdeltaevent.js"() {
    init_v4();
    init_primitives();
    OpenResponsesReasoningSummaryTextDeltaEvent$inboundSchema = object({
      type: literal("response.reasoning_summary_text.delta"),
      item_id: string2(),
      output_index: number2(),
      summary_index: number2(),
      delta: string2(),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "item_id": "itemId",
        "output_index": "outputIndex",
        "summary_index": "summaryIndex",
        "sequence_number": "sequenceNumber"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesreasoningsummarytextdoneevent.js
var OpenResponsesReasoningSummaryTextDoneEvent$inboundSchema;
var init_openresponsesreasoningsummarytextdoneevent = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesreasoningsummarytextdoneevent.js"() {
    init_v4();
    init_primitives();
    OpenResponsesReasoningSummaryTextDoneEvent$inboundSchema = object({
      type: literal("response.reasoning_summary_text.done"),
      item_id: string2(),
      output_index: number2(),
      summary_index: number2(),
      text: string2(),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "item_id": "itemId",
        "output_index": "outputIndex",
        "summary_index": "summaryIndex",
        "sequence_number": "sequenceNumber"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesresponsetext.js
var OpenResponsesResponseTextVerbosity, OpenResponsesResponseTextVerbosity$outboundSchema, OpenResponsesResponseText$outboundSchema;
var init_openresponsesresponsetext = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesresponsetext.js"() {
    init_v4();
    init_enums();
    init_responseformattextconfig();
    OpenResponsesResponseTextVerbosity = {
      High: "high",
      Low: "low",
      Medium: "medium"
    };
    OpenResponsesResponseTextVerbosity$outboundSchema = outboundSchema(OpenResponsesResponseTextVerbosity);
    OpenResponsesResponseText$outboundSchema = object({
      format: ResponseFormatTextConfig$outboundSchema.optional(),
      verbosity: nullable(OpenResponsesResponseTextVerbosity$outboundSchema).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/pdfparserengine.js
var PDFParserEngine, PDFParserEngine$outboundSchema;
var init_pdfparserengine = __esm({
  "node_modules/@openrouter/sdk/esm/models/pdfparserengine.js"() {
    init_enums();
    PDFParserEngine = {
      MistralOcr: "mistral-ocr",
      PdfText: "pdf-text",
      Native: "native"
    };
    PDFParserEngine$outboundSchema = outboundSchema(PDFParserEngine);
  }
});

// node_modules/@openrouter/sdk/esm/models/pdfparseroptions.js
var PDFParserOptions$outboundSchema;
var init_pdfparseroptions = __esm({
  "node_modules/@openrouter/sdk/esm/models/pdfparseroptions.js"() {
    init_v4();
    init_pdfparserengine();
    PDFParserOptions$outboundSchema = object({
      engine: PDFParserEngine$outboundSchema.optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/percentilelatencycutoffs.js
var PercentileLatencyCutoffs$outboundSchema;
var init_percentilelatencycutoffs = __esm({
  "node_modules/@openrouter/sdk/esm/models/percentilelatencycutoffs.js"() {
    init_v4();
    PercentileLatencyCutoffs$outboundSchema = object({
      p50: nullable(number2()).optional(),
      p75: nullable(number2()).optional(),
      p90: nullable(number2()).optional(),
      p99: nullable(number2()).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/preferredmaxlatency.js
var PreferredMaxLatency$outboundSchema;
var init_preferredmaxlatency = __esm({
  "node_modules/@openrouter/sdk/esm/models/preferredmaxlatency.js"() {
    init_v4();
    init_percentilelatencycutoffs();
    PreferredMaxLatency$outboundSchema = union([number2(), PercentileLatencyCutoffs$outboundSchema, any()]);
  }
});

// node_modules/@openrouter/sdk/esm/models/percentilethroughputcutoffs.js
var PercentileThroughputCutoffs$outboundSchema;
var init_percentilethroughputcutoffs = __esm({
  "node_modules/@openrouter/sdk/esm/models/percentilethroughputcutoffs.js"() {
    init_v4();
    PercentileThroughputCutoffs$outboundSchema = object({
      p50: nullable(number2()).optional(),
      p75: nullable(number2()).optional(),
      p90: nullable(number2()).optional(),
      p99: nullable(number2()).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/preferredminthroughput.js
var PreferredMinThroughput$outboundSchema;
var init_preferredminthroughput = __esm({
  "node_modules/@openrouter/sdk/esm/models/preferredminthroughput.js"() {
    init_v4();
    init_percentilethroughputcutoffs();
    PreferredMinThroughput$outboundSchema = union([number2(), PercentileThroughputCutoffs$outboundSchema, any()]);
  }
});

// node_modules/@openrouter/sdk/esm/models/quantization.js
var Quantization, Quantization$outboundSchema;
var init_quantization = __esm({
  "node_modules/@openrouter/sdk/esm/models/quantization.js"() {
    init_enums();
    Quantization = {
      Int4: "int4",
      Int8: "int8",
      Fp4: "fp4",
      Fp6: "fp6",
      Fp8: "fp8",
      Fp16: "fp16",
      Bf16: "bf16",
      Fp32: "fp32",
      Unknown: "unknown"
    };
    Quantization$outboundSchema = outboundSchema(Quantization);
  }
});

// node_modules/@openrouter/sdk/esm/models/responsesoutputmodality.js
var ResponsesOutputModality, ResponsesOutputModality$outboundSchema;
var init_responsesoutputmodality = __esm({
  "node_modules/@openrouter/sdk/esm/models/responsesoutputmodality.js"() {
    init_enums();
    ResponsesOutputModality = {
      Text: "text",
      Image: "image"
    };
    ResponsesOutputModality$outboundSchema = outboundSchema(ResponsesOutputModality);
  }
});

// node_modules/@openrouter/sdk/esm/models/websearchengine.js
var WebSearchEngine, WebSearchEngine$outboundSchema;
var init_websearchengine = __esm({
  "node_modules/@openrouter/sdk/esm/models/websearchengine.js"() {
    init_enums();
    WebSearchEngine = {
      Native: "native",
      Exa: "exa"
    };
    WebSearchEngine$outboundSchema = outboundSchema(WebSearchEngine);
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesrequest.js
var ServiceTier, Truncation, OpenResponsesRequestToolFunction$outboundSchema, OpenResponsesRequestToolUnion$outboundSchema, OpenResponsesRequestImageConfig$outboundSchema, ServiceTier$outboundSchema, Truncation$outboundSchema, OpenResponsesRequestOrder$outboundSchema, OpenResponsesRequestOnly$outboundSchema, OpenResponsesRequestIgnore$outboundSchema, OpenResponsesRequestSort$outboundSchema, OpenResponsesRequestMaxPrice$outboundSchema, Provider$outboundSchema, PluginResponseHealing$outboundSchema, PluginFileParser$outboundSchema, PluginWeb$outboundSchema, PluginModeration$outboundSchema, PluginAutoRouter$outboundSchema, Plugin$outboundSchema, OpenResponsesRequest$outboundSchema;
var init_openresponsesrequest = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesrequest.js"() {
    init_v4();
    init_primitives();
    init_enums();
    init_datacollection();
    init_openairesponsesincludable();
    init_openairesponsesprompt();
    init_openairesponsestoolchoiceunion();
    init_openresponsesinput();
    init_openresponsesreasoningconfig();
    init_openresponsesresponsetext();
    init_openresponseswebsearch20250826tool();
    init_openresponseswebsearchpreview20250311tool();
    init_openresponseswebsearchpreviewtool();
    init_openresponseswebsearchtool();
    init_pdfparseroptions();
    init_preferredmaxlatency();
    init_preferredminthroughput();
    init_providername();
    init_providersort();
    init_providersortconfig();
    init_quantization();
    init_responsesoutputmodality();
    init_websearchengine();
    ServiceTier = {
      Auto: "auto"
    };
    Truncation = {
      Auto: "auto",
      Disabled: "disabled"
    };
    OpenResponsesRequestToolFunction$outboundSchema = object({
      type: literal("function"),
      name: string2(),
      description: nullable(string2()).optional(),
      strict: nullable(boolean2()).optional(),
      parameters: nullable(record(string2(), nullable(any())))
    });
    OpenResponsesRequestToolUnion$outboundSchema = union([
      lazy(() => OpenResponsesRequestToolFunction$outboundSchema),
      OpenResponsesWebSearchPreviewTool$outboundSchema,
      OpenResponsesWebSearchPreview20250311Tool$outboundSchema,
      OpenResponsesWebSearchTool$outboundSchema,
      OpenResponsesWebSearch20250826Tool$outboundSchema
    ]);
    OpenResponsesRequestImageConfig$outboundSchema = union([string2(), number2()]);
    ServiceTier$outboundSchema = _enum2(ServiceTier);
    Truncation$outboundSchema = outboundSchema(Truncation);
    OpenResponsesRequestOrder$outboundSchema = union([ProviderName$outboundSchema, string2()]);
    OpenResponsesRequestOnly$outboundSchema = union([ProviderName$outboundSchema, string2()]);
    OpenResponsesRequestIgnore$outboundSchema = union([ProviderName$outboundSchema, string2()]);
    OpenResponsesRequestSort$outboundSchema = union([
      ProviderSort$outboundSchema,
      ProviderSortConfig$outboundSchema,
      any()
    ]);
    OpenResponsesRequestMaxPrice$outboundSchema = object({
      prompt: string2().optional(),
      completion: string2().optional(),
      image: string2().optional(),
      audio: string2().optional(),
      request: string2().optional()
    });
    Provider$outboundSchema = object({
      allowFallbacks: nullable(boolean2()).optional(),
      requireParameters: nullable(boolean2()).optional(),
      dataCollection: nullable(DataCollection$outboundSchema).optional(),
      zdr: nullable(boolean2()).optional(),
      enforceDistillableText: nullable(boolean2()).optional(),
      order: nullable(array(union([ProviderName$outboundSchema, string2()]))).optional(),
      only: nullable(array(union([ProviderName$outboundSchema, string2()]))).optional(),
      ignore: nullable(array(union([ProviderName$outboundSchema, string2()]))).optional(),
      quantizations: nullable(array(Quantization$outboundSchema)).optional(),
      sort: nullable(union([
        ProviderSort$outboundSchema,
        ProviderSortConfig$outboundSchema,
        any()
      ])).optional(),
      maxPrice: lazy(() => OpenResponsesRequestMaxPrice$outboundSchema).optional(),
      preferredMinThroughput: nullable(PreferredMinThroughput$outboundSchema).optional(),
      preferredMaxLatency: nullable(PreferredMaxLatency$outboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        allowFallbacks: "allow_fallbacks",
        requireParameters: "require_parameters",
        dataCollection: "data_collection",
        enforceDistillableText: "enforce_distillable_text",
        maxPrice: "max_price",
        preferredMinThroughput: "preferred_min_throughput",
        preferredMaxLatency: "preferred_max_latency"
      });
    });
    PluginResponseHealing$outboundSchema = object({
      id: literal("response-healing"),
      enabled: boolean2().optional()
    });
    PluginFileParser$outboundSchema = object({
      id: literal("file-parser"),
      enabled: boolean2().optional(),
      pdf: PDFParserOptions$outboundSchema.optional()
    });
    PluginWeb$outboundSchema = object({
      id: literal("web"),
      enabled: boolean2().optional(),
      maxResults: number2().optional(),
      searchPrompt: string2().optional(),
      engine: WebSearchEngine$outboundSchema.optional()
    }).transform((v) => {
      return remap(v, {
        maxResults: "max_results",
        searchPrompt: "search_prompt"
      });
    });
    PluginModeration$outboundSchema = object({
      id: literal("moderation")
    });
    PluginAutoRouter$outboundSchema = object({
      id: literal("auto-router"),
      enabled: boolean2().optional(),
      allowedModels: array(string2()).optional()
    }).transform((v) => {
      return remap(v, {
        allowedModels: "allowed_models"
      });
    });
    Plugin$outboundSchema = union([
      lazy(() => PluginAutoRouter$outboundSchema),
      lazy(() => PluginModeration$outboundSchema),
      lazy(() => PluginWeb$outboundSchema),
      lazy(() => PluginFileParser$outboundSchema),
      lazy(() => PluginResponseHealing$outboundSchema)
    ]);
    OpenResponsesRequest$outboundSchema = object({
      input: OpenResponsesInput$outboundSchema.optional(),
      instructions: nullable(string2()).optional(),
      metadata: nullable(record(string2(), string2())).optional(),
      tools: array(union([
        lazy(() => OpenResponsesRequestToolFunction$outboundSchema),
        OpenResponsesWebSearchPreviewTool$outboundSchema,
        OpenResponsesWebSearchPreview20250311Tool$outboundSchema,
        OpenResponsesWebSearchTool$outboundSchema,
        OpenResponsesWebSearch20250826Tool$outboundSchema
      ])).optional(),
      toolChoice: OpenAIResponsesToolChoiceUnion$outboundSchema.optional(),
      parallelToolCalls: nullable(boolean2()).optional(),
      model: string2().optional(),
      models: array(string2()).optional(),
      text: OpenResponsesResponseText$outboundSchema.optional(),
      reasoning: nullable(OpenResponsesReasoningConfig$outboundSchema).optional(),
      maxOutputTokens: nullable(number2()).optional(),
      temperature: nullable(number2()).optional(),
      topP: nullable(number2()).optional(),
      topLogprobs: nullable(int()).optional(),
      maxToolCalls: nullable(int()).optional(),
      presencePenalty: nullable(number2()).optional(),
      frequencyPenalty: nullable(number2()).optional(),
      topK: number2().optional(),
      imageConfig: record(string2(), union([string2(), number2()])).optional(),
      modalities: array(ResponsesOutputModality$outboundSchema).optional(),
      promptCacheKey: nullable(string2()).optional(),
      previousResponseId: nullable(string2()).optional(),
      prompt: nullable(OpenAIResponsesPrompt$outboundSchema).optional(),
      include: nullable(array(OpenAIResponsesIncludable$outboundSchema)).optional(),
      background: nullable(boolean2()).optional(),
      safetyIdentifier: nullable(string2()).optional(),
      store: literal(false).default(false),
      serviceTier: ServiceTier$outboundSchema.default("auto"),
      truncation: nullable(Truncation$outboundSchema).optional(),
      stream: boolean2().default(false),
      provider: nullable(lazy(() => Provider$outboundSchema)).optional(),
      plugins: array(union([
        lazy(() => PluginAutoRouter$outboundSchema),
        lazy(() => PluginModeration$outboundSchema),
        lazy(() => PluginWeb$outboundSchema),
        lazy(() => PluginFileParser$outboundSchema),
        lazy(() => PluginResponseHealing$outboundSchema)
      ])).optional(),
      user: string2().optional(),
      sessionId: string2().optional()
    }).transform((v) => {
      return remap(v, {
        toolChoice: "tool_choice",
        parallelToolCalls: "parallel_tool_calls",
        maxOutputTokens: "max_output_tokens",
        topP: "top_p",
        topLogprobs: "top_logprobs",
        maxToolCalls: "max_tool_calls",
        presencePenalty: "presence_penalty",
        frequencyPenalty: "frequency_penalty",
        topK: "top_k",
        imageConfig: "image_config",
        promptCacheKey: "prompt_cache_key",
        previousResponseId: "previous_response_id",
        safetyIdentifier: "safety_identifier",
        serviceTier: "service_tier",
        sessionId: "session_id"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/openresponsesstreamevent.js
var OpenResponsesStreamEventResponseReasoningSummaryPartDone$inboundSchema, OpenResponsesStreamEventResponseFunctionCallArgumentsDone$inboundSchema, OpenResponsesStreamEventResponseFunctionCallArgumentsDelta$inboundSchema, OpenResponsesStreamEventResponseOutputTextAnnotationAdded$inboundSchema, OpenResponsesStreamEventResponseRefusalDone$inboundSchema, OpenResponsesStreamEventResponseRefusalDelta$inboundSchema, OpenResponsesStreamEventResponseOutputTextDone$inboundSchema, OpenResponsesStreamEventResponseOutputTextDelta$inboundSchema, Part2$inboundSchema, OpenResponsesStreamEventResponseContentPartDone$inboundSchema, Part1$inboundSchema, OpenResponsesStreamEventResponseContentPartAdded$inboundSchema, OpenResponsesStreamEventResponseOutputItemDone$inboundSchema, OpenResponsesStreamEventResponseOutputItemAdded$inboundSchema, OpenResponsesStreamEventResponseFailed$inboundSchema, OpenResponsesStreamEventResponseIncomplete$inboundSchema, OpenResponsesStreamEventResponseCompleted$inboundSchema, OpenResponsesStreamEventResponseInProgress$inboundSchema, OpenResponsesStreamEventResponseCreated$inboundSchema, OpenResponsesStreamEvent$inboundSchema;
var init_openresponsesstreamevent = __esm({
  "node_modules/@openrouter/sdk/esm/models/openresponsesstreamevent.js"() {
    init_v4();
    init_primitives();
    init_openairesponsesannotation();
    init_openairesponsesrefusalcontent();
    init_openresponseserrorevent();
    init_openresponsesimagegencallcompleted();
    init_openresponsesimagegencallgenerating();
    init_openresponsesimagegencallinprogress();
    init_openresponsesimagegencallpartialimage();
    init_openresponseslogprobs();
    init_openresponsesnonstreamingresponse();
    init_openresponsesreasoningdeltaevent();
    init_openresponsesreasoningdoneevent();
    init_openresponsesreasoningsummarypartaddedevent();
    init_openresponsesreasoningsummarytextdeltaevent();
    init_openresponsesreasoningsummarytextdoneevent();
    init_reasoningsummarytext();
    init_reasoningtextcontent();
    init_responseoutputtext();
    init_responsesoutputitem();
    OpenResponsesStreamEventResponseReasoningSummaryPartDone$inboundSchema = object({
      type: literal("response.reasoning_summary_part.done"),
      output_index: number2(),
      item_id: string2(),
      summary_index: number2(),
      part: ReasoningSummaryText$inboundSchema,
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "output_index": "outputIndex",
        "item_id": "itemId",
        "summary_index": "summaryIndex",
        "sequence_number": "sequenceNumber"
      });
    });
    OpenResponsesStreamEventResponseFunctionCallArgumentsDone$inboundSchema = object({
      type: literal("response.function_call_arguments.done"),
      item_id: string2(),
      output_index: number2(),
      name: string2(),
      arguments: string2(),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "item_id": "itemId",
        "output_index": "outputIndex",
        "sequence_number": "sequenceNumber"
      });
    });
    OpenResponsesStreamEventResponseFunctionCallArgumentsDelta$inboundSchema = object({
      type: literal("response.function_call_arguments.delta"),
      item_id: string2(),
      output_index: number2(),
      delta: string2(),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "item_id": "itemId",
        "output_index": "outputIndex",
        "sequence_number": "sequenceNumber"
      });
    });
    OpenResponsesStreamEventResponseOutputTextAnnotationAdded$inboundSchema = object({
      type: literal("response.output_text.annotation.added"),
      output_index: number2(),
      item_id: string2(),
      content_index: number2(),
      sequence_number: number2(),
      annotation_index: number2(),
      annotation: OpenAIResponsesAnnotation$inboundSchema
    }).transform((v) => {
      return remap(v, {
        "output_index": "outputIndex",
        "item_id": "itemId",
        "content_index": "contentIndex",
        "sequence_number": "sequenceNumber",
        "annotation_index": "annotationIndex"
      });
    });
    OpenResponsesStreamEventResponseRefusalDone$inboundSchema = object({
      type: literal("response.refusal.done"),
      output_index: number2(),
      item_id: string2(),
      content_index: number2(),
      refusal: string2(),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "output_index": "outputIndex",
        "item_id": "itemId",
        "content_index": "contentIndex",
        "sequence_number": "sequenceNumber"
      });
    });
    OpenResponsesStreamEventResponseRefusalDelta$inboundSchema = object({
      type: literal("response.refusal.delta"),
      output_index: number2(),
      item_id: string2(),
      content_index: number2(),
      delta: string2(),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "output_index": "outputIndex",
        "item_id": "itemId",
        "content_index": "contentIndex",
        "sequence_number": "sequenceNumber"
      });
    });
    OpenResponsesStreamEventResponseOutputTextDone$inboundSchema = object({
      type: literal("response.output_text.done"),
      output_index: number2(),
      item_id: string2(),
      content_index: number2(),
      text: string2(),
      sequence_number: number2(),
      logprobs: array(OpenResponsesLogProbs$inboundSchema)
    }).transform((v) => {
      return remap(v, {
        "output_index": "outputIndex",
        "item_id": "itemId",
        "content_index": "contentIndex",
        "sequence_number": "sequenceNumber"
      });
    });
    OpenResponsesStreamEventResponseOutputTextDelta$inboundSchema = object({
      type: literal("response.output_text.delta"),
      logprobs: array(OpenResponsesLogProbs$inboundSchema),
      output_index: number2(),
      item_id: string2(),
      content_index: number2(),
      delta: string2(),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "output_index": "outputIndex",
        "item_id": "itemId",
        "content_index": "contentIndex",
        "sequence_number": "sequenceNumber"
      });
    });
    Part2$inboundSchema = union([
      ResponseOutputText$inboundSchema,
      ReasoningTextContent$inboundSchema.and(object({ type: literal("reasoning_text") })),
      OpenAIResponsesRefusalContent$inboundSchema
    ]);
    OpenResponsesStreamEventResponseContentPartDone$inboundSchema = object({
      type: literal("response.content_part.done"),
      output_index: number2(),
      item_id: string2(),
      content_index: number2(),
      part: union([
        ResponseOutputText$inboundSchema,
        ReasoningTextContent$inboundSchema.and(object({ type: literal("reasoning_text") })),
        OpenAIResponsesRefusalContent$inboundSchema
      ]),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "output_index": "outputIndex",
        "item_id": "itemId",
        "content_index": "contentIndex",
        "sequence_number": "sequenceNumber"
      });
    });
    Part1$inboundSchema = union([
      ResponseOutputText$inboundSchema,
      ReasoningTextContent$inboundSchema.and(object({ type: literal("reasoning_text") })),
      OpenAIResponsesRefusalContent$inboundSchema
    ]);
    OpenResponsesStreamEventResponseContentPartAdded$inboundSchema = object({
      type: literal("response.content_part.added"),
      output_index: number2(),
      item_id: string2(),
      content_index: number2(),
      part: union([
        ResponseOutputText$inboundSchema,
        ReasoningTextContent$inboundSchema.and(object({ type: literal("reasoning_text") })),
        OpenAIResponsesRefusalContent$inboundSchema
      ]),
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "output_index": "outputIndex",
        "item_id": "itemId",
        "content_index": "contentIndex",
        "sequence_number": "sequenceNumber"
      });
    });
    OpenResponsesStreamEventResponseOutputItemDone$inboundSchema = object({
      type: literal("response.output_item.done"),
      output_index: number2(),
      item: ResponsesOutputItem$inboundSchema,
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "output_index": "outputIndex",
        "sequence_number": "sequenceNumber"
      });
    });
    OpenResponsesStreamEventResponseOutputItemAdded$inboundSchema = object({
      type: literal("response.output_item.added"),
      output_index: number2(),
      item: ResponsesOutputItem$inboundSchema,
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "output_index": "outputIndex",
        "sequence_number": "sequenceNumber"
      });
    });
    OpenResponsesStreamEventResponseFailed$inboundSchema = object({
      type: literal("response.failed"),
      response: OpenResponsesNonStreamingResponse$inboundSchema,
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "sequence_number": "sequenceNumber"
      });
    });
    OpenResponsesStreamEventResponseIncomplete$inboundSchema = object({
      type: literal("response.incomplete"),
      response: OpenResponsesNonStreamingResponse$inboundSchema,
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "sequence_number": "sequenceNumber"
      });
    });
    OpenResponsesStreamEventResponseCompleted$inboundSchema = object({
      type: literal("response.completed"),
      response: OpenResponsesNonStreamingResponse$inboundSchema,
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "sequence_number": "sequenceNumber"
      });
    });
    OpenResponsesStreamEventResponseInProgress$inboundSchema = object({
      type: literal("response.in_progress"),
      response: OpenResponsesNonStreamingResponse$inboundSchema,
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "sequence_number": "sequenceNumber"
      });
    });
    OpenResponsesStreamEventResponseCreated$inboundSchema = object({
      type: literal("response.created"),
      response: OpenResponsesNonStreamingResponse$inboundSchema,
      sequence_number: number2()
    }).transform((v) => {
      return remap(v, {
        "sequence_number": "sequenceNumber"
      });
    });
    OpenResponsesStreamEvent$inboundSchema = union([
      lazy(() => OpenResponsesStreamEventResponseCreated$inboundSchema),
      lazy(() => OpenResponsesStreamEventResponseInProgress$inboundSchema),
      lazy(() => OpenResponsesStreamEventResponseCompleted$inboundSchema),
      lazy(() => OpenResponsesStreamEventResponseIncomplete$inboundSchema),
      lazy(() => OpenResponsesStreamEventResponseFailed$inboundSchema),
      OpenResponsesErrorEvent$inboundSchema,
      lazy(() => OpenResponsesStreamEventResponseOutputItemAdded$inboundSchema),
      lazy(() => OpenResponsesStreamEventResponseOutputItemDone$inboundSchema),
      lazy(() => OpenResponsesStreamEventResponseContentPartAdded$inboundSchema),
      lazy(() => OpenResponsesStreamEventResponseContentPartDone$inboundSchema),
      lazy(() => OpenResponsesStreamEventResponseOutputTextDelta$inboundSchema),
      lazy(() => OpenResponsesStreamEventResponseOutputTextDone$inboundSchema),
      lazy(() => OpenResponsesStreamEventResponseRefusalDelta$inboundSchema),
      lazy(() => OpenResponsesStreamEventResponseRefusalDone$inboundSchema),
      lazy(() => OpenResponsesStreamEventResponseOutputTextAnnotationAdded$inboundSchema),
      lazy(() => OpenResponsesStreamEventResponseFunctionCallArgumentsDelta$inboundSchema),
      lazy(() => OpenResponsesStreamEventResponseFunctionCallArgumentsDone$inboundSchema),
      OpenResponsesReasoningDeltaEvent$inboundSchema,
      OpenResponsesReasoningDoneEvent$inboundSchema,
      OpenResponsesReasoningSummaryPartAddedEvent$inboundSchema,
      lazy(() => OpenResponsesStreamEventResponseReasoningSummaryPartDone$inboundSchema),
      OpenResponsesReasoningSummaryTextDeltaEvent$inboundSchema,
      OpenResponsesReasoningSummaryTextDoneEvent$inboundSchema,
      OpenResponsesImageGenCallInProgress$inboundSchema,
      OpenResponsesImageGenCallGenerating$inboundSchema,
      OpenResponsesImageGenCallPartialImage$inboundSchema,
      OpenResponsesImageGenCallCompleted$inboundSchema
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/payloadtoolargeresponseerrordata.js
var PayloadTooLargeResponseErrorData$inboundSchema;
var init_payloadtoolargeresponseerrordata = __esm({
  "node_modules/@openrouter/sdk/esm/models/payloadtoolargeresponseerrordata.js"() {
    init_v4();
    PayloadTooLargeResponseErrorData$inboundSchema = object({
      code: int(),
      message: string2(),
      metadata: nullable(record(string2(), nullable(any()))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/paymentrequiredresponseerrordata.js
var PaymentRequiredResponseErrorData$inboundSchema;
var init_paymentrequiredresponseerrordata = __esm({
  "node_modules/@openrouter/sdk/esm/models/paymentrequiredresponseerrordata.js"() {
    init_v4();
    PaymentRequiredResponseErrorData$inboundSchema = object({
      code: int(),
      message: string2(),
      metadata: nullable(record(string2(), nullable(any()))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/provideroverloadedresponseerrordata.js
var ProviderOverloadedResponseErrorData$inboundSchema;
var init_provideroverloadedresponseerrordata = __esm({
  "node_modules/@openrouter/sdk/esm/models/provideroverloadedresponseerrordata.js"() {
    init_v4();
    ProviderOverloadedResponseErrorData$inboundSchema = object({
      code: int(),
      message: string2(),
      metadata: nullable(record(string2(), nullable(any()))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/providerpreferences.js
var SortEnum, ProviderSortConfigEnum, ProviderPreferencesPartition, ProviderPreferencesProviderSort, ProviderPreferencesOrder$outboundSchema, ProviderPreferencesOnly$outboundSchema, ProviderPreferencesIgnore$outboundSchema, SortEnum$outboundSchema, ProviderSortConfigEnum$outboundSchema, ProviderPreferencesPartition$outboundSchema, ProviderPreferencesProviderSortConfig$outboundSchema, ProviderSortConfigUnion$outboundSchema, ProviderPreferencesProviderSort$outboundSchema, ProviderPreferencesSortUnion$outboundSchema, ProviderPreferencesMaxPrice$outboundSchema, ProviderPreferences$outboundSchema;
var init_providerpreferences = __esm({
  "node_modules/@openrouter/sdk/esm/models/providerpreferences.js"() {
    init_v4();
    init_primitives();
    init_enums();
    init_datacollection();
    init_preferredmaxlatency();
    init_preferredminthroughput();
    init_providername();
    init_providersort();
    init_quantization();
    SortEnum = {
      Price: "price",
      Throughput: "throughput",
      Latency: "latency"
    };
    ProviderSortConfigEnum = {
      Price: "price",
      Throughput: "throughput",
      Latency: "latency"
    };
    ProviderPreferencesPartition = {
      Model: "model",
      None: "none"
    };
    ProviderPreferencesProviderSort = {
      Price: "price",
      Throughput: "throughput",
      Latency: "latency"
    };
    ProviderPreferencesOrder$outboundSchema = union([ProviderName$outboundSchema, string2()]);
    ProviderPreferencesOnly$outboundSchema = union([ProviderName$outboundSchema, string2()]);
    ProviderPreferencesIgnore$outboundSchema = union([ProviderName$outboundSchema, string2()]);
    SortEnum$outboundSchema = outboundSchema(SortEnum);
    ProviderSortConfigEnum$outboundSchema = _enum2(ProviderSortConfigEnum);
    ProviderPreferencesPartition$outboundSchema = outboundSchema(ProviderPreferencesPartition);
    ProviderPreferencesProviderSortConfig$outboundSchema = object({
      by: nullable(ProviderSort$outboundSchema).optional(),
      partition: nullable(ProviderPreferencesPartition$outboundSchema).optional()
    });
    ProviderSortConfigUnion$outboundSchema = union([
      lazy(() => ProviderPreferencesProviderSortConfig$outboundSchema),
      ProviderSortConfigEnum$outboundSchema
    ]);
    ProviderPreferencesProviderSort$outboundSchema = outboundSchema(ProviderPreferencesProviderSort);
    ProviderPreferencesSortUnion$outboundSchema = union([
      ProviderPreferencesProviderSort$outboundSchema,
      union([
        lazy(() => ProviderPreferencesProviderSortConfig$outboundSchema),
        ProviderSortConfigEnum$outboundSchema
      ]),
      SortEnum$outboundSchema
    ]);
    ProviderPreferencesMaxPrice$outboundSchema = object({
      prompt: string2().optional(),
      completion: string2().optional(),
      image: string2().optional(),
      audio: string2().optional(),
      request: string2().optional()
    });
    ProviderPreferences$outboundSchema = object({
      allowFallbacks: nullable(boolean2()).optional(),
      requireParameters: nullable(boolean2()).optional(),
      dataCollection: nullable(DataCollection$outboundSchema).optional(),
      zdr: nullable(boolean2()).optional(),
      enforceDistillableText: nullable(boolean2()).optional(),
      order: nullable(array(union([ProviderName$outboundSchema, string2()]))).optional(),
      only: nullable(array(union([ProviderName$outboundSchema, string2()]))).optional(),
      ignore: nullable(array(union([ProviderName$outboundSchema, string2()]))).optional(),
      quantizations: nullable(array(Quantization$outboundSchema)).optional(),
      sort: nullable(union([
        ProviderPreferencesProviderSort$outboundSchema,
        union([
          lazy(() => ProviderPreferencesProviderSortConfig$outboundSchema),
          ProviderSortConfigEnum$outboundSchema
        ]),
        SortEnum$outboundSchema
      ])).optional(),
      maxPrice: lazy(() => ProviderPreferencesMaxPrice$outboundSchema).optional(),
      preferredMinThroughput: nullable(PreferredMinThroughput$outboundSchema).optional(),
      preferredMaxLatency: nullable(PreferredMaxLatency$outboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        allowFallbacks: "allow_fallbacks",
        requireParameters: "require_parameters",
        dataCollection: "data_collection",
        enforceDistillableText: "enforce_distillable_text",
        maxPrice: "max_price",
        preferredMinThroughput: "preferred_min_throughput",
        preferredMaxLatency: "preferred_max_latency"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/requesttimeoutresponseerrordata.js
var RequestTimeoutResponseErrorData$inboundSchema;
var init_requesttimeoutresponseerrordata = __esm({
  "node_modules/@openrouter/sdk/esm/models/requesttimeoutresponseerrordata.js"() {
    init_v4();
    RequestTimeoutResponseErrorData$inboundSchema = object({
      code: int(),
      message: string2(),
      metadata: nullable(record(string2(), nullable(any()))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/security.js
var Security$outboundSchema;
var init_security = __esm({
  "node_modules/@openrouter/sdk/esm/models/security.js"() {
    init_v4();
    Security$outboundSchema = object({
      apiKey: string2().optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/serviceunavailableresponseerrordata.js
var ServiceUnavailableResponseErrorData$inboundSchema;
var init_serviceunavailableresponseerrordata = __esm({
  "node_modules/@openrouter/sdk/esm/models/serviceunavailableresponseerrordata.js"() {
    init_v4();
    ServiceUnavailableResponseErrorData$inboundSchema = object({
      code: int(),
      message: string2(),
      metadata: nullable(record(string2(), nullable(any()))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/toomanyrequestsresponseerrordata.js
var TooManyRequestsResponseErrorData$inboundSchema;
var init_toomanyrequestsresponseerrordata = __esm({
  "node_modules/@openrouter/sdk/esm/models/toomanyrequestsresponseerrordata.js"() {
    init_v4();
    TooManyRequestsResponseErrorData$inboundSchema = object({
      code: int(),
      message: string2(),
      metadata: nullable(record(string2(), nullable(any()))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/unauthorizedresponseerrordata.js
var UnauthorizedResponseErrorData$inboundSchema;
var init_unauthorizedresponseerrordata = __esm({
  "node_modules/@openrouter/sdk/esm/models/unauthorizedresponseerrordata.js"() {
    init_v4();
    UnauthorizedResponseErrorData$inboundSchema = object({
      code: int(),
      message: string2(),
      metadata: nullable(record(string2(), nullable(any()))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/unprocessableentityresponseerrordata.js
var UnprocessableEntityResponseErrorData$inboundSchema;
var init_unprocessableentityresponseerrordata = __esm({
  "node_modules/@openrouter/sdk/esm/models/unprocessableentityresponseerrordata.js"() {
    init_v4();
    UnprocessableEntityResponseErrorData$inboundSchema = object({
      code: int(),
      message: string2(),
      metadata: nullable(record(string2(), nullable(any()))).optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/claude-message.js
var init_claude_message = __esm({
  "node_modules/@openrouter/sdk/esm/models/claude-message.js"() {
  }
});

// node_modules/@openrouter/sdk/esm/models/index.js
var init_models = __esm({
  "node_modules/@openrouter/sdk/esm/models/index.js"() {
    init_activityitem();
    init_assistantmessage();
    init_badgatewayresponseerrordata();
    init_badrequestresponseerrordata();
    init_chatcompletionfinishreason();
    init_chaterror();
    init_chatgenerationparams();
    init_chatgenerationtokenusage();
    init_chatmessagecontentitem();
    init_chatmessagecontentitemaudio();
    init_chatmessagecontentitemcachecontrol();
    init_chatmessagecontentitemimage();
    init_chatmessagecontentitemtext();
    init_chatmessagecontentitemvideo();
    init_chatmessagetokenlogprob();
    init_chatmessagetokenlogprobs();
    init_chatmessagetoolcall();
    init_chatresponse();
    init_chatresponsechoice();
    init_chatstreamingchoice();
    init_chatstreamingmessagechunk();
    init_chatstreamingmessagetoolcall();
    init_chatstreamingresponsechunk();
    init_chatstreamoptions();
    init_createchargerequest();
    init_datacollection();
    init_defaultparameters();
    init_developermessage();
    init_edgenetworktimeoutresponseerrordata();
    init_endpointstatus();
    init_filecitation();
    init_filepath();
    init_forbiddenresponseerrordata();
    init_imagegenerationstatus();
    init_inputmodality();
    init_instructtype();
    init_internalserverresponseerrordata();
    init_jsonschemaconfig();
    init_listendpointsresponse();
    init_message();
    init_model();
    init_modelarchitecture();
    init_modelgroup();
    init_modelscountresponse();
    init_modelslistresponse();
    init_namedtoolchoice();
    init_notfoundresponseerrordata();
    init_openairesponsesannotation();
    init_openairesponsesincludable();
    init_openairesponsesincompletedetails();
    init_openairesponsesinputunion();
    init_openairesponsesprompt();
    init_openairesponsesreasoningconfig();
    init_openairesponsesreasoningeffort();
    init_openairesponsesrefusalcontent();
    init_openairesponsesresponsestatus();
    init_openairesponsesservicetier();
    init_openairesponsestoolchoiceunion();
    init_openairesponsestruncation();
    init_openresponseseasyinputmessage();
    init_openresponseserrorevent();
    init_openresponsesfunctioncalloutput();
    init_openresponsesfunctiontoolcall();
    init_openresponsesimagegencallcompleted();
    init_openresponsesimagegencallgenerating();
    init_openresponsesimagegencallinprogress();
    init_openresponsesimagegencallpartialimage();
    init_openresponsesinput();
    init_openresponsesinputmessageitem();
    init_openresponseslogprobs();
    init_openresponsesnonstreamingresponse();
    init_openresponsesreasoning();
    init_openresponsesreasoningconfig();
    init_openresponsesreasoningdeltaevent();
    init_openresponsesreasoningdoneevent();
    init_openresponsesreasoningsummarypartaddedevent();
    init_openresponsesreasoningsummarytextdeltaevent();
    init_openresponsesreasoningsummarytextdoneevent();
    init_openresponsesrequest();
    init_openresponsesresponsetext();
    init_openresponsesstreamevent();
    init_openresponsestoplogprobs();
    init_openresponsesusage();
    init_openresponseswebsearch20250826tool();
    init_openresponseswebsearchpreview20250311tool();
    init_openresponseswebsearchpreviewtool();
    init_openresponseswebsearchtool();
    init_outputitemimagegenerationcall();
    init_outputmessage();
    init_outputmodality();
    init_parameter();
    init_payloadtoolargeresponseerrordata();
    init_paymentrequiredresponseerrordata();
    init_pdfparserengine();
    init_pdfparseroptions();
    init_percentilelatencycutoffs();
    init_percentilestats();
    init_percentilethroughputcutoffs();
    init_perrequestlimits();
    init_preferredmaxlatency();
    init_preferredminthroughput();
    init_providername();
    init_provideroverloadedresponseerrordata();
    init_providerpreferences();
    init_providersort();
    init_providersortconfig();
    init_providersortunion();
    init_publicendpoint();
    init_publicpricing();
    init_quantization();
    init_reasoningsummarytext();
    init_reasoningsummaryverbosity();
    init_reasoningtextcontent();
    init_requesttimeoutresponseerrordata();
    init_responseformatjsonschema();
    init_responseformattextconfig();
    init_responseformattextgrammar();
    init_responseinputaudio();
    init_responseinputfile();
    init_responseinputimage();
    init_responseinputtext();
    init_responseinputvideo();
    init_responseoutputtext();
    init_responseserrorfield();
    init_responsesformatjsonobject();
    init_responsesformattext();
    init_responsesformattextjsonschemaconfig();
    init_responsesimagegenerationcall();
    init_responsesoutputitem();
    init_responsesoutputitemfilesearchcall();
    init_responsesoutputitemfunctioncall();
    init_responsesoutputitemreasoning();
    init_responsesoutputmessage();
    init_responsesoutputmodality();
    init_responsessearchcontextsize();
    init_responseswebsearchcalloutput();
    init_responseswebsearchuserlocation();
    init_responsetextconfig();
    init_schema10();
    init_schema14();
    init_schema17();
    init_schema19();
    init_schema5();
    init_security();
    init_serviceunavailableresponseerrordata();
    init_systemmessage();
    init_toolcallstatus();
    init_tooldefinitionjson();
    init_toolresponsemessage();
    init_toomanyrequestsresponseerrordata();
    init_topproviderinfo();
    init_unauthorizedresponseerrordata();
    init_unprocessableentityresponseerrordata();
    init_urlcitation();
    init_usermessage();
    init_websearchengine();
    init_websearchpreviewtooluserlocation();
    init_websearchstatus();
    init_claude_message();
  }
});

// node_modules/@openrouter/sdk/esm/lib/turn-context.js
function normalizeInputToArray(input) {
  if (typeof input === "string") {
    const message = {
      role: OpenResponsesEasyInputMessageRoleUser.User,
      content: input
    };
    return [message];
  }
  return input;
}
var init_turn_context = __esm({
  "node_modules/@openrouter/sdk/esm/lib/turn-context.js"() {
    init_models();
  }
});

// node_modules/@openrouter/sdk/esm/lib/conversation-state.js
function isValidUnsentToolResult(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  const candidate = obj;
  return typeof candidate["callId"] === "string" && typeof candidate["name"] === "string" && "output" in candidate;
}
function generateConversationId() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return `conv_${crypto.randomUUID()}`;
  }
  return `conv_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
}
function createInitialState(id) {
  const now = Date.now();
  return {
    id: id ?? generateConversationId(),
    messages: [],
    status: "in_progress",
    createdAt: now,
    updatedAt: now
  };
}
function updateState(state, updates) {
  return {
    ...state,
    ...updates,
    updatedAt: Date.now()
  };
}
function appendToMessages(current, newItems) {
  const currentArray = normalizeInputToArray(current);
  return [...currentArray, ...newItems];
}
async function toolRequiresApproval(toolCall, tools, context, callLevelCheck) {
  if (callLevelCheck) {
    return callLevelCheck(toolCall, context);
  }
  const tool = tools.find((t) => t.function.name === toolCall.name);
  if (!tool)
    return false;
  const requireApproval = tool.function.requireApproval;
  if (typeof requireApproval === "function") {
    return requireApproval(toolCall.arguments, context);
  }
  return requireApproval ?? false;
}
async function partitionToolCalls(toolCalls, tools, context, callLevelCheck) {
  const requiresApproval = [];
  const autoExecute = [];
  for (const tc of toolCalls) {
    if (await toolRequiresApproval(tc, tools, context, callLevelCheck)) {
      requiresApproval.push(tc);
    } else {
      autoExecute.push(tc);
    }
  }
  return { requiresApproval, autoExecute };
}
function createUnsentResult(callId, name, output) {
  const result = { callId, name, output };
  if (!isValidUnsentToolResult(result)) {
    throw new Error("Invalid UnsentToolResult structure");
  }
  return result;
}
function createRejectedResult(callId, name, reason) {
  const result = {
    callId,
    name,
    output: null,
    error: reason ?? "Tool call rejected by user"
  };
  if (!isValidUnsentToolResult(result)) {
    throw new Error("Invalid UnsentToolResult structure");
  }
  return result;
}
function unsentResultsToAPIFormat(results) {
  return results.map((r) => ({
    type: "function_call_output",
    id: `output_${r.callId}`,
    callId: r.callId,
    output: r.error ? JSON.stringify({ error: r.error }) : JSON.stringify(r.output)
  }));
}
function extractTextFromResponse2(response) {
  if (!response.output) {
    return "";
  }
  const outputs = Array.isArray(response.output) ? response.output : [response.output];
  const textParts = [];
  for (const item of outputs) {
    if (item.type === "message" && item.content) {
      for (const content of item.content) {
        if (content.type === "output_text" && content.text) {
          textParts.push(content.text);
        }
      }
    }
  }
  return textParts.join("");
}
var init_conversation_state = __esm({
  "node_modules/@openrouter/sdk/esm/lib/conversation-state.js"() {
    init_turn_context();
  }
});

// node_modules/@openrouter/sdk/esm/lib/tool-event-broadcaster.js
var ToolEventBroadcaster;
var init_tool_event_broadcaster = __esm({
  "node_modules/@openrouter/sdk/esm/lib/tool-event-broadcaster.js"() {
    ToolEventBroadcaster = class {
      constructor() {
        this.buffer = [];
        this.consumers = /* @__PURE__ */ new Map();
        this.nextConsumerId = 0;
        this.isComplete = false;
        this.completionError = null;
      }
      /**
       * Push a new event to all consumers.
       * Events are buffered so late-joining consumers can catch up.
       */
      push(event) {
        if (this.isComplete) {
          return;
        }
        this.buffer.push(event);
        this.notifyWaitingConsumers();
      }
      /**
       * Mark the broadcaster as complete - no more events will be pushed.
       * Optionally pass an error to signal failure to all consumers.
       * Cleans up buffer and consumers after completion.
       */
      complete(error48) {
        this.isComplete = true;
        this.completionError = error48 ?? null;
        this.notifyWaitingConsumers();
        queueMicrotask(() => this.cleanup());
      }
      /**
       * Clean up resources after all consumers have finished.
       * Called automatically after complete(), but can be called manually.
       */
      cleanup() {
        if (this.isComplete && this.consumers.size === 0) {
          this.buffer = [];
        }
      }
      /**
       * Create a new consumer that can independently iterate over events.
       * Consumers can join at any time and will receive events from position 0.
       * Multiple consumers can be created and will all receive the same events.
       */
      createConsumer() {
        const consumerId = this.nextConsumerId++;
        const state = {
          position: 0,
          waitingPromise: null,
          cancelled: false
        };
        this.consumers.set(consumerId, state);
        const self = this;
        return {
          async next() {
            const consumer = self.consumers.get(consumerId);
            if (!consumer) {
              return { done: true, value: void 0 };
            }
            if (consumer.cancelled) {
              return { done: true, value: void 0 };
            }
            if (consumer.position < self.buffer.length) {
              const value = self.buffer[consumer.position];
              consumer.position++;
              return { done: false, value };
            }
            if (self.isComplete) {
              self.consumers.delete(consumerId);
              self.cleanup();
              if (self.completionError) {
                throw self.completionError;
              }
              return { done: true, value: void 0 };
            }
            const waitPromise = new Promise((resolve, reject) => {
              consumer.waitingPromise = { resolve, reject };
              if (self.isComplete || self.completionError || consumer.position < self.buffer.length) {
                resolve();
              }
            });
            await waitPromise;
            consumer.waitingPromise = null;
            return this.next();
          },
          async return() {
            const consumer = self.consumers.get(consumerId);
            if (consumer) {
              consumer.cancelled = true;
              self.consumers.delete(consumerId);
              self.cleanup();
            }
            return { done: true, value: void 0 };
          },
          async throw(e) {
            const consumer = self.consumers.get(consumerId);
            if (consumer) {
              consumer.cancelled = true;
              self.consumers.delete(consumerId);
              self.cleanup();
            }
            throw e;
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
      /**
       * Notify all waiting consumers that new data is available or stream completed
       */
      notifyWaitingConsumers() {
        for (const consumer of this.consumers.values()) {
          if (consumer.waitingPromise) {
            if (this.completionError) {
              consumer.waitingPromise.reject(this.completionError);
            } else {
              consumer.waitingPromise.resolve();
            }
            consumer.waitingPromise = null;
          }
        }
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/hooks/registration.js
function initHooks(_hooks) {
}
var init_registration = __esm({
  "node_modules/@openrouter/sdk/esm/hooks/registration.js"() {
  }
});

// node_modules/@openrouter/sdk/esm/hooks/hooks.js
var SDKHooks;
var init_hooks = __esm({
  "node_modules/@openrouter/sdk/esm/hooks/hooks.js"() {
    init_registration();
    SDKHooks = class {
      constructor() {
        this.sdkInitHooks = [];
        this.beforeCreateRequestHooks = [];
        this.beforeRequestHooks = [];
        this.afterSuccessHooks = [];
        this.afterErrorHooks = [];
        const presetHooks = [];
        for (const hook of presetHooks) {
          if ("sdkInit" in hook) {
            this.registerSDKInitHook(hook);
          }
          if ("beforeCreateRequest" in hook) {
            this.registerBeforeCreateRequestHook(hook);
          }
          if ("beforeRequest" in hook) {
            this.registerBeforeRequestHook(hook);
          }
          if ("afterSuccess" in hook) {
            this.registerAfterSuccessHook(hook);
          }
          if ("afterError" in hook) {
            this.registerAfterErrorHook(hook);
          }
        }
        initHooks(this);
      }
      registerSDKInitHook(hook) {
        this.sdkInitHooks.push(hook);
      }
      registerBeforeCreateRequestHook(hook) {
        this.beforeCreateRequestHooks.push(hook);
      }
      registerBeforeRequestHook(hook) {
        this.beforeRequestHooks.push(hook);
      }
      registerAfterSuccessHook(hook) {
        this.afterSuccessHooks.push(hook);
      }
      registerAfterErrorHook(hook) {
        this.afterErrorHooks.push(hook);
      }
      sdkInit(opts) {
        return this.sdkInitHooks.reduce((opts2, hook) => hook.sdkInit(opts2), opts);
      }
      beforeCreateRequest(hookCtx, input) {
        let inp = input;
        for (const hook of this.beforeCreateRequestHooks) {
          inp = hook.beforeCreateRequest(hookCtx, inp);
        }
        return inp;
      }
      async beforeRequest(hookCtx, request) {
        let req = request;
        for (const hook of this.beforeRequestHooks) {
          req = await hook.beforeRequest(hookCtx, req);
        }
        return req;
      }
      async afterSuccess(hookCtx, response) {
        let res = response;
        for (const hook of this.afterSuccessHooks) {
          res = await hook.afterSuccess(hookCtx, res);
        }
        return res;
      }
      async afterError(hookCtx, response, error48) {
        let res = response;
        let err = error48;
        for (const hook of this.afterErrorHooks) {
          const result = await hook.afterError(hookCtx, res, err);
          res = result.response;
          err = result.error;
        }
        return { response: res, error: err };
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/httpclienterrors.js
var HTTPClientError, UnexpectedClientError, InvalidRequestError, RequestAbortedError, RequestTimeoutError, ConnectionError;
var init_httpclienterrors = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/httpclienterrors.js"() {
    HTTPClientError = class extends Error {
      constructor(message, opts) {
        let msg = message;
        if (opts?.cause) {
          msg += `: ${opts.cause}`;
        }
        super(msg, opts);
        this.name = "HTTPClientError";
        if (typeof this.cause === "undefined") {
          this.cause = opts?.cause;
        }
      }
    };
    UnexpectedClientError = class extends HTTPClientError {
      constructor() {
        super(...arguments);
        this.name = "UnexpectedClientError";
      }
    };
    InvalidRequestError = class extends HTTPClientError {
      constructor() {
        super(...arguments);
        this.name = "InvalidRequestError";
      }
    };
    RequestAbortedError = class extends HTTPClientError {
      constructor() {
        super(...arguments);
        this.name = "RequestAbortedError";
      }
    };
    RequestTimeoutError = class extends HTTPClientError {
      constructor() {
        super(...arguments);
        this.name = "RequestTimeoutError";
      }
    };
    ConnectionError = class extends HTTPClientError {
      constructor() {
        super(...arguments);
        this.name = "ConnectionError";
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/lib/base64.js
function bytesToBase64(u8arr) {
  return btoa(String.fromCodePoint(...u8arr));
}
function bytesFromBase64(encoded) {
  return Uint8Array.from(atob(encoded), (c) => c.charCodeAt(0));
}
function stringToBytes(str) {
  return new TextEncoder().encode(str);
}
function stringToBase64(str) {
  return bytesToBase64(stringToBytes(str));
}
var zodOutbound, zodInbound;
var init_base64 = __esm({
  "node_modules/@openrouter/sdk/esm/lib/base64.js"() {
    init_v4();
    zodOutbound = custom((x) => x instanceof Uint8Array).or(string2().transform(stringToBytes));
    zodInbound = custom((x) => x instanceof Uint8Array).or(string2().transform(bytesFromBase64));
  }
});

// node_modules/@openrouter/sdk/esm/lib/is-plain-object.js
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
var init_is_plain_object = __esm({
  "node_modules/@openrouter/sdk/esm/lib/is-plain-object.js"() {
  }
});

// node_modules/@openrouter/sdk/esm/lib/encodings.js
function formEncoder(sep) {
  return (key, value, options) => {
    let out = "";
    const pairs = options?.explode ? explode(key, value) : [[key, value]];
    if (pairs.every(([_, v]) => v == null)) {
      return;
    }
    const encodeString = (v) => {
      return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
    };
    const encodeValue = (v) => encodeString(serializeValue(v));
    const encodedSep = encodeString(sep);
    pairs.forEach(([pk, pv]) => {
      let tmp = "";
      let encValue = null;
      if (pv == null) {
        return;
      } else if (Array.isArray(pv)) {
        encValue = mapDefined(pv, (v) => `${encodeValue(v)}`)?.join(encodedSep);
      } else if (isPlainObject2(pv)) {
        encValue = mapDefinedEntries(Object.entries(pv), ([k, v]) => {
          return `${encodeString(k)}${encodedSep}${encodeValue(v)}`;
        })?.join(encodedSep);
      } else {
        encValue = `${encodeValue(pv)}`;
      }
      if (encValue == null) {
        return;
      }
      tmp = `${encodeString(pk)}=${encValue}`;
      if (!tmp || tmp === "=") {
        return;
      }
      out += `&${tmp}`;
    });
    return out.slice(1);
  };
}
function encodeDeepObject(key, value, options) {
  if (value == null) {
    return;
  }
  if (!isPlainObject2(value)) {
    throw new EncodingError(`Value of parameter '${key}' which uses deepObject encoding must be an object or null`);
  }
  return encodeDeepObjectObject(key, value, options);
}
function encodeDeepObjectObject(key, value, options) {
  if (value == null) {
    return;
  }
  let out = "";
  const encodeString = (v) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
  };
  if (!isPlainObject2(value)) {
    throw new EncodingError(`Expected parameter '${key}' to be an object.`);
  }
  Object.entries(value).forEach(([ck, cv]) => {
    if (cv == null) {
      return;
    }
    const pk = `${key}[${ck}]`;
    if (isPlainObject2(cv)) {
      const objOut = encodeDeepObjectObject(pk, cv, options);
      out += objOut == null ? "" : `&${objOut}`;
      return;
    }
    const pairs = Array.isArray(cv) ? cv : [cv];
    const encoded = mapDefined(pairs, (v) => {
      return `${encodeString(pk)}=${encodeString(serializeValue(v))}`;
    })?.join("&");
    out += encoded == null ? "" : `&${encoded}`;
  });
  return out.slice(1);
}
function encodeJSON(key, value, options) {
  if (typeof value === "undefined") {
    return;
  }
  const encodeString = (v) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
  };
  const encVal = encodeString(JSON.stringify(value, jsonReplacer));
  return options?.explode ? encVal : `${encodeString(key)}=${encVal}`;
}
function explode(key, value) {
  if (Array.isArray(value)) {
    return value.map((v) => [key, v]);
  } else if (isPlainObject2(value)) {
    const o = value ?? {};
    return Object.entries(o).map(([k, v]) => [k, v]);
  } else {
    return [[key, value]];
  }
}
function serializeValue(value) {
  if (value == null) {
    return "";
  } else if (value instanceof Date) {
    return value.toISOString();
  } else if (value instanceof Uint8Array) {
    return bytesToBase64(value);
  } else if (typeof value === "object") {
    return JSON.stringify(value, jsonReplacer);
  }
  return `${value}`;
}
function jsonReplacer(_, value) {
  if (value instanceof Uint8Array) {
    return bytesToBase64(value);
  } else {
    return value;
  }
}
function mapDefined(inp, mapper) {
  const res = inp.reduce((acc, v) => {
    if (v == null) {
      return acc;
    }
    const m = mapper(v);
    if (m == null) {
      return acc;
    }
    acc.push(m);
    return acc;
  }, []);
  return res.length ? res : null;
}
function mapDefinedEntries(inp, mapper) {
  const acc = [];
  for (const [k, v] of inp) {
    if (v == null) {
      continue;
    }
    const m = mapper([k, v]);
    if (m == null) {
      continue;
    }
    acc.push(m);
  }
  return acc.length ? acc : null;
}
function queryJoin(...args) {
  return args.filter(Boolean).join("&");
}
function queryEncoder(f) {
  const bulkEncode = function(values, options) {
    const opts = {
      ...options,
      explode: options?.explode ?? true,
      charEncoding: options?.charEncoding ?? "percent"
    };
    const allowEmptySet = new Set(options?.allowEmptyValue ?? []);
    const encoded = Object.entries(values).map(([key, value]) => {
      if (allowEmptySet.has(key)) {
        if (value === void 0 || value === null || value === "" || Array.isArray(value) && value.length === 0) {
          return `${encodeURIComponent(key)}=`;
        }
      }
      return f(key, value, opts);
    });
    return queryJoin(...encoded);
  };
  return bulkEncode;
}
var EncodingError, encodeForm, encodeSpaceDelimited, encodePipeDelimited, encodeSimple, encodeJSONQuery, encodeFormQuery, encodeSpaceDelimitedQuery, encodePipeDelimitedQuery, encodeDeepObjectQuery;
var init_encodings = __esm({
  "node_modules/@openrouter/sdk/esm/lib/encodings.js"() {
    init_base64();
    init_is_plain_object();
    EncodingError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "EncodingError";
      }
    };
    encodeForm = formEncoder(",");
    encodeSpaceDelimited = formEncoder(" ");
    encodePipeDelimited = formEncoder("|");
    encodeSimple = (key, value, options) => {
      let out = "";
      const pairs = options?.explode ? explode(key, value) : [[key, value]];
      if (pairs.every(([_, v]) => v == null)) {
        return;
      }
      const encodeString = (v) => {
        return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
      };
      const encodeValue = (v) => encodeString(serializeValue(v));
      pairs.forEach(([pk, pv]) => {
        let tmp = "";
        if (pv == null) {
          return;
        } else if (Array.isArray(pv)) {
          tmp = mapDefined(pv, (v) => `${encodeValue(v)}`)?.join(",");
        } else if (isPlainObject2(pv)) {
          const mapped = mapDefinedEntries(Object.entries(pv), ([k, v]) => {
            return `,${encodeString(k)},${encodeValue(v)}`;
          });
          tmp = mapped?.join("").slice(1);
        } else {
          const k = options?.explode && isPlainObject2(value) ? `${pk}=` : "";
          tmp = `${k}${encodeValue(pv)}`;
        }
        out += tmp ? `,${tmp}` : "";
      });
      return out.slice(1);
    };
    encodeJSONQuery = queryEncoder(encodeJSON);
    encodeFormQuery = queryEncoder(encodeForm);
    encodeSpaceDelimitedQuery = queryEncoder(encodeSpaceDelimited);
    encodePipeDelimitedQuery = queryEncoder(encodePipeDelimited);
    encodeDeepObjectQuery = queryEncoder(encodeDeepObject);
  }
});

// node_modules/@openrouter/sdk/esm/lib/dlv.js
function dlv(obj, key, def, p, undef) {
  key = Array.isArray(key) ? key : key.split(".");
  for (p = 0; p < key.length; p++) {
    const k = key[p];
    obj = k != null && obj ? obj[k] : undef;
  }
  return obj === undef ? def : obj;
}
var init_dlv = __esm({
  "node_modules/@openrouter/sdk/esm/lib/dlv.js"() {
  }
});

// node_modules/@openrouter/sdk/esm/lib/env.js
function isDeno() {
  if ("Deno" in globalThis) {
    return true;
  }
  return false;
}
function env() {
  if (envMemo) {
    return envMemo;
  }
  let envObject = {};
  if (isDeno()) {
    envObject = globalThis.Deno?.env?.toObject?.() ?? {};
  } else {
    envObject = dlv(globalThis, "process.env") ?? {};
  }
  envMemo = envSchema.parse(envObject);
  return envMemo;
}
function fillGlobals(options) {
  const clone2 = { ...options };
  const envVars = env();
  if (typeof envVars.OPENROUTER_HTTP_REFERER !== "undefined") {
    clone2.httpReferer ?? (clone2.httpReferer = envVars.OPENROUTER_HTTP_REFERER);
  }
  if (typeof envVars.OPENROUTER_X_TITLE !== "undefined") {
    clone2.xTitle ?? (clone2.xTitle = envVars.OPENROUTER_X_TITLE);
  }
  return clone2;
}
var envSchema, envMemo;
var init_env = __esm({
  "node_modules/@openrouter/sdk/esm/lib/env.js"() {
    init_v4();
    init_dlv();
    envSchema = object({
      OPENROUTER_API_KEY: string2().optional(),
      OPENROUTER_HTTP_REFERER: string2().optional(),
      OPENROUTER_X_TITLE: string2().optional(),
      OPENROUTER_DEBUG: coerce_exports.boolean().optional()
    });
    envMemo = void 0;
  }
});

// node_modules/@openrouter/sdk/esm/lib/retries.js
async function retry(fetchFn, options) {
  switch (options.config.strategy) {
    case "backoff":
      return retryBackoff(wrapFetcher(fetchFn, {
        statusCodes: options.statusCodes,
        retryConnectionErrors: !!options.config.retryConnectionErrors
      }), options.config.backoff ?? defaultBackoff);
    default:
      return await fetchFn();
  }
}
function wrapFetcher(fn, options) {
  return async () => {
    try {
      const res = await fn();
      if (isRetryableResponse(res, options.statusCodes)) {
        throw new TemporaryError("Response failed with retryable status code", res);
      }
      return res;
    } catch (err) {
      if (err instanceof TemporaryError) {
        throw err;
      }
      if (options.retryConnectionErrors && (isTimeoutError(err) || isConnectionError(err))) {
        throw err;
      }
      throw new PermanentError("Permanent error", { cause: err });
    }
  };
}
function isRetryableResponse(res, statusCodes) {
  const actual = `${res.status}`;
  return statusCodes.some((code) => {
    if (!codeRangeRE2.test(code)) {
      return code === actual;
    }
    const expectFamily = code.charAt(0);
    if (!expectFamily) {
      throw new Error("Invalid status code range");
    }
    const actualFamily = actual.charAt(0);
    if (!actualFamily) {
      throw new Error(`Invalid response status code: ${actual}`);
    }
    return actualFamily === expectFamily;
  });
}
async function retryBackoff(fn, strategy) {
  const { maxElapsedTime, initialInterval, exponent, maxInterval } = strategy;
  const start = Date.now();
  let x = 0;
  while (true) {
    try {
      const res = await fn();
      return res;
    } catch (err) {
      if (err instanceof PermanentError) {
        throw err.cause;
      }
      const elapsed = Date.now() - start;
      if (elapsed > maxElapsedTime) {
        if (err instanceof TemporaryError) {
          return err.response;
        }
        throw err;
      }
      let retryInterval = 0;
      if (err instanceof TemporaryError) {
        retryInterval = retryIntervalFromResponse(err.response);
      }
      if (retryInterval <= 0) {
        retryInterval = initialInterval * Math.pow(x, exponent) + Math.random() * 1e3;
      }
      const d = Math.min(retryInterval, maxInterval);
      await delay(d);
      x++;
    }
  }
}
function retryIntervalFromResponse(res) {
  const retryVal = res.headers.get("retry-after") || "";
  if (!retryVal) {
    return 0;
  }
  const parsedNumber = Number(retryVal);
  if (Number.isInteger(parsedNumber)) {
    return parsedNumber * 1e3;
  }
  const parsedDate = Date.parse(retryVal);
  if (Number.isInteger(parsedDate)) {
    const deltaMS = parsedDate - Date.now();
    return deltaMS > 0 ? Math.ceil(deltaMS) : 0;
  }
  return 0;
}
async function delay(delay2) {
  return new Promise((resolve) => setTimeout(resolve, delay2));
}
var defaultBackoff, PermanentError, TemporaryError, codeRangeRE2;
var init_retries = __esm({
  "node_modules/@openrouter/sdk/esm/lib/retries.js"() {
    init_http();
    defaultBackoff = {
      initialInterval: 500,
      maxInterval: 6e4,
      exponent: 1.5,
      maxElapsedTime: 36e5
    };
    PermanentError = class _PermanentError extends Error {
      constructor(message, options) {
        let msg = message;
        if (options?.cause) {
          msg += `: ${options.cause}`;
        }
        super(msg, options);
        this.name = "PermanentError";
        if (typeof this.cause === "undefined") {
          this.cause = options?.cause;
        }
        Object.setPrototypeOf(this, _PermanentError.prototype);
      }
    };
    TemporaryError = class _TemporaryError extends Error {
      constructor(message, response) {
        super(message);
        this.response = response;
        this.name = "TemporaryError";
        Object.setPrototypeOf(this, _TemporaryError.prototype);
      }
    };
    codeRangeRE2 = new RegExp("^[0-9]xx$", "i");
  }
});

// node_modules/@openrouter/sdk/esm/lib/sdks.js
async function logRequest(logger2, req) {
  if (!logger2) {
    return;
  }
  const contentType = req.headers.get("content-type");
  const ct = contentType?.split(";")[0] || "";
  logger2.group(`> Request: ${req.method} ${req.url}`);
  logger2.group("Headers:");
  for (const [k, v] of req.headers.entries()) {
    logger2.log(`${k}: ${v}`);
  }
  logger2.groupEnd();
  logger2.group("Body:");
  switch (true) {
    case jsonLikeContentTypeRE.test(ct):
      logger2.log(await req.clone().json());
      break;
    case ct.startsWith("text/"):
      logger2.log(await req.clone().text());
      break;
    case ct === "multipart/form-data": {
      const body = await req.clone().formData();
      for (const [k, v] of body) {
        const vlabel = v instanceof Blob ? "<Blob>" : v;
        logger2.log(`${k}: ${vlabel}`);
      }
      break;
    }
    default:
      logger2.log(`<${contentType}>`);
      break;
  }
  logger2.groupEnd();
  logger2.groupEnd();
}
async function logResponse(logger2, res, req) {
  if (!logger2) {
    return;
  }
  const contentType = res.headers.get("content-type");
  const ct = contentType?.split(";")[0] || "";
  logger2.group(`< Response: ${req.method} ${req.url}`);
  logger2.log("Status Code:", res.status, res.statusText);
  logger2.group("Headers:");
  for (const [k, v] of res.headers.entries()) {
    logger2.log(`${k}: ${v}`);
  }
  logger2.groupEnd();
  logger2.group("Body:");
  switch (true) {
    case (matchContentType(res, "application/json") || jsonLikeContentTypeRE.test(ct) && !jsonlLikeContentTypeRE.test(ct)):
      logger2.log(await res.clone().json());
      break;
    case (matchContentType(res, "application/jsonl") || jsonlLikeContentTypeRE.test(ct)):
      logger2.log(await res.clone().text());
      break;
    case matchContentType(res, "text/event-stream"):
      logger2.log(`<${contentType}>`);
      break;
    case matchContentType(res, "text/*"):
      logger2.log(await res.clone().text());
      break;
    case matchContentType(res, "multipart/form-data"): {
      const body = await res.clone().formData();
      for (const [k, v] of body) {
        const vlabel = v instanceof Blob ? "<Blob>" : v;
        logger2.log(`${k}: ${vlabel}`);
      }
      break;
    }
    default:
      logger2.log(`<${contentType}>`);
      break;
  }
  logger2.groupEnd();
  logger2.groupEnd();
}
var __classPrivateFieldSet, __classPrivateFieldGet, _ClientSDK_instances, _ClientSDK_httpClient, _ClientSDK_hooks, _ClientSDK_logger, _ClientSDK_registerHook, gt, webWorkerLike, isBrowserLike, ClientSDK, jsonLikeContentTypeRE, jsonlLikeContentTypeRE;
var init_sdks = __esm({
  "node_modules/@openrouter/sdk/esm/lib/sdks.js"() {
    init_hooks();
    init_httpclienterrors();
    init_fp();
    init_base64();
    init_config();
    init_encodings();
    init_env();
    init_http();
    init_retries();
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    gt = typeof globalThis === "undefined" ? null : globalThis;
    webWorkerLike = typeof gt === "object" && gt != null && "importScripts" in gt && typeof gt["importScripts"] === "function";
    isBrowserLike = webWorkerLike || typeof navigator !== "undefined" && "serviceWorker" in navigator || typeof window === "object" && typeof window.document !== "undefined";
    ClientSDK = class {
      constructor(options = {}) {
        _ClientSDK_instances.add(this);
        _ClientSDK_httpClient.set(this, void 0);
        _ClientSDK_hooks.set(this, void 0);
        _ClientSDK_logger.set(this, void 0);
        if (options.hooks instanceof SDKHooks) {
          __classPrivateFieldSet(this, _ClientSDK_hooks, options.hooks, "f");
        } else {
          __classPrivateFieldSet(this, _ClientSDK_hooks, new SDKHooks(), "f");
          if (options.hooks) {
            const hooksArray = Array.isArray(options.hooks) ? options.hooks : [options.hooks];
            for (const hook of hooksArray) {
              __classPrivateFieldGet(this, _ClientSDK_instances, "m", _ClientSDK_registerHook).call(this, hook);
            }
          }
        }
        const defaultHttpClient = new HTTPClient();
        options.httpClient = options.httpClient || defaultHttpClient;
        options = __classPrivateFieldGet(this, _ClientSDK_hooks, "f").sdkInit(options);
        const url2 = serverURLFromOptions(options);
        if (url2) {
          url2.pathname = url2.pathname.replace(/\/+$/, "") + "/";
        }
        this._baseURL = url2;
        __classPrivateFieldSet(this, _ClientSDK_httpClient, options.httpClient || defaultHttpClient, "f");
        this._options = { ...fillGlobals(options), hooks: __classPrivateFieldGet(this, _ClientSDK_hooks, "f") };
        __classPrivateFieldSet(this, _ClientSDK_logger, this._options.debugLogger, "f");
        if (!__classPrivateFieldGet(this, _ClientSDK_logger, "f") && env().OPENROUTER_DEBUG) {
          __classPrivateFieldSet(this, _ClientSDK_logger, console, "f");
        }
      }
      _createRequest(context, conf, options) {
        const { method, path: path3, query, headers: opHeaders, security } = conf;
        const base = conf.baseURL ?? this._baseURL;
        if (!base) {
          return ERR(new InvalidRequestError("No base URL provided for operation"));
        }
        const reqURL = new URL(base);
        const inputURL = new URL(path3, reqURL);
        if (path3) {
          reqURL.pathname += reqURL.pathname.endsWith("/") ? "" : "/";
          reqURL.pathname += inputURL.pathname.replace(/^\/+/, "");
        }
        let finalQuery = query || "";
        const secQuery = [];
        for (const [k, v] of Object.entries(security?.queryParams || {})) {
          const q = encodeForm(k, v, { charEncoding: "percent" });
          if (typeof q !== "undefined") {
            secQuery.push(q);
          }
        }
        if (secQuery.length) {
          finalQuery += `&${secQuery.join("&")}`;
        }
        if (finalQuery) {
          const q = finalQuery.startsWith("&") ? finalQuery.slice(1) : finalQuery;
          reqURL.search = `?${q}`;
        }
        const headers = new Headers(opHeaders);
        const username = security?.basic.username;
        const password = security?.basic.password;
        if (username != null || password != null) {
          const encoded = stringToBase64([username || "", password || ""].join(":"));
          headers.set("Authorization", `Basic ${encoded}`);
        }
        const securityHeaders = new Headers(security?.headers || {});
        for (const [k, v] of securityHeaders) {
          headers.set(k, v);
        }
        let cookie = headers.get("cookie") || "";
        for (const [k, v] of Object.entries(security?.cookies || {})) {
          cookie += `; ${k}=${v}`;
        }
        cookie = cookie.startsWith("; ") ? cookie.slice(2) : cookie;
        headers.set("cookie", cookie);
        const userHeaders = new Headers(options?.headers ?? options?.fetchOptions?.headers);
        for (const [k, v] of userHeaders) {
          headers.set(k, v);
        }
        if (!isBrowserLike) {
          headers.set(conf.uaHeader ?? "user-agent", conf.userAgent ?? SDK_METADATA.userAgent);
        }
        const fetchOptions = {
          ...options?.fetchOptions,
          ...options
        };
        if (!fetchOptions?.signal && conf.timeoutMs && conf.timeoutMs > 0) {
          const timeoutSignal = AbortSignal.timeout(conf.timeoutMs);
          fetchOptions.signal = timeoutSignal;
        }
        if (conf.body instanceof ReadableStream) {
          Object.assign(fetchOptions, { duplex: "half" });
        }
        let input;
        try {
          input = __classPrivateFieldGet(this, _ClientSDK_hooks, "f").beforeCreateRequest(context, {
            url: reqURL,
            options: {
              ...fetchOptions,
              body: conf.body ?? null,
              headers,
              method
            }
          });
        } catch (err) {
          return ERR(new UnexpectedClientError("Create request hook failed to execute", {
            cause: err
          }));
        }
        return OK(new Request(input.url, input.options));
      }
      async _do(request, options) {
        const { context, errorCodes } = options;
        return retry(async () => {
          const req = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").beforeRequest(context, request.clone());
          await logRequest(__classPrivateFieldGet(this, _ClientSDK_logger, "f"), req).catch((e) => __classPrivateFieldGet(this, _ClientSDK_logger, "f")?.log("Failed to log request:", e));
          let response = await __classPrivateFieldGet(this, _ClientSDK_httpClient, "f").request(req);
          try {
            if (matchStatusCode(response, errorCodes)) {
              const result = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").afterError(context, response, null);
              if (result.error) {
                throw result.error;
              }
              response = result.response || response;
            } else {
              response = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").afterSuccess(context, response);
            }
          } finally {
            await logResponse(__classPrivateFieldGet(this, _ClientSDK_logger, "f"), response, req).catch((e) => __classPrivateFieldGet(this, _ClientSDK_logger, "f")?.log("Failed to log response:", e));
          }
          return response;
        }, { config: options.retryConfig, statusCodes: options.retryCodes }).then((r) => OK(r), (err) => {
          switch (true) {
            case isAbortError(err):
              return ERR(new RequestAbortedError("Request aborted by client", {
                cause: err
              }));
            case isTimeoutError(err):
              return ERR(new RequestTimeoutError("Request timed out", { cause: err }));
            case isConnectionError(err):
              return ERR(new ConnectionError("Unable to make request", { cause: err }));
            default:
              return ERR(new UnexpectedClientError("Unexpected HTTP client error", {
                cause: err
              }));
          }
        });
      }
    };
    _ClientSDK_httpClient = /* @__PURE__ */ new WeakMap(), _ClientSDK_hooks = /* @__PURE__ */ new WeakMap(), _ClientSDK_logger = /* @__PURE__ */ new WeakMap(), _ClientSDK_instances = /* @__PURE__ */ new WeakSet(), _ClientSDK_registerHook = function _ClientSDK_registerHook2(hook) {
      if ("sdkInit" in hook) {
        __classPrivateFieldGet(this, _ClientSDK_hooks, "f").registerSDKInitHook(hook);
      }
      if ("beforeCreateRequest" in hook) {
        __classPrivateFieldGet(this, _ClientSDK_hooks, "f").registerBeforeCreateRequestHook(hook);
      }
      if ("beforeRequest" in hook) {
        __classPrivateFieldGet(this, _ClientSDK_hooks, "f").registerBeforeRequestHook(hook);
      }
      if ("afterSuccess" in hook) {
        __classPrivateFieldGet(this, _ClientSDK_hooks, "f").registerAfterSuccessHook(hook);
      }
      if ("afterError" in hook) {
        __classPrivateFieldGet(this, _ClientSDK_hooks, "f").registerAfterErrorHook(hook);
      }
    };
    jsonLikeContentTypeRE = /(application|text)\/.*?\+*json.*/;
    jsonlLikeContentTypeRE = /(application|text)\/(.*?\+*\bjsonl\b.*|.*?\+*\bx-ndjson\b.*)/;
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/openroutererror.js
var OpenRouterError;
var init_openroutererror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/openroutererror.js"() {
    OpenRouterError = class extends Error {
      constructor(message, httpMeta) {
        super(message);
        this.statusCode = httpMeta.response.status;
        this.body = httpMeta.body;
        this.headers = httpMeta.response.headers;
        this.contentType = httpMeta.response.headers.get("content-type") || "";
        this.rawResponse = httpMeta.response;
        this.name = "OpenRouterError";
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/openrouterdefaulterror.js
var OpenRouterDefaultError;
var init_openrouterdefaulterror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/openrouterdefaulterror.js"() {
    init_openroutererror();
    OpenRouterDefaultError = class extends OpenRouterError {
      constructor(message, httpMeta) {
        if (message) {
          message += `: `;
        }
        message += `Status ${httpMeta.response.status}`;
        const contentType = httpMeta.response.headers.get("content-type") || `""`;
        if (contentType !== "application/json") {
          message += ` Content-Type ${contentType.includes(" ") ? `"${contentType}"` : contentType}`;
        }
        const body = httpMeta.body || `""`;
        message += body.length > 100 ? "\n" : ". ";
        let bodyDisplay = body;
        if (body.length > 1e4) {
          const truncated = body.substring(0, 1e4);
          const remaining = body.length - 1e4;
          bodyDisplay = `${truncated}...and ${remaining} more chars`;
        }
        message += `Body: ${bodyDisplay}`;
        message = message.trim();
        super(message, httpMeta);
        this.name = "OpenRouterDefaultError";
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/responsevalidationerror.js
var ResponseValidationError;
var init_responsevalidationerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/responsevalidationerror.js"() {
    init_core2();
    init_openroutererror();
    init_sdkvalidationerror();
    ResponseValidationError = class extends OpenRouterError {
      constructor(message, extra) {
        super(message, extra);
        this.name = "ResponseValidationError";
        this.cause = extra.cause;
        this.rawValue = extra.rawValue;
        this.rawMessage = extra.rawMessage;
      }
      /**
       * Return a pretty-formatted error message if the underlying validation error
       * is a ZodError or some other recognized error type, otherwise return the
       * default error message.
       */
      pretty() {
        if (this.cause instanceof $ZodError) {
          return `${this.rawMessage}
${formatZodError(this.cause)}`;
        } else {
          return this.toString();
        }
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/lib/matchers.js
function jsonErr(codes, schema, options) {
  return { ...options, err: true, enc: "json", codes, schema };
}
function json2(codes, schema, options) {
  return { ...options, enc: "json", codes, schema };
}
function text(codes, schema, options) {
  return { ...options, enc: "text", codes, schema };
}
function sse(codes, schema, options) {
  return { ...options, enc: "sse", codes, schema };
}
function fail(codes) {
  return { enc: "fail", codes };
}
function match(...matchers) {
  return async function matchFunc(response, request, options) {
    let raw;
    let matcher;
    for (const match2 of matchers) {
      const { codes } = match2;
      const ctpattern = "ctype" in match2 ? match2.ctype : DEFAULT_CONTENT_TYPES[match2.enc];
      if (ctpattern && matchResponse(response, codes, ctpattern)) {
        matcher = match2;
        break;
      } else if (!ctpattern && matchStatusCode(response, codes)) {
        matcher = match2;
        break;
      }
    }
    if (!matcher) {
      return [{
        ok: false,
        error: new OpenRouterDefaultError("Unexpected Status or Content-Type", {
          response,
          request,
          body: await response.text().catch(() => "")
        })
      }, raw];
    }
    const encoding = matcher.enc;
    let body = "";
    switch (encoding) {
      case "json":
        body = await response.text();
        raw = JSON.parse(body);
        break;
      case "jsonl":
        raw = response.body;
        break;
      case "bytes":
        raw = new Uint8Array(await response.arrayBuffer());
        break;
      case "stream":
        raw = response.body;
        break;
      case "text":
        body = await response.text();
        raw = body;
        break;
      case "sse":
        raw = response.body;
        break;
      case "nil":
        body = await response.text();
        raw = void 0;
        break;
      case "fail":
        body = await response.text();
        raw = body;
        break;
      default:
        encoding;
        throw new Error(`Unsupported response type: ${encoding}`);
    }
    if (matcher.enc === "fail") {
      return [{
        ok: false,
        error: new OpenRouterDefaultError("API error occurred", {
          request,
          response,
          body
        })
      }, raw];
    }
    const resultKey = matcher.key || options?.resultKey;
    let data;
    if ("err" in matcher) {
      data = {
        ...options?.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        ...isPlainObject2(raw) ? raw : null,
        request$: request,
        response$: response,
        body$: body
      };
    } else if (resultKey) {
      data = {
        ...options?.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        [resultKey]: raw
      };
    } else if (matcher.hdrs) {
      data = {
        ...options?.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        ...isPlainObject2(raw) ? raw : null
      };
    } else {
      data = raw;
    }
    if ("err" in matcher) {
      const result = safeParseResponse(data, (v) => matcher.schema.parse(v), "Response validation failed", { request, response, body });
      return [result.ok ? { ok: false, error: result.value } : result, raw];
    } else {
      return [
        safeParseResponse(data, (v) => matcher.schema.parse(v), "Response validation failed", { request, response, body }),
        raw
      ];
    }
  };
}
function unpackHeaders(headers) {
  const out = {};
  for (const [k, v] of headers.entries()) {
    out[k] = v.split(headerValRE);
  }
  return out;
}
function safeParseResponse(rawValue, fn, errorMessage, httpMeta) {
  try {
    return OK(fn(rawValue));
  } catch (err) {
    return ERR(new ResponseValidationError(errorMessage, {
      cause: err,
      rawValue,
      rawMessage: errorMessage,
      ...httpMeta
    }));
  }
}
var DEFAULT_CONTENT_TYPES, headerValRE;
var init_matchers = __esm({
  "node_modules/@openrouter/sdk/esm/lib/matchers.js"() {
    init_openrouterdefaulterror();
    init_responsevalidationerror();
    init_fp();
    init_http();
    init_is_plain_object();
    DEFAULT_CONTENT_TYPES = {
      jsonl: "application/jsonl",
      json: "application/json",
      text: "text/plain",
      bytes: "application/octet-stream",
      stream: "application/octet-stream",
      sse: "text/event-stream",
      nil: "*",
      fail: "*"
    };
    headerValRE = /, */;
  }
});

// node_modules/@openrouter/sdk/esm/lib/security.js
function resolveSecurity(...options) {
  const state = {
    basic: {},
    headers: {},
    queryParams: {},
    cookies: {},
    oauth2: { type: "none" }
  };
  const option = options.find((opts) => {
    return opts.every((o) => {
      if (o.value == null) {
        return false;
      } else if (o.type === "http:basic") {
        return o.value.username != null || o.value.password != null;
      } else if (o.type === "http:custom") {
        return null;
      } else if (o.type === "oauth2:password") {
        return typeof o.value === "string" && !!o.value;
      } else if (o.type === "oauth2:client_credentials") {
        if (typeof o.value == "string") {
          return !!o.value;
        }
        return o.value.clientID != null || o.value.clientSecret != null;
      } else if (typeof o.value === "string") {
        return !!o.value;
      } else {
        throw new Error(`Unrecognized security type: ${o.type} (value type: ${typeof o.value})`);
      }
    });
  });
  if (option == null) {
    return null;
  }
  option.forEach((spec) => {
    if (spec.value == null) {
      return;
    }
    const { type } = spec;
    switch (type) {
      case "apiKey:header":
        state.headers[spec.fieldName] = spec.value;
        break;
      case "apiKey:query":
        state.queryParams[spec.fieldName] = spec.value;
        break;
      case "apiKey:cookie":
        state.cookies[spec.fieldName] = spec.value;
        break;
      case "http:basic":
        applyBasic(state, spec);
        break;
      case "http:custom":
        break;
      case "http:bearer":
        applyBearer(state, spec);
        break;
      case "oauth2":
        applyBearer(state, spec);
        break;
      case "oauth2:password":
        applyBearer(state, spec);
        break;
      case "oauth2:client_credentials":
        break;
      case "openIdConnect":
        applyBearer(state, spec);
        break;
      default:
        spec;
        throw SecurityError.unrecognizedType(type);
    }
  });
  return state;
}
function applyBasic(state, spec) {
  if (spec.value == null) {
    return;
  }
  state.basic = spec.value;
}
function applyBearer(state, spec) {
  if (typeof spec.value !== "string" || !spec.value) {
    return;
  }
  let value = spec.value;
  if (value.slice(0, 7).toLowerCase() !== "bearer ") {
    value = `Bearer ${value}`;
  }
  if (spec.fieldName !== void 0) {
    state.headers[spec.fieldName] = value;
  }
}
function resolveGlobalSecurity(security) {
  return resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.apiKey ?? env().OPENROUTER_API_KEY
    }
  ]);
}
async function extractSecurity(sec) {
  if (sec == null) {
    return;
  }
  return typeof sec === "function" ? sec() : sec;
}
var SecurityErrorCode, SecurityError;
var init_security2 = __esm({
  "node_modules/@openrouter/sdk/esm/lib/security.js"() {
    init_env();
    (function(SecurityErrorCode2) {
      SecurityErrorCode2["Incomplete"] = "incomplete";
      SecurityErrorCode2["UnrecognisedSecurityType"] = "unrecognized_security_type";
    })(SecurityErrorCode || (SecurityErrorCode = {}));
    SecurityError = class _SecurityError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        this.name = "SecurityError";
      }
      static incomplete() {
        return new _SecurityError(SecurityErrorCode.Incomplete, "Security requirements not met in order to perform the operation");
      }
      static unrecognizedType(type) {
        return new _SecurityError(SecurityErrorCode.UnrecognisedSecurityType, `Unrecognised security type: ${type}`);
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/badgatewayresponseerror.js
var BadGatewayResponseError, BadGatewayResponseError$inboundSchema;
var init_badgatewayresponseerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/badgatewayresponseerror.js"() {
    init_v4();
    init_primitives();
    init_models();
    init_openroutererror();
    BadGatewayResponseError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        if (err.userId != null)
          this.userId = err.userId;
        this.name = "BadGatewayResponseError";
      }
    };
    BadGatewayResponseError$inboundSchema = object({
      error: BadGatewayResponseErrorData$inboundSchema,
      user_id: nullable(string2()).optional(),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      const remapped = remap(v, {
        "user_id": "userId"
      });
      return new BadGatewayResponseError(remapped, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/badrequestresponseerror.js
var BadRequestResponseError, BadRequestResponseError$inboundSchema;
var init_badrequestresponseerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/badrequestresponseerror.js"() {
    init_v4();
    init_primitives();
    init_models();
    init_openroutererror();
    BadRequestResponseError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        if (err.userId != null)
          this.userId = err.userId;
        this.name = "BadRequestResponseError";
      }
    };
    BadRequestResponseError$inboundSchema = object({
      error: BadRequestResponseErrorData$inboundSchema,
      user_id: nullable(string2()).optional(),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      const remapped = remap(v, {
        "user_id": "userId"
      });
      return new BadRequestResponseError(remapped, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/chaterror.js
var ChatError, ChatError$inboundSchema;
var init_chaterror2 = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/chaterror.js"() {
    init_v4();
    init_models();
    init_openroutererror();
    ChatError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        this.name = "ChatError";
      }
    };
    ChatError$inboundSchema = object({
      error: lazy(() => ChatErrorError$inboundSchema),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      return new ChatError(v, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/edgenetworktimeoutresponseerror.js
var EdgeNetworkTimeoutResponseError, EdgeNetworkTimeoutResponseError$inboundSchema;
var init_edgenetworktimeoutresponseerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/edgenetworktimeoutresponseerror.js"() {
    init_v4();
    init_primitives();
    init_models();
    init_openroutererror();
    EdgeNetworkTimeoutResponseError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        if (err.userId != null)
          this.userId = err.userId;
        this.name = "EdgeNetworkTimeoutResponseError";
      }
    };
    EdgeNetworkTimeoutResponseError$inboundSchema = object({
      error: EdgeNetworkTimeoutResponseErrorData$inboundSchema,
      user_id: nullable(string2()).optional(),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      const remapped = remap(v, {
        "user_id": "userId"
      });
      return new EdgeNetworkTimeoutResponseError(remapped, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/forbiddenresponseerror.js
var ForbiddenResponseError, ForbiddenResponseError$inboundSchema;
var init_forbiddenresponseerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/forbiddenresponseerror.js"() {
    init_v4();
    init_primitives();
    init_models();
    init_openroutererror();
    ForbiddenResponseError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        if (err.userId != null)
          this.userId = err.userId;
        this.name = "ForbiddenResponseError";
      }
    };
    ForbiddenResponseError$inboundSchema = object({
      error: ForbiddenResponseErrorData$inboundSchema,
      user_id: nullable(string2()).optional(),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      const remapped = remap(v, {
        "user_id": "userId"
      });
      return new ForbiddenResponseError(remapped, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/internalserverresponseerror.js
var InternalServerResponseError, InternalServerResponseError$inboundSchema;
var init_internalserverresponseerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/internalserverresponseerror.js"() {
    init_v4();
    init_primitives();
    init_models();
    init_openroutererror();
    InternalServerResponseError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        if (err.userId != null)
          this.userId = err.userId;
        this.name = "InternalServerResponseError";
      }
    };
    InternalServerResponseError$inboundSchema = object({
      error: InternalServerResponseErrorData$inboundSchema,
      user_id: nullable(string2()).optional(),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      const remapped = remap(v, {
        "user_id": "userId"
      });
      return new InternalServerResponseError(remapped, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/notfoundresponseerror.js
var NotFoundResponseError, NotFoundResponseError$inboundSchema;
var init_notfoundresponseerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/notfoundresponseerror.js"() {
    init_v4();
    init_primitives();
    init_models();
    init_openroutererror();
    NotFoundResponseError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        if (err.userId != null)
          this.userId = err.userId;
        this.name = "NotFoundResponseError";
      }
    };
    NotFoundResponseError$inboundSchema = object({
      error: NotFoundResponseErrorData$inboundSchema,
      user_id: nullable(string2()).optional(),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      const remapped = remap(v, {
        "user_id": "userId"
      });
      return new NotFoundResponseError(remapped, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/payloadtoolargeresponseerror.js
var PayloadTooLargeResponseError, PayloadTooLargeResponseError$inboundSchema;
var init_payloadtoolargeresponseerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/payloadtoolargeresponseerror.js"() {
    init_v4();
    init_primitives();
    init_models();
    init_openroutererror();
    PayloadTooLargeResponseError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        if (err.userId != null)
          this.userId = err.userId;
        this.name = "PayloadTooLargeResponseError";
      }
    };
    PayloadTooLargeResponseError$inboundSchema = object({
      error: PayloadTooLargeResponseErrorData$inboundSchema,
      user_id: nullable(string2()).optional(),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      const remapped = remap(v, {
        "user_id": "userId"
      });
      return new PayloadTooLargeResponseError(remapped, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/paymentrequiredresponseerror.js
var PaymentRequiredResponseError, PaymentRequiredResponseError$inboundSchema;
var init_paymentrequiredresponseerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/paymentrequiredresponseerror.js"() {
    init_v4();
    init_primitives();
    init_models();
    init_openroutererror();
    PaymentRequiredResponseError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        if (err.userId != null)
          this.userId = err.userId;
        this.name = "PaymentRequiredResponseError";
      }
    };
    PaymentRequiredResponseError$inboundSchema = object({
      error: PaymentRequiredResponseErrorData$inboundSchema,
      user_id: nullable(string2()).optional(),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      const remapped = remap(v, {
        "user_id": "userId"
      });
      return new PaymentRequiredResponseError(remapped, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/provideroverloadedresponseerror.js
var ProviderOverloadedResponseError, ProviderOverloadedResponseError$inboundSchema;
var init_provideroverloadedresponseerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/provideroverloadedresponseerror.js"() {
    init_v4();
    init_primitives();
    init_models();
    init_openroutererror();
    ProviderOverloadedResponseError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        if (err.userId != null)
          this.userId = err.userId;
        this.name = "ProviderOverloadedResponseError";
      }
    };
    ProviderOverloadedResponseError$inboundSchema = object({
      error: ProviderOverloadedResponseErrorData$inboundSchema,
      user_id: nullable(string2()).optional(),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      const remapped = remap(v, {
        "user_id": "userId"
      });
      return new ProviderOverloadedResponseError(remapped, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/requesttimeoutresponseerror.js
var RequestTimeoutResponseError, RequestTimeoutResponseError$inboundSchema;
var init_requesttimeoutresponseerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/requesttimeoutresponseerror.js"() {
    init_v4();
    init_primitives();
    init_models();
    init_openroutererror();
    RequestTimeoutResponseError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        if (err.userId != null)
          this.userId = err.userId;
        this.name = "RequestTimeoutResponseError";
      }
    };
    RequestTimeoutResponseError$inboundSchema = object({
      error: RequestTimeoutResponseErrorData$inboundSchema,
      user_id: nullable(string2()).optional(),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      const remapped = remap(v, {
        "user_id": "userId"
      });
      return new RequestTimeoutResponseError(remapped, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/serviceunavailableresponseerror.js
var ServiceUnavailableResponseError, ServiceUnavailableResponseError$inboundSchema;
var init_serviceunavailableresponseerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/serviceunavailableresponseerror.js"() {
    init_v4();
    init_primitives();
    init_models();
    init_openroutererror();
    ServiceUnavailableResponseError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        if (err.userId != null)
          this.userId = err.userId;
        this.name = "ServiceUnavailableResponseError";
      }
    };
    ServiceUnavailableResponseError$inboundSchema = object({
      error: ServiceUnavailableResponseErrorData$inboundSchema,
      user_id: nullable(string2()).optional(),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      const remapped = remap(v, {
        "user_id": "userId"
      });
      return new ServiceUnavailableResponseError(remapped, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/toomanyrequestsresponseerror.js
var TooManyRequestsResponseError, TooManyRequestsResponseError$inboundSchema;
var init_toomanyrequestsresponseerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/toomanyrequestsresponseerror.js"() {
    init_v4();
    init_primitives();
    init_models();
    init_openroutererror();
    TooManyRequestsResponseError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        if (err.userId != null)
          this.userId = err.userId;
        this.name = "TooManyRequestsResponseError";
      }
    };
    TooManyRequestsResponseError$inboundSchema = object({
      error: TooManyRequestsResponseErrorData$inboundSchema,
      user_id: nullable(string2()).optional(),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      const remapped = remap(v, {
        "user_id": "userId"
      });
      return new TooManyRequestsResponseError(remapped, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/unauthorizedresponseerror.js
var UnauthorizedResponseError, UnauthorizedResponseError$inboundSchema;
var init_unauthorizedresponseerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/unauthorizedresponseerror.js"() {
    init_v4();
    init_primitives();
    init_models();
    init_openroutererror();
    UnauthorizedResponseError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        if (err.userId != null)
          this.userId = err.userId;
        this.name = "UnauthorizedResponseError";
      }
    };
    UnauthorizedResponseError$inboundSchema = object({
      error: UnauthorizedResponseErrorData$inboundSchema,
      user_id: nullable(string2()).optional(),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      const remapped = remap(v, {
        "user_id": "userId"
      });
      return new UnauthorizedResponseError(remapped, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/unprocessableentityresponseerror.js
var UnprocessableEntityResponseError, UnprocessableEntityResponseError$inboundSchema;
var init_unprocessableentityresponseerror = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/unprocessableentityresponseerror.js"() {
    init_v4();
    init_primitives();
    init_models();
    init_openroutererror();
    UnprocessableEntityResponseError = class extends OpenRouterError {
      constructor(err, httpMeta) {
        const message = err.error?.message || `API error occurred: ${JSON.stringify(err)}`;
        super(message, httpMeta);
        this.data$ = err;
        this.error = err.error;
        if (err.userId != null)
          this.userId = err.userId;
        this.name = "UnprocessableEntityResponseError";
      }
    };
    UnprocessableEntityResponseError$inboundSchema = object({
      error: UnprocessableEntityResponseErrorData$inboundSchema,
      user_id: nullable(string2()).optional(),
      request$: custom((x) => x instanceof Request),
      response$: custom((x) => x instanceof Response),
      body$: string2()
    }).transform((v) => {
      const remapped = remap(v, {
        "user_id": "userId"
      });
      return new UnprocessableEntityResponseError(remapped, {
        request: v.request$,
        response: v.response$,
        body: v.body$
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/errors/index.js
var init_errors3 = __esm({
  "node_modules/@openrouter/sdk/esm/models/errors/index.js"() {
    init_badgatewayresponseerror();
    init_badrequestresponseerror();
    init_chaterror2();
    init_edgenetworktimeoutresponseerror();
    init_forbiddenresponseerror();
    init_httpclienterrors();
    init_internalserverresponseerror();
    init_notfoundresponseerror();
    init_openrouterdefaulterror();
    init_openroutererror();
    init_payloadtoolargeresponseerror();
    init_paymentrequiredresponseerror();
    init_provideroverloadedresponseerror();
    init_requesttimeoutresponseerror();
    init_responsevalidationerror();
    init_sdkvalidationerror();
    init_serviceunavailableresponseerror();
    init_toomanyrequestsresponseerror();
    init_unauthorizedresponseerror();
    init_unprocessableentityresponseerror();
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/bulkassignkeystoguardrail.js
var BulkAssignKeysToGuardrailRequestBody$outboundSchema, BulkAssignKeysToGuardrailRequest$outboundSchema, BulkAssignKeysToGuardrailResponse$inboundSchema;
var init_bulkassignkeystoguardrail = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/bulkassignkeystoguardrail.js"() {
    init_v4();
    init_primitives();
    BulkAssignKeysToGuardrailRequestBody$outboundSchema = object({
      keyHashes: array(string2())
    }).transform((v) => {
      return remap(v, {
        keyHashes: "key_hashes"
      });
    });
    BulkAssignKeysToGuardrailRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      id: string2(),
      requestBody: lazy(() => BulkAssignKeysToGuardrailRequestBody$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        requestBody: "RequestBody"
      });
    });
    BulkAssignKeysToGuardrailResponse$inboundSchema = object({
      assigned_count: number2()
    }).transform((v) => {
      return remap(v, {
        "assigned_count": "assignedCount"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/bulkassignmemberstoguardrail.js
var BulkAssignMembersToGuardrailRequestBody$outboundSchema, BulkAssignMembersToGuardrailRequest$outboundSchema, BulkAssignMembersToGuardrailResponse$inboundSchema;
var init_bulkassignmemberstoguardrail = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/bulkassignmemberstoguardrail.js"() {
    init_v4();
    init_primitives();
    BulkAssignMembersToGuardrailRequestBody$outboundSchema = object({
      memberUserIds: array(string2())
    }).transform((v) => {
      return remap(v, {
        memberUserIds: "member_user_ids"
      });
    });
    BulkAssignMembersToGuardrailRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      id: string2(),
      requestBody: lazy(() => BulkAssignMembersToGuardrailRequestBody$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        requestBody: "RequestBody"
      });
    });
    BulkAssignMembersToGuardrailResponse$inboundSchema = object({
      assigned_count: number2()
    }).transform((v) => {
      return remap(v, {
        "assigned_count": "assignedCount"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/bulkunassignkeysfromguardrail.js
var BulkUnassignKeysFromGuardrailRequestBody$outboundSchema, BulkUnassignKeysFromGuardrailRequest$outboundSchema, BulkUnassignKeysFromGuardrailResponse$inboundSchema;
var init_bulkunassignkeysfromguardrail = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/bulkunassignkeysfromguardrail.js"() {
    init_v4();
    init_primitives();
    BulkUnassignKeysFromGuardrailRequestBody$outboundSchema = object({
      keyHashes: array(string2())
    }).transform((v) => {
      return remap(v, {
        keyHashes: "key_hashes"
      });
    });
    BulkUnassignKeysFromGuardrailRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      id: string2(),
      requestBody: lazy(() => BulkUnassignKeysFromGuardrailRequestBody$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        requestBody: "RequestBody"
      });
    });
    BulkUnassignKeysFromGuardrailResponse$inboundSchema = object({
      unassigned_count: number2()
    }).transform((v) => {
      return remap(v, {
        "unassigned_count": "unassignedCount"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/bulkunassignmembersfromguardrail.js
var BulkUnassignMembersFromGuardrailRequestBody$outboundSchema, BulkUnassignMembersFromGuardrailRequest$outboundSchema, BulkUnassignMembersFromGuardrailResponse$inboundSchema;
var init_bulkunassignmembersfromguardrail = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/bulkunassignmembersfromguardrail.js"() {
    init_v4();
    init_primitives();
    BulkUnassignMembersFromGuardrailRequestBody$outboundSchema = object({
      memberUserIds: array(string2())
    }).transform((v) => {
      return remap(v, {
        memberUserIds: "member_user_ids"
      });
    });
    BulkUnassignMembersFromGuardrailRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      id: string2(),
      requestBody: lazy(() => BulkUnassignMembersFromGuardrailRequestBody$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        requestBody: "RequestBody"
      });
    });
    BulkUnassignMembersFromGuardrailResponse$inboundSchema = object({
      unassigned_count: number2()
    }).transform((v) => {
      return remap(v, {
        "unassigned_count": "unassignedCount"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/createauthkeyscode.js
var CreateAuthKeysCodeCodeChallengeMethod, CreateAuthKeysCodeCodeChallengeMethod$outboundSchema, CreateAuthKeysCodeRequestBody$outboundSchema, CreateAuthKeysCodeRequest$outboundSchema, CreateAuthKeysCodeData$inboundSchema, CreateAuthKeysCodeResponse$inboundSchema;
var init_createauthkeyscode = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/createauthkeyscode.js"() {
    init_v4();
    init_primitives();
    init_enums();
    CreateAuthKeysCodeCodeChallengeMethod = {
      S256: "S256",
      Plain: "plain"
    };
    CreateAuthKeysCodeCodeChallengeMethod$outboundSchema = outboundSchema(CreateAuthKeysCodeCodeChallengeMethod);
    CreateAuthKeysCodeRequestBody$outboundSchema = object({
      callbackUrl: string2(),
      codeChallenge: string2().optional(),
      codeChallengeMethod: CreateAuthKeysCodeCodeChallengeMethod$outboundSchema.optional(),
      limit: number2().optional(),
      expiresAt: nullable(date3().transform((v) => v.toISOString())).optional()
    }).transform((v) => {
      return remap(v, {
        callbackUrl: "callback_url",
        codeChallenge: "code_challenge",
        codeChallengeMethod: "code_challenge_method",
        expiresAt: "expires_at"
      });
    });
    CreateAuthKeysCodeRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      requestBody: lazy(() => CreateAuthKeysCodeRequestBody$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        requestBody: "RequestBody"
      });
    });
    CreateAuthKeysCodeData$inboundSchema = object({
      id: string2(),
      app_id: number2(),
      created_at: string2()
    }).transform((v) => {
      return remap(v, {
        "app_id": "appId",
        "created_at": "createdAt"
      });
    });
    CreateAuthKeysCodeResponse$inboundSchema = object({
      data: lazy(() => CreateAuthKeysCodeData$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/createcoinbasecharge.js
var CreateCoinbaseChargeSecurity$outboundSchema, CreateCoinbaseChargeRequest$outboundSchema, CallData$inboundSchema, Metadata$inboundSchema, TransferIntent$inboundSchema, Web3Data$inboundSchema, CreateCoinbaseChargeData$inboundSchema, CreateCoinbaseChargeResponse$inboundSchema;
var init_createcoinbasecharge = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/createcoinbasecharge.js"() {
    init_v4();
    init_primitives();
    init_models();
    CreateCoinbaseChargeSecurity$outboundSchema = object({
      bearer: string2()
    });
    CreateCoinbaseChargeRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      createChargeRequest: CreateChargeRequest$outboundSchema
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        createChargeRequest: "CreateChargeRequest"
      });
    });
    CallData$inboundSchema = object({
      deadline: string2(),
      fee_amount: string2(),
      id: string2(),
      operator: string2(),
      prefix: string2(),
      recipient: string2(),
      recipient_amount: string2(),
      recipient_currency: string2(),
      refund_destination: string2(),
      signature: string2()
    }).transform((v) => {
      return remap(v, {
        "fee_amount": "feeAmount",
        "recipient_amount": "recipientAmount",
        "recipient_currency": "recipientCurrency",
        "refund_destination": "refundDestination"
      });
    });
    Metadata$inboundSchema = object({
      chain_id: number2(),
      contract_address: string2(),
      sender: string2()
    }).transform((v) => {
      return remap(v, {
        "chain_id": "chainId",
        "contract_address": "contractAddress"
      });
    });
    TransferIntent$inboundSchema = object({
      call_data: lazy(() => CallData$inboundSchema),
      metadata: lazy(() => Metadata$inboundSchema)
    }).transform((v) => {
      return remap(v, {
        "call_data": "callData"
      });
    });
    Web3Data$inboundSchema = object({
      transfer_intent: lazy(() => TransferIntent$inboundSchema)
    }).transform((v) => {
      return remap(v, {
        "transfer_intent": "transferIntent"
      });
    });
    CreateCoinbaseChargeData$inboundSchema = object({
      id: string2(),
      created_at: string2(),
      expires_at: string2(),
      web3_data: lazy(() => Web3Data$inboundSchema)
    }).transform((v) => {
      return remap(v, {
        "created_at": "createdAt",
        "expires_at": "expiresAt",
        "web3_data": "web3Data"
      });
    });
    CreateCoinbaseChargeResponse$inboundSchema = object({
      data: lazy(() => CreateCoinbaseChargeData$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/createembeddings.js
var EncodingFormat, ObjectT2, ObjectEmbedding, ImageUrl$outboundSchema, ContentImageURL$outboundSchema, ContentText$outboundSchema, Content$outboundSchema, Input$outboundSchema, InputUnion$outboundSchema, EncodingFormat$outboundSchema, CreateEmbeddingsRequestBody$outboundSchema, CreateEmbeddingsRequest$outboundSchema, ObjectT$inboundSchema2, ObjectEmbedding$inboundSchema, Embedding$inboundSchema, CreateEmbeddingsData$inboundSchema, Usage$inboundSchema, CreateEmbeddingsResponseBody$inboundSchema, CreateEmbeddingsResponse$inboundSchema;
var init_createembeddings = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/createembeddings.js"() {
    init_v4();
    init_primitives();
    init_enums();
    init_models();
    EncodingFormat = {
      Float: "float",
      Base64: "base64"
    };
    ObjectT2 = {
      List: "list"
    };
    ObjectEmbedding = {
      Embedding: "embedding"
    };
    ImageUrl$outboundSchema = object({
      url: string2()
    });
    ContentImageURL$outboundSchema = object({
      type: literal("image_url"),
      imageUrl: lazy(() => ImageUrl$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        imageUrl: "image_url"
      });
    });
    ContentText$outboundSchema = object({
      type: literal("text"),
      text: string2()
    });
    Content$outboundSchema = union([
      lazy(() => ContentText$outboundSchema),
      lazy(() => ContentImageURL$outboundSchema)
    ]);
    Input$outboundSchema = object({
      content: array(union([
        lazy(() => ContentText$outboundSchema),
        lazy(() => ContentImageURL$outboundSchema)
      ]))
    });
    InputUnion$outboundSchema = union([
      string2(),
      array(string2()),
      array(number2()),
      array(array(number2())),
      array(lazy(() => Input$outboundSchema))
    ]);
    EncodingFormat$outboundSchema = outboundSchema(EncodingFormat);
    CreateEmbeddingsRequestBody$outboundSchema = object({
      input: union([
        string2(),
        array(string2()),
        array(number2()),
        array(array(number2())),
        array(lazy(() => Input$outboundSchema))
      ]),
      model: string2(),
      encodingFormat: EncodingFormat$outboundSchema.optional(),
      dimensions: int().optional(),
      user: string2().optional(),
      provider: ProviderPreferences$outboundSchema.optional(),
      inputType: string2().optional()
    }).transform((v) => {
      return remap(v, {
        encodingFormat: "encoding_format",
        inputType: "input_type"
      });
    });
    CreateEmbeddingsRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      requestBody: lazy(() => CreateEmbeddingsRequestBody$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        requestBody: "RequestBody"
      });
    });
    ObjectT$inboundSchema2 = _enum2(ObjectT2);
    ObjectEmbedding$inboundSchema = _enum2(ObjectEmbedding);
    Embedding$inboundSchema = union([
      array(number2()),
      string2()
    ]);
    CreateEmbeddingsData$inboundSchema = object({
      object: ObjectEmbedding$inboundSchema,
      embedding: union([array(number2()), string2()]),
      index: number2().optional()
    });
    Usage$inboundSchema = object({
      prompt_tokens: number2(),
      total_tokens: number2(),
      cost: number2().optional()
    }).transform((v) => {
      return remap(v, {
        "prompt_tokens": "promptTokens",
        "total_tokens": "totalTokens"
      });
    });
    CreateEmbeddingsResponseBody$inboundSchema = object({
      id: string2().optional(),
      object: ObjectT$inboundSchema2,
      data: array(lazy(() => CreateEmbeddingsData$inboundSchema)),
      model: string2(),
      usage: lazy(() => Usage$inboundSchema).optional()
    });
    CreateEmbeddingsResponse$inboundSchema = union([
      lazy(() => CreateEmbeddingsResponseBody$inboundSchema),
      string2()
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/createguardrail.js
var CreateGuardrailResetIntervalRequest, CreateGuardrailResetIntervalResponse, CreateGuardrailResetIntervalRequest$outboundSchema, CreateGuardrailRequestBody$outboundSchema, CreateGuardrailRequest$outboundSchema, CreateGuardrailResetIntervalResponse$inboundSchema, CreateGuardrailData$inboundSchema, CreateGuardrailResponse$inboundSchema;
var init_createguardrail = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/createguardrail.js"() {
    init_v4();
    init_primitives();
    init_enums();
    CreateGuardrailResetIntervalRequest = {
      Daily: "daily",
      Weekly: "weekly",
      Monthly: "monthly"
    };
    CreateGuardrailResetIntervalResponse = {
      Daily: "daily",
      Weekly: "weekly",
      Monthly: "monthly"
    };
    CreateGuardrailResetIntervalRequest$outboundSchema = outboundSchema(CreateGuardrailResetIntervalRequest);
    CreateGuardrailRequestBody$outboundSchema = object({
      name: string2(),
      description: nullable(string2()).optional(),
      limitUsd: nullable(number2()).optional(),
      resetInterval: nullable(CreateGuardrailResetIntervalRequest$outboundSchema).optional(),
      allowedProviders: nullable(array(string2())).optional(),
      allowedModels: nullable(array(string2())).optional(),
      enforceZdr: nullable(boolean2()).optional()
    }).transform((v) => {
      return remap(v, {
        limitUsd: "limit_usd",
        resetInterval: "reset_interval",
        allowedProviders: "allowed_providers",
        allowedModels: "allowed_models",
        enforceZdr: "enforce_zdr"
      });
    });
    CreateGuardrailRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      requestBody: lazy(() => CreateGuardrailRequestBody$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        requestBody: "RequestBody"
      });
    });
    CreateGuardrailResetIntervalResponse$inboundSchema = inboundSchema(CreateGuardrailResetIntervalResponse);
    CreateGuardrailData$inboundSchema = object({
      id: string2(),
      name: string2(),
      description: nullable(string2()).optional(),
      limit_usd: nullable(number2()).optional(),
      reset_interval: nullable(CreateGuardrailResetIntervalResponse$inboundSchema).optional(),
      allowed_providers: nullable(array(string2())).optional(),
      allowed_models: nullable(array(string2())).optional(),
      enforce_zdr: nullable(boolean2()).optional(),
      created_at: string2(),
      updated_at: nullable(string2()).optional()
    }).transform((v) => {
      return remap(v, {
        "limit_usd": "limitUsd",
        "reset_interval": "resetInterval",
        "allowed_providers": "allowedProviders",
        "allowed_models": "allowedModels",
        "enforce_zdr": "enforceZdr",
        "created_at": "createdAt",
        "updated_at": "updatedAt"
      });
    });
    CreateGuardrailResponse$inboundSchema = object({
      data: lazy(() => CreateGuardrailData$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/createkeys.js
var CreateKeysLimitReset, CreateKeysLimitReset$outboundSchema, CreateKeysRequestBody$outboundSchema, CreateKeysRequest$outboundSchema, CreateKeysData$inboundSchema, CreateKeysResponse$inboundSchema;
var init_createkeys = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/createkeys.js"() {
    init_v4();
    init_primitives();
    init_enums();
    CreateKeysLimitReset = {
      Daily: "daily",
      Weekly: "weekly",
      Monthly: "monthly"
    };
    CreateKeysLimitReset$outboundSchema = outboundSchema(CreateKeysLimitReset);
    CreateKeysRequestBody$outboundSchema = object({
      name: string2(),
      limit: nullable(number2()).optional(),
      limitReset: nullable(CreateKeysLimitReset$outboundSchema).optional(),
      includeByokInLimit: boolean2().optional(),
      expiresAt: nullable(date3().transform((v) => v.toISOString())).optional()
    }).transform((v) => {
      return remap(v, {
        limitReset: "limit_reset",
        includeByokInLimit: "include_byok_in_limit",
        expiresAt: "expires_at"
      });
    });
    CreateKeysRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      requestBody: lazy(() => CreateKeysRequestBody$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        requestBody: "RequestBody"
      });
    });
    CreateKeysData$inboundSchema = object({
      hash: string2(),
      name: string2(),
      label: string2(),
      disabled: boolean2(),
      limit: nullable(number2()),
      limit_remaining: nullable(number2()),
      limit_reset: nullable(string2()),
      include_byok_in_limit: boolean2(),
      usage: number2(),
      usage_daily: number2(),
      usage_weekly: number2(),
      usage_monthly: number2(),
      byok_usage: number2(),
      byok_usage_daily: number2(),
      byok_usage_weekly: number2(),
      byok_usage_monthly: number2(),
      created_at: string2(),
      updated_at: nullable(string2()),
      expires_at: nullable(iso_exports.datetime({ offset: true }).transform((v) => new Date(v))).optional()
    }).transform((v) => {
      return remap(v, {
        "limit_remaining": "limitRemaining",
        "limit_reset": "limitReset",
        "include_byok_in_limit": "includeByokInLimit",
        "usage_daily": "usageDaily",
        "usage_weekly": "usageWeekly",
        "usage_monthly": "usageMonthly",
        "byok_usage": "byokUsage",
        "byok_usage_daily": "byokUsageDaily",
        "byok_usage_weekly": "byokUsageWeekly",
        "byok_usage_monthly": "byokUsageMonthly",
        "created_at": "createdAt",
        "updated_at": "updatedAt",
        "expires_at": "expiresAt"
      });
    });
    CreateKeysResponse$inboundSchema = object({
      data: lazy(() => CreateKeysData$inboundSchema),
      key: string2()
    });
  }
});

// node_modules/@openrouter/sdk/esm/lib/event-streams.js
function concatBuffer(a, b) {
  const c = new Uint8Array(a.length + b.length);
  c.set(a, 0);
  c.set(b, a.length);
  return c;
}
function findBoundary(buf) {
  const len = buf.length;
  for (let i = 0; i < len; i++) {
    if (i <= len - 4 && buf[i] === 13 && buf[i + 1] === 10 && buf[i + 2] === 13 && buf[i + 3] === 10) {
      return { index: i, length: 4 };
    }
    if (i <= len - 2 && buf[i] === 13 && buf[i + 1] === 13) {
      return { index: i, length: 2 };
    }
    if (i <= len - 2 && buf[i] === 10 && buf[i + 1] === 10) {
      return { index: i, length: 2 };
    }
  }
  return null;
}
function parseMessage(chunk, parse3) {
  const text2 = new TextDecoder().decode(chunk);
  const lines = text2.split(/\r\n|\r|\n/);
  const dataLines = [];
  const ret = {};
  let ignore = true;
  for (const line of lines) {
    if (!line || line.startsWith(":"))
      continue;
    ignore = false;
    const i = line.indexOf(":");
    const field = line.slice(0, i);
    const value = line[i + 1] === " " ? line.slice(i + 2) : line.slice(i + 1);
    if (field === "data")
      dataLines.push(value);
    else if (field === "event")
      ret.event = value;
    else if (field === "id")
      ret.id = value;
    else if (field === "retry") {
      const n = Number(value);
      if (!isNaN(n))
        ret.retry = n;
    }
  }
  if (ignore)
    return;
  if (dataLines.length)
    ret.data = dataLines.join("\n");
  return parse3(ret);
}
var EventStream;
var init_event_streams = __esm({
  "node_modules/@openrouter/sdk/esm/lib/event-streams.js"() {
    EventStream = class extends ReadableStream {
      constructor(responseBody, parse3) {
        const upstream = responseBody.getReader();
        let buffer = new Uint8Array();
        super({
          async pull(downstream) {
            try {
              while (true) {
                const match2 = findBoundary(buffer);
                if (!match2) {
                  const chunk = await upstream.read();
                  if (chunk.done)
                    return downstream.close();
                  buffer = concatBuffer(buffer, chunk.value);
                  continue;
                }
                const message = buffer.slice(0, match2.index);
                buffer = buffer.slice(match2.index + match2.length);
                const item = parseMessage(message, parse3);
                if (item && !item.done)
                  return downstream.enqueue(item.value);
                if (item?.done) {
                  await upstream.cancel("done");
                  return downstream.close();
                }
              }
            } catch (e) {
              downstream.error(e);
              await upstream.cancel(e);
            }
          },
          cancel: (reason) => upstream.cancel(reason)
        });
      }
      // Polyfill for older browsers
      [Symbol.asyncIterator]() {
        const fn = ReadableStream.prototype[Symbol.asyncIterator];
        if (typeof fn === "function")
          return fn.call(this);
        const reader = this.getReader();
        return {
          next: async () => {
            const r = await reader.read();
            if (r.done) {
              reader.releaseLock();
              return { done: true, value: void 0 };
            }
            return { done: false, value: r.value };
          },
          throw: async (e) => {
            await reader.cancel(e);
            reader.releaseLock();
            return { done: true, value: void 0 };
          },
          return: async () => {
            await reader.cancel("done");
            reader.releaseLock();
            return { done: true, value: void 0 };
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/createresponses.js
var CreateResponsesRequest$outboundSchema, CreateResponsesResponseBody$inboundSchema, CreateResponsesResponse$inboundSchema;
var init_createresponses = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/createresponses.js"() {
    init_v4();
    init_event_streams();
    init_primitives();
    init_models();
    CreateResponsesRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      openResponsesRequest: OpenResponsesRequest$outboundSchema
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        openResponsesRequest: "OpenResponsesRequest"
      });
    });
    CreateResponsesResponseBody$inboundSchema = object({
      data: string2().transform((v, ctx) => {
        try {
          return JSON.parse(v);
        } catch (err) {
          ctx.addIssue({
            input: v,
            code: "custom",
            message: `malformed json: ${err}`
          });
          return NEVER;
        }
      }).pipe(OpenResponsesStreamEvent$inboundSchema)
    });
    CreateResponsesResponse$inboundSchema = union([
      OpenResponsesNonStreamingResponse$inboundSchema,
      custom((x) => x instanceof ReadableStream).transform((stream) => {
        return new EventStream(stream, (rawEvent) => {
          if (rawEvent.data === "[DONE]")
            return { done: true };
          return {
            value: lazy(() => CreateResponsesResponseBody$inboundSchema).parse(rawEvent)?.data
          };
        });
      })
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/deleteguardrail.js
var DeleteGuardrailRequest$outboundSchema, DeleteGuardrailResponse$inboundSchema;
var init_deleteguardrail = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/deleteguardrail.js"() {
    init_v4();
    init_primitives();
    DeleteGuardrailRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      id: string2()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    DeleteGuardrailResponse$inboundSchema = object({
      deleted: literal(true)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/deletekeys.js
var DeleteKeysRequest$outboundSchema, DeleteKeysResponse$inboundSchema;
var init_deletekeys = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/deletekeys.js"() {
    init_v4();
    init_primitives();
    DeleteKeysRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      hash: string2()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    DeleteKeysResponse$inboundSchema = object({
      deleted: literal(true)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/exchangeauthcodeforapikey.js
var ExchangeAuthCodeForAPIKeyCodeChallengeMethod, ExchangeAuthCodeForAPIKeyCodeChallengeMethod$outboundSchema, ExchangeAuthCodeForAPIKeyRequestBody$outboundSchema, ExchangeAuthCodeForAPIKeyRequest$outboundSchema, ExchangeAuthCodeForAPIKeyResponse$inboundSchema;
var init_exchangeauthcodeforapikey = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/exchangeauthcodeforapikey.js"() {
    init_v4();
    init_primitives();
    init_enums();
    ExchangeAuthCodeForAPIKeyCodeChallengeMethod = {
      S256: "S256",
      Plain: "plain"
    };
    ExchangeAuthCodeForAPIKeyCodeChallengeMethod$outboundSchema = outboundSchema(ExchangeAuthCodeForAPIKeyCodeChallengeMethod);
    ExchangeAuthCodeForAPIKeyRequestBody$outboundSchema = object({
      code: string2(),
      codeVerifier: string2().optional(),
      codeChallengeMethod: nullable(ExchangeAuthCodeForAPIKeyCodeChallengeMethod$outboundSchema).optional()
    }).transform((v) => {
      return remap(v, {
        codeVerifier: "code_verifier",
        codeChallengeMethod: "code_challenge_method"
      });
    });
    ExchangeAuthCodeForAPIKeyRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      requestBody: lazy(() => ExchangeAuthCodeForAPIKeyRequestBody$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        requestBody: "RequestBody"
      });
    });
    ExchangeAuthCodeForAPIKeyResponse$inboundSchema = object({
      key: string2(),
      user_id: nullable(string2())
    }).transform((v) => {
      return remap(v, {
        "user_id": "userId"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/getcredits.js
var GetCreditsRequest$outboundSchema, GetCreditsData$inboundSchema, GetCreditsResponse$inboundSchema;
var init_getcredits = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/getcredits.js"() {
    init_v4();
    init_primitives();
    GetCreditsRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    GetCreditsData$inboundSchema = object({
      total_credits: number2(),
      total_usage: number2()
    }).transform((v) => {
      return remap(v, {
        "total_credits": "totalCredits",
        "total_usage": "totalUsage"
      });
    });
    GetCreditsResponse$inboundSchema = object({
      data: lazy(() => GetCreditsData$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/getcurrentkey.js
var GetCurrentKeyRequest$outboundSchema, RateLimit$inboundSchema, GetCurrentKeyData$inboundSchema, GetCurrentKeyResponse$inboundSchema;
var init_getcurrentkey = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/getcurrentkey.js"() {
    init_v4();
    init_primitives();
    GetCurrentKeyRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    RateLimit$inboundSchema = object({
      requests: number2(),
      interval: string2(),
      note: string2()
    });
    GetCurrentKeyData$inboundSchema = object({
      label: string2(),
      limit: nullable(number2()),
      usage: number2(),
      usage_daily: number2(),
      usage_weekly: number2(),
      usage_monthly: number2(),
      byok_usage: number2(),
      byok_usage_daily: number2(),
      byok_usage_weekly: number2(),
      byok_usage_monthly: number2(),
      is_free_tier: boolean2(),
      is_management_key: boolean2(),
      is_provisioning_key: boolean2(),
      limit_remaining: nullable(number2()),
      limit_reset: nullable(string2()),
      include_byok_in_limit: boolean2(),
      expires_at: nullable(iso_exports.datetime({ offset: true }).transform((v) => new Date(v))).optional(),
      rate_limit: lazy(() => RateLimit$inboundSchema)
    }).transform((v) => {
      return remap(v, {
        "usage_daily": "usageDaily",
        "usage_weekly": "usageWeekly",
        "usage_monthly": "usageMonthly",
        "byok_usage": "byokUsage",
        "byok_usage_daily": "byokUsageDaily",
        "byok_usage_weekly": "byokUsageWeekly",
        "byok_usage_monthly": "byokUsageMonthly",
        "is_free_tier": "isFreeTier",
        "is_management_key": "isManagementKey",
        "is_provisioning_key": "isProvisioningKey",
        "limit_remaining": "limitRemaining",
        "limit_reset": "limitReset",
        "include_byok_in_limit": "includeByokInLimit",
        "expires_at": "expiresAt",
        "rate_limit": "rateLimit"
      });
    });
    GetCurrentKeyResponse$inboundSchema = object({
      data: lazy(() => GetCurrentKeyData$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/getgeneration.js
var ApiType, ProviderName2, GetGenerationRequest$outboundSchema, ApiType$inboundSchema, ProviderName$inboundSchema2, ProviderResponse$inboundSchema, GetGenerationData$inboundSchema, GetGenerationResponse$inboundSchema;
var init_getgeneration = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/getgeneration.js"() {
    init_v4();
    init_primitives();
    init_enums();
    ApiType = {
      Completions: "completions",
      Embeddings: "embeddings"
    };
    ProviderName2 = {
      AnyScale: "AnyScale",
      Atoma: "Atoma",
      CentML: "Cent-ML",
      CrofAI: "CrofAI",
      Enfer: "Enfer",
      GoPomelo: "GoPomelo",
      HuggingFace: "HuggingFace",
      Hyperbolic2: "Hyperbolic 2",
      InoCloud: "InoCloud",
      Kluster: "Kluster",
      Lambda: "Lambda",
      Lepton: "Lepton",
      Lynn2: "Lynn 2",
      Lynn: "Lynn",
      Mancer: "Mancer",
      Meta: "Meta",
      Modal: "Modal",
      Nineteen: "Nineteen",
      OctoAI: "OctoAI",
      Recursal: "Recursal",
      Reflection: "Reflection",
      Replicate: "Replicate",
      SambaNova2: "SambaNova 2",
      SFCompute: "SF Compute",
      Targon: "Targon",
      Together2: "Together 2",
      Ubicloud: "Ubicloud",
      OneDotAI: "01.AI",
      Ai21: "AI21",
      AionLabs: "AionLabs",
      Alibaba: "Alibaba",
      Ambient: "Ambient",
      AmazonBedrock: "Amazon Bedrock",
      AmazonNova: "Amazon Nova",
      Anthropic: "Anthropic",
      ArceeAI: "Arcee AI",
      AtlasCloud: "AtlasCloud",
      Avian: "Avian",
      Azure: "Azure",
      BaseTen: "BaseTen",
      BytePlus: "BytePlus",
      BlackForestLabs: "Black Forest Labs",
      Cerebras: "Cerebras",
      Chutes: "Chutes",
      Cirrascale: "Cirrascale",
      Clarifai: "Clarifai",
      Cloudflare: "Cloudflare",
      Cohere: "Cohere",
      Crusoe: "Crusoe",
      DeepInfra: "DeepInfra",
      DeepSeek: "DeepSeek",
      Featherless: "Featherless",
      Fireworks: "Fireworks",
      Friendli: "Friendli",
      GMICloud: "GMICloud",
      Google: "Google",
      GoogleAIStudio: "Google AI Studio",
      Groq: "Groq",
      Hyperbolic: "Hyperbolic",
      Inception: "Inception",
      Inceptron: "Inceptron",
      InferenceNet: "InferenceNet",
      Infermatic: "Infermatic",
      Inflection: "Inflection",
      Liquid: "Liquid",
      Mara: "Mara",
      Mancer2: "Mancer 2",
      Minimax: "Minimax",
      ModelRun: "ModelRun",
      Mistral: "Mistral",
      Modular: "Modular",
      MoonshotAI: "Moonshot AI",
      Morph: "Morph",
      NCompass: "NCompass",
      Nebius: "Nebius",
      NextBit: "NextBit",
      Novita: "Novita",
      Nvidia: "Nvidia",
      OpenAI: "OpenAI",
      OpenInference: "OpenInference",
      Parasail: "Parasail",
      Perplexity: "Perplexity",
      Phala: "Phala",
      Relace: "Relace",
      SambaNova: "SambaNova",
      Seed: "Seed",
      SiliconFlow: "SiliconFlow",
      Sourceful: "Sourceful",
      StepFun: "StepFun",
      Stealth: "Stealth",
      StreamLake: "StreamLake",
      Switchpoint: "Switchpoint",
      Together: "Together",
      Upstage: "Upstage",
      Venice: "Venice",
      WandB: "WandB",
      Xiaomi: "Xiaomi",
      XAI: "xAI",
      ZAi: "Z.AI",
      FakeProvider: "FakeProvider"
    };
    GetGenerationRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      id: string2()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    ApiType$inboundSchema = inboundSchema(ApiType);
    ProviderName$inboundSchema2 = inboundSchema(ProviderName2);
    ProviderResponse$inboundSchema = object({
      id: string2().optional(),
      endpoint_id: string2().optional(),
      model_permaslug: string2().optional(),
      provider_name: ProviderName$inboundSchema2.optional(),
      status: nullable(number2()),
      latency: number2().optional(),
      is_byok: boolean2().optional()
    }).transform((v) => {
      return remap(v, {
        "endpoint_id": "endpointId",
        "model_permaslug": "modelPermaslug",
        "provider_name": "providerName",
        "is_byok": "isByok"
      });
    });
    GetGenerationData$inboundSchema = object({
      id: string2(),
      upstream_id: nullable(string2()),
      total_cost: number2(),
      cache_discount: nullable(number2()),
      upstream_inference_cost: nullable(number2()),
      created_at: string2(),
      model: string2(),
      app_id: nullable(number2()),
      streamed: nullable(boolean2()),
      cancelled: nullable(boolean2()),
      provider_name: nullable(string2()),
      latency: nullable(number2()),
      moderation_latency: nullable(number2()),
      generation_time: nullable(number2()),
      finish_reason: nullable(string2()),
      tokens_prompt: nullable(number2()),
      tokens_completion: nullable(number2()),
      native_tokens_prompt: nullable(number2()),
      native_tokens_completion: nullable(number2()),
      native_tokens_completion_images: nullable(number2()),
      native_tokens_reasoning: nullable(number2()),
      native_tokens_cached: nullable(number2()),
      num_media_prompt: nullable(number2()),
      num_input_audio_prompt: nullable(number2()),
      num_media_completion: nullable(number2()),
      num_search_results: nullable(number2()),
      origin: string2(),
      usage: number2(),
      is_byok: boolean2(),
      native_finish_reason: nullable(string2()),
      external_user: nullable(string2()),
      api_type: nullable(ApiType$inboundSchema),
      router: nullable(string2()),
      provider_responses: nullable(array(lazy(() => ProviderResponse$inboundSchema)))
    }).transform((v) => {
      return remap(v, {
        "upstream_id": "upstreamId",
        "total_cost": "totalCost",
        "cache_discount": "cacheDiscount",
        "upstream_inference_cost": "upstreamInferenceCost",
        "created_at": "createdAt",
        "app_id": "appId",
        "provider_name": "providerName",
        "moderation_latency": "moderationLatency",
        "generation_time": "generationTime",
        "finish_reason": "finishReason",
        "tokens_prompt": "tokensPrompt",
        "tokens_completion": "tokensCompletion",
        "native_tokens_prompt": "nativeTokensPrompt",
        "native_tokens_completion": "nativeTokensCompletion",
        "native_tokens_completion_images": "nativeTokensCompletionImages",
        "native_tokens_reasoning": "nativeTokensReasoning",
        "native_tokens_cached": "nativeTokensCached",
        "num_media_prompt": "numMediaPrompt",
        "num_input_audio_prompt": "numInputAudioPrompt",
        "num_media_completion": "numMediaCompletion",
        "num_search_results": "numSearchResults",
        "is_byok": "isByok",
        "native_finish_reason": "nativeFinishReason",
        "external_user": "externalUser",
        "api_type": "apiType",
        "provider_responses": "providerResponses"
      });
    });
    GetGenerationResponse$inboundSchema = object({
      data: lazy(() => GetGenerationData$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/getguardrail.js
var GetGuardrailResetInterval, GetGuardrailRequest$outboundSchema, GetGuardrailResetInterval$inboundSchema, GetGuardrailData$inboundSchema, GetGuardrailResponse$inboundSchema;
var init_getguardrail = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/getguardrail.js"() {
    init_v4();
    init_primitives();
    init_enums();
    GetGuardrailResetInterval = {
      Daily: "daily",
      Weekly: "weekly",
      Monthly: "monthly"
    };
    GetGuardrailRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      id: string2()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    GetGuardrailResetInterval$inboundSchema = inboundSchema(GetGuardrailResetInterval);
    GetGuardrailData$inboundSchema = object({
      id: string2(),
      name: string2(),
      description: nullable(string2()).optional(),
      limit_usd: nullable(number2()).optional(),
      reset_interval: nullable(GetGuardrailResetInterval$inboundSchema).optional(),
      allowed_providers: nullable(array(string2())).optional(),
      allowed_models: nullable(array(string2())).optional(),
      enforce_zdr: nullable(boolean2()).optional(),
      created_at: string2(),
      updated_at: nullable(string2()).optional()
    }).transform((v) => {
      return remap(v, {
        "limit_usd": "limitUsd",
        "reset_interval": "resetInterval",
        "allowed_providers": "allowedProviders",
        "allowed_models": "allowedModels",
        "enforce_zdr": "enforceZdr",
        "created_at": "createdAt",
        "updated_at": "updatedAt"
      });
    });
    GetGuardrailResponse$inboundSchema = object({
      data: lazy(() => GetGuardrailData$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/getkey.js
var GetKeyRequest$outboundSchema, GetKeyData$inboundSchema, GetKeyResponse$inboundSchema;
var init_getkey = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/getkey.js"() {
    init_v4();
    init_primitives();
    GetKeyRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      hash: string2()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    GetKeyData$inboundSchema = object({
      hash: string2(),
      name: string2(),
      label: string2(),
      disabled: boolean2(),
      limit: nullable(number2()),
      limit_remaining: nullable(number2()),
      limit_reset: nullable(string2()),
      include_byok_in_limit: boolean2(),
      usage: number2(),
      usage_daily: number2(),
      usage_weekly: number2(),
      usage_monthly: number2(),
      byok_usage: number2(),
      byok_usage_daily: number2(),
      byok_usage_weekly: number2(),
      byok_usage_monthly: number2(),
      created_at: string2(),
      updated_at: nullable(string2()),
      expires_at: nullable(iso_exports.datetime({ offset: true }).transform((v) => new Date(v))).optional()
    }).transform((v) => {
      return remap(v, {
        "limit_remaining": "limitRemaining",
        "limit_reset": "limitReset",
        "include_byok_in_limit": "includeByokInLimit",
        "usage_daily": "usageDaily",
        "usage_weekly": "usageWeekly",
        "usage_monthly": "usageMonthly",
        "byok_usage": "byokUsage",
        "byok_usage_daily": "byokUsageDaily",
        "byok_usage_weekly": "byokUsageWeekly",
        "byok_usage_monthly": "byokUsageMonthly",
        "created_at": "createdAt",
        "updated_at": "updatedAt",
        "expires_at": "expiresAt"
      });
    });
    GetKeyResponse$inboundSchema = object({
      data: lazy(() => GetKeyData$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/getmodels.js
var Category, Category$outboundSchema, GetModelsRequest$outboundSchema;
var init_getmodels = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/getmodels.js"() {
    init_v4();
    init_primitives();
    init_enums();
    Category = {
      Programming: "programming",
      Roleplay: "roleplay",
      Marketing: "marketing",
      MarketingSeo: "marketing/seo",
      Technology: "technology",
      Science: "science",
      Translation: "translation",
      Legal: "legal",
      Finance: "finance",
      Health: "health",
      Trivia: "trivia",
      Academia: "academia"
    };
    Category$outboundSchema = outboundSchema(Category);
    GetModelsRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      category: Category$outboundSchema.optional(),
      supportedParameters: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        supportedParameters: "supported_parameters"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/getuseractivity.js
var GetUserActivityRequest$outboundSchema, GetUserActivityResponse$inboundSchema;
var init_getuseractivity = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/getuseractivity.js"() {
    init_v4();
    init_primitives();
    init_models();
    GetUserActivityRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      date: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    GetUserActivityResponse$inboundSchema = object({
      data: array(ActivityItem$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/list.js
var ListRequest$outboundSchema, ListData$inboundSchema, ListResponse$inboundSchema;
var init_list = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/list.js"() {
    init_v4();
    init_primitives();
    ListRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      includeDisabled: string2().optional(),
      offset: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        includeDisabled: "include_disabled"
      });
    });
    ListData$inboundSchema = object({
      hash: string2(),
      name: string2(),
      label: string2(),
      disabled: boolean2(),
      limit: nullable(number2()),
      limit_remaining: nullable(number2()),
      limit_reset: nullable(string2()),
      include_byok_in_limit: boolean2(),
      usage: number2(),
      usage_daily: number2(),
      usage_weekly: number2(),
      usage_monthly: number2(),
      byok_usage: number2(),
      byok_usage_daily: number2(),
      byok_usage_weekly: number2(),
      byok_usage_monthly: number2(),
      created_at: string2(),
      updated_at: nullable(string2()),
      expires_at: nullable(iso_exports.datetime({ offset: true }).transform((v) => new Date(v))).optional()
    }).transform((v) => {
      return remap(v, {
        "limit_remaining": "limitRemaining",
        "limit_reset": "limitReset",
        "include_byok_in_limit": "includeByokInLimit",
        "usage_daily": "usageDaily",
        "usage_weekly": "usageWeekly",
        "usage_monthly": "usageMonthly",
        "byok_usage": "byokUsage",
        "byok_usage_daily": "byokUsageDaily",
        "byok_usage_weekly": "byokUsageWeekly",
        "byok_usage_monthly": "byokUsageMonthly",
        "created_at": "createdAt",
        "updated_at": "updatedAt",
        "expires_at": "expiresAt"
      });
    });
    ListResponse$inboundSchema = object({
      data: array(lazy(() => ListData$inboundSchema))
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/listembeddingsmodels.js
var ListEmbeddingsModelsRequest$outboundSchema;
var init_listembeddingsmodels = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/listembeddingsmodels.js"() {
    init_v4();
    init_primitives();
    ListEmbeddingsModelsRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/listendpoints.js
var ListEndpointsRequest$outboundSchema, ListEndpointsResponse$inboundSchema2;
var init_listendpoints = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/listendpoints.js"() {
    init_v4();
    init_primitives();
    init_models();
    ListEndpointsRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      author: string2(),
      slug: string2()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    ListEndpointsResponse$inboundSchema2 = object({
      data: ListEndpointsResponse$inboundSchema
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/listendpointszdr.js
var ListEndpointsZdrRequest$outboundSchema, ListEndpointsZdrResponse$inboundSchema;
var init_listendpointszdr = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/listendpointszdr.js"() {
    init_v4();
    init_primitives();
    init_models();
    ListEndpointsZdrRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    ListEndpointsZdrResponse$inboundSchema = object({
      data: array(PublicEndpoint$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/listguardrailkeyassignments.js
var ListGuardrailKeyAssignmentsRequest$outboundSchema, ListGuardrailKeyAssignmentsData$inboundSchema, ListGuardrailKeyAssignmentsResponse$inboundSchema;
var init_listguardrailkeyassignments = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/listguardrailkeyassignments.js"() {
    init_v4();
    init_primitives();
    ListGuardrailKeyAssignmentsRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      id: string2(),
      offset: string2().optional(),
      limit: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    ListGuardrailKeyAssignmentsData$inboundSchema = object({
      id: string2(),
      key_hash: string2(),
      guardrail_id: string2(),
      key_name: string2(),
      key_label: string2(),
      assigned_by: nullable(string2()),
      created_at: string2()
    }).transform((v) => {
      return remap(v, {
        "key_hash": "keyHash",
        "guardrail_id": "guardrailId",
        "key_name": "keyName",
        "key_label": "keyLabel",
        "assigned_by": "assignedBy",
        "created_at": "createdAt"
      });
    });
    ListGuardrailKeyAssignmentsResponse$inboundSchema = object({
      data: array(lazy(() => ListGuardrailKeyAssignmentsData$inboundSchema)),
      total_count: number2()
    }).transform((v) => {
      return remap(v, {
        "total_count": "totalCount"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/listguardrailmemberassignments.js
var ListGuardrailMemberAssignmentsRequest$outboundSchema, ListGuardrailMemberAssignmentsData$inboundSchema, ListGuardrailMemberAssignmentsResponse$inboundSchema;
var init_listguardrailmemberassignments = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/listguardrailmemberassignments.js"() {
    init_v4();
    init_primitives();
    ListGuardrailMemberAssignmentsRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      id: string2(),
      offset: string2().optional(),
      limit: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    ListGuardrailMemberAssignmentsData$inboundSchema = object({
      id: string2(),
      user_id: string2(),
      organization_id: string2(),
      guardrail_id: string2(),
      assigned_by: nullable(string2()),
      created_at: string2()
    }).transform((v) => {
      return remap(v, {
        "user_id": "userId",
        "organization_id": "organizationId",
        "guardrail_id": "guardrailId",
        "assigned_by": "assignedBy",
        "created_at": "createdAt"
      });
    });
    ListGuardrailMemberAssignmentsResponse$inboundSchema = object({
      data: array(lazy(() => ListGuardrailMemberAssignmentsData$inboundSchema)),
      total_count: number2()
    }).transform((v) => {
      return remap(v, {
        "total_count": "totalCount"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/listguardrails.js
var ListGuardrailsResetInterval, ListGuardrailsRequest$outboundSchema, ListGuardrailsResetInterval$inboundSchema, ListGuardrailsData$inboundSchema, ListGuardrailsResponse$inboundSchema;
var init_listguardrails = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/listguardrails.js"() {
    init_v4();
    init_primitives();
    init_enums();
    ListGuardrailsResetInterval = {
      Daily: "daily",
      Weekly: "weekly",
      Monthly: "monthly"
    };
    ListGuardrailsRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      offset: string2().optional(),
      limit: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    ListGuardrailsResetInterval$inboundSchema = inboundSchema(ListGuardrailsResetInterval);
    ListGuardrailsData$inboundSchema = object({
      id: string2(),
      name: string2(),
      description: nullable(string2()).optional(),
      limit_usd: nullable(number2()).optional(),
      reset_interval: nullable(ListGuardrailsResetInterval$inboundSchema).optional(),
      allowed_providers: nullable(array(string2())).optional(),
      allowed_models: nullable(array(string2())).optional(),
      enforce_zdr: nullable(boolean2()).optional(),
      created_at: string2(),
      updated_at: nullable(string2()).optional()
    }).transform((v) => {
      return remap(v, {
        "limit_usd": "limitUsd",
        "reset_interval": "resetInterval",
        "allowed_providers": "allowedProviders",
        "allowed_models": "allowedModels",
        "enforce_zdr": "enforceZdr",
        "created_at": "createdAt",
        "updated_at": "updatedAt"
      });
    });
    ListGuardrailsResponse$inboundSchema = object({
      data: array(lazy(() => ListGuardrailsData$inboundSchema)),
      total_count: number2()
    }).transform((v) => {
      return remap(v, {
        "total_count": "totalCount"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/listkeyassignments.js
var ListKeyAssignmentsRequest$outboundSchema, ListKeyAssignmentsData$inboundSchema, ListKeyAssignmentsResponse$inboundSchema;
var init_listkeyassignments = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/listkeyassignments.js"() {
    init_v4();
    init_primitives();
    ListKeyAssignmentsRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      offset: string2().optional(),
      limit: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    ListKeyAssignmentsData$inboundSchema = object({
      id: string2(),
      key_hash: string2(),
      guardrail_id: string2(),
      key_name: string2(),
      key_label: string2(),
      assigned_by: nullable(string2()),
      created_at: string2()
    }).transform((v) => {
      return remap(v, {
        "key_hash": "keyHash",
        "guardrail_id": "guardrailId",
        "key_name": "keyName",
        "key_label": "keyLabel",
        "assigned_by": "assignedBy",
        "created_at": "createdAt"
      });
    });
    ListKeyAssignmentsResponse$inboundSchema = object({
      data: array(lazy(() => ListKeyAssignmentsData$inboundSchema)),
      total_count: number2()
    }).transform((v) => {
      return remap(v, {
        "total_count": "totalCount"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/listmemberassignments.js
var ListMemberAssignmentsRequest$outboundSchema, ListMemberAssignmentsData$inboundSchema, ListMemberAssignmentsResponse$inboundSchema;
var init_listmemberassignments = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/listmemberassignments.js"() {
    init_v4();
    init_primitives();
    ListMemberAssignmentsRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      offset: string2().optional(),
      limit: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    ListMemberAssignmentsData$inboundSchema = object({
      id: string2(),
      user_id: string2(),
      organization_id: string2(),
      guardrail_id: string2(),
      assigned_by: nullable(string2()),
      created_at: string2()
    }).transform((v) => {
      return remap(v, {
        "user_id": "userId",
        "organization_id": "organizationId",
        "guardrail_id": "guardrailId",
        "assigned_by": "assignedBy",
        "created_at": "createdAt"
      });
    });
    ListMemberAssignmentsResponse$inboundSchema = object({
      data: array(lazy(() => ListMemberAssignmentsData$inboundSchema)),
      total_count: number2()
    }).transform((v) => {
      return remap(v, {
        "total_count": "totalCount"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/listmodelscount.js
var ListModelsCountRequest$outboundSchema;
var init_listmodelscount = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/listmodelscount.js"() {
    init_v4();
    init_primitives();
    ListModelsCountRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/listmodelsuser.js
var ListModelsUserSecurity$outboundSchema, ListModelsUserRequest$outboundSchema;
var init_listmodelsuser = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/listmodelsuser.js"() {
    init_v4();
    init_primitives();
    ListModelsUserSecurity$outboundSchema = object({
      bearer: string2()
    });
    ListModelsUserRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/listproviders.js
var ListProvidersRequest$outboundSchema, ListProvidersData$inboundSchema, ListProvidersResponse$inboundSchema;
var init_listproviders = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/listproviders.js"() {
    init_v4();
    init_primitives();
    ListProvidersRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional()
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title"
      });
    });
    ListProvidersData$inboundSchema = object({
      name: string2(),
      slug: string2(),
      privacy_policy_url: nullable(string2()),
      terms_of_service_url: nullable(string2()).optional(),
      status_page_url: nullable(string2()).optional()
    }).transform((v) => {
      return remap(v, {
        "privacy_policy_url": "privacyPolicyUrl",
        "terms_of_service_url": "termsOfServiceUrl",
        "status_page_url": "statusPageUrl"
      });
    });
    ListProvidersResponse$inboundSchema = object({
      data: array(lazy(() => ListProvidersData$inboundSchema))
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/sendchatcompletionrequest.js
var SendChatCompletionRequestRequest$outboundSchema, SendChatCompletionRequestResponse$inboundSchema;
var init_sendchatcompletionrequest = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/sendchatcompletionrequest.js"() {
    init_v4();
    init_event_streams();
    init_primitives();
    init_models();
    SendChatCompletionRequestRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      chatGenerationParams: ChatGenerationParams$outboundSchema
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        chatGenerationParams: "ChatGenerationParams"
      });
    });
    SendChatCompletionRequestResponse$inboundSchema = union([
      ChatResponse$inboundSchema,
      custom((x) => x instanceof ReadableStream).transform((stream) => {
        return new EventStream(stream, (rawEvent) => {
          if (rawEvent.data === "[DONE]")
            return { done: true };
          return {
            value: ChatStreamingResponseChunk$inboundSchema.parse(rawEvent)?.data
          };
        });
      })
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/updateguardrail.js
var UpdateGuardrailResetIntervalRequest, UpdateGuardrailResetIntervalResponse, UpdateGuardrailResetIntervalRequest$outboundSchema, UpdateGuardrailRequestBody$outboundSchema, UpdateGuardrailRequest$outboundSchema, UpdateGuardrailResetIntervalResponse$inboundSchema, UpdateGuardrailData$inboundSchema, UpdateGuardrailResponse$inboundSchema;
var init_updateguardrail = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/updateguardrail.js"() {
    init_v4();
    init_primitives();
    init_enums();
    UpdateGuardrailResetIntervalRequest = {
      Daily: "daily",
      Weekly: "weekly",
      Monthly: "monthly"
    };
    UpdateGuardrailResetIntervalResponse = {
      Daily: "daily",
      Weekly: "weekly",
      Monthly: "monthly"
    };
    UpdateGuardrailResetIntervalRequest$outboundSchema = outboundSchema(UpdateGuardrailResetIntervalRequest);
    UpdateGuardrailRequestBody$outboundSchema = object({
      name: string2().optional(),
      description: nullable(string2()).optional(),
      limitUsd: nullable(number2()).optional(),
      resetInterval: nullable(UpdateGuardrailResetIntervalRequest$outboundSchema).optional(),
      allowedProviders: nullable(array(string2())).optional(),
      allowedModels: nullable(array(string2())).optional(),
      enforceZdr: nullable(boolean2()).optional()
    }).transform((v) => {
      return remap(v, {
        limitUsd: "limit_usd",
        resetInterval: "reset_interval",
        allowedProviders: "allowed_providers",
        allowedModels: "allowed_models",
        enforceZdr: "enforce_zdr"
      });
    });
    UpdateGuardrailRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      id: string2(),
      requestBody: lazy(() => UpdateGuardrailRequestBody$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        requestBody: "RequestBody"
      });
    });
    UpdateGuardrailResetIntervalResponse$inboundSchema = inboundSchema(UpdateGuardrailResetIntervalResponse);
    UpdateGuardrailData$inboundSchema = object({
      id: string2(),
      name: string2(),
      description: nullable(string2()).optional(),
      limit_usd: nullable(number2()).optional(),
      reset_interval: nullable(UpdateGuardrailResetIntervalResponse$inboundSchema).optional(),
      allowed_providers: nullable(array(string2())).optional(),
      allowed_models: nullable(array(string2())).optional(),
      enforce_zdr: nullable(boolean2()).optional(),
      created_at: string2(),
      updated_at: nullable(string2()).optional()
    }).transform((v) => {
      return remap(v, {
        "limit_usd": "limitUsd",
        "reset_interval": "resetInterval",
        "allowed_providers": "allowedProviders",
        "allowed_models": "allowedModels",
        "enforce_zdr": "enforceZdr",
        "created_at": "createdAt",
        "updated_at": "updatedAt"
      });
    });
    UpdateGuardrailResponse$inboundSchema = object({
      data: lazy(() => UpdateGuardrailData$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/updatekeys.js
var UpdateKeysLimitReset, UpdateKeysLimitReset$outboundSchema, UpdateKeysRequestBody$outboundSchema, UpdateKeysRequest$outboundSchema, UpdateKeysData$inboundSchema, UpdateKeysResponse$inboundSchema;
var init_updatekeys = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/updatekeys.js"() {
    init_v4();
    init_primitives();
    init_enums();
    UpdateKeysLimitReset = {
      Daily: "daily",
      Weekly: "weekly",
      Monthly: "monthly"
    };
    UpdateKeysLimitReset$outboundSchema = outboundSchema(UpdateKeysLimitReset);
    UpdateKeysRequestBody$outboundSchema = object({
      name: string2().optional(),
      disabled: boolean2().optional(),
      limit: nullable(number2()).optional(),
      limitReset: nullable(UpdateKeysLimitReset$outboundSchema).optional(),
      includeByokInLimit: boolean2().optional()
    }).transform((v) => {
      return remap(v, {
        limitReset: "limit_reset",
        includeByokInLimit: "include_byok_in_limit"
      });
    });
    UpdateKeysRequest$outboundSchema = object({
      httpReferer: string2().optional(),
      xTitle: string2().optional(),
      hash: string2(),
      requestBody: lazy(() => UpdateKeysRequestBody$outboundSchema)
    }).transform((v) => {
      return remap(v, {
        httpReferer: "HTTP-Referer",
        xTitle: "X-Title",
        requestBody: "RequestBody"
      });
    });
    UpdateKeysData$inboundSchema = object({
      hash: string2(),
      name: string2(),
      label: string2(),
      disabled: boolean2(),
      limit: nullable(number2()),
      limit_remaining: nullable(number2()),
      limit_reset: nullable(string2()),
      include_byok_in_limit: boolean2(),
      usage: number2(),
      usage_daily: number2(),
      usage_weekly: number2(),
      usage_monthly: number2(),
      byok_usage: number2(),
      byok_usage_daily: number2(),
      byok_usage_weekly: number2(),
      byok_usage_monthly: number2(),
      created_at: string2(),
      updated_at: nullable(string2()),
      expires_at: nullable(iso_exports.datetime({ offset: true }).transform((v) => new Date(v))).optional()
    }).transform((v) => {
      return remap(v, {
        "limit_remaining": "limitRemaining",
        "limit_reset": "limitReset",
        "include_byok_in_limit": "includeByokInLimit",
        "usage_daily": "usageDaily",
        "usage_weekly": "usageWeekly",
        "usage_monthly": "usageMonthly",
        "byok_usage": "byokUsage",
        "byok_usage_daily": "byokUsageDaily",
        "byok_usage_weekly": "byokUsageWeekly",
        "byok_usage_monthly": "byokUsageMonthly",
        "created_at": "createdAt",
        "updated_at": "updatedAt",
        "expires_at": "expiresAt"
      });
    });
    UpdateKeysResponse$inboundSchema = object({
      data: lazy(() => UpdateKeysData$inboundSchema)
    });
  }
});

// node_modules/@openrouter/sdk/esm/models/operations/index.js
var init_operations = __esm({
  "node_modules/@openrouter/sdk/esm/models/operations/index.js"() {
    init_bulkassignkeystoguardrail();
    init_bulkassignmemberstoguardrail();
    init_bulkunassignkeysfromguardrail();
    init_bulkunassignmembersfromguardrail();
    init_createauthkeyscode();
    init_createcoinbasecharge();
    init_createembeddings();
    init_createguardrail();
    init_createkeys();
    init_createresponses();
    init_deleteguardrail();
    init_deletekeys();
    init_exchangeauthcodeforapikey();
    init_getcredits();
    init_getcurrentkey();
    init_getgeneration();
    init_getguardrail();
    init_getkey();
    init_getmodels();
    init_getuseractivity();
    init_list();
    init_listembeddingsmodels();
    init_listendpoints();
    init_listendpointszdr();
    init_listguardrailkeyassignments();
    init_listguardrailmemberassignments();
    init_listguardrails();
    init_listkeyassignments();
    init_listmemberassignments();
    init_listmodelscount();
    init_listmodelsuser();
    init_listproviders();
    init_sendchatcompletionrequest();
    init_updateguardrail();
    init_updatekeys();
  }
});

// node_modules/@openrouter/sdk/esm/types/async.js
var __classPrivateFieldSet2, __classPrivateFieldGet2, _APIPromise_promise, _APIPromise_unwrapped, _a2, APIPromise;
var init_async = __esm({
  "node_modules/@openrouter/sdk/esm/types/async.js"() {
    __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet2 = function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    APIPromise = class {
      constructor(p) {
        _APIPromise_promise.set(this, void 0);
        _APIPromise_unwrapped.set(this, void 0);
        this[_a2] = "APIPromise";
        __classPrivateFieldSet2(this, _APIPromise_promise, p instanceof Promise ? p : Promise.resolve(p), "f");
        __classPrivateFieldSet2(this, _APIPromise_unwrapped, p instanceof Promise ? __classPrivateFieldGet2(this, _APIPromise_promise, "f").then(([value]) => value) : Promise.resolve(p[0]), "f");
      }
      then(onfulfilled, onrejected) {
        return __classPrivateFieldGet2(this, _APIPromise_promise, "f").then(onfulfilled ? ([value]) => onfulfilled(value) : void 0, onrejected);
      }
      catch(onrejected) {
        return __classPrivateFieldGet2(this, _APIPromise_unwrapped, "f").catch(onrejected);
      }
      finally(onfinally) {
        return __classPrivateFieldGet2(this, _APIPromise_unwrapped, "f").finally(onfinally);
      }
      $inspect() {
        return __classPrivateFieldGet2(this, _APIPromise_promise, "f");
      }
    };
    _APIPromise_promise = /* @__PURE__ */ new WeakMap(), _APIPromise_unwrapped = /* @__PURE__ */ new WeakMap(), _a2 = Symbol.toStringTag;
  }
});

// node_modules/@openrouter/sdk/esm/funcs/analyticsGetUserActivity.js
function analyticsGetUserActivity(client, request, options) {
  return new APIPromise($do(client, request, options));
}
async function $do(client, request, options) {
  const parsed = safeParse3(request, (value) => GetUserActivityRequest$outboundSchema.optional().parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path3 = pathToFunc("/activity")();
  const query = encodeFormQuery({
    "date": payload?.date
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload?.["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload?.["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getUserActivity",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "403", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, GetUserActivityResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(403, ForbiddenResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_analyticsGetUserActivity = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/analyticsGetUserActivity.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/sdk/analytics.js
var Analytics;
var init_analytics = __esm({
  "node_modules/@openrouter/sdk/esm/sdk/analytics.js"() {
    init_analyticsGetUserActivity();
    init_sdks();
    init_fp();
    Analytics = class extends ClientSDK {
      /**
       * Get user activity grouped by endpoint
       *
       * @remarks
       * Returns user activity data grouped by endpoint for the last 30 (completed) UTC days. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async getUserActivity(request, options) {
        return unwrapAsync(analyticsGetUserActivity(this, request, options));
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/funcs/apiKeysCreate.js
function apiKeysCreate(client, request, options) {
  return new APIPromise($do2(client, request, options));
}
async function $do2(client, request, options) {
  const parsed = safeParse3(request, (value) => CreateKeysRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.RequestBody, { explode: true });
  const path3 = pathToFunc("/keys")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createKeys",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "429", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(201, CreateKeysResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(429, TooManyRequestsResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_apiKeysCreate = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/apiKeysCreate.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/apiKeysDelete.js
function apiKeysDelete(client, request, options) {
  return new APIPromise($do3(client, request, options));
}
async function $do3(client, request, options) {
  const parsed = safeParse3(request, (value) => DeleteKeysRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    hash: encodeSimple("hash", payload.hash, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path3 = pathToFunc("/keys/{hash}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteKeys",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "404", "429", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, DeleteKeysResponse$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(429, TooManyRequestsResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_apiKeysDelete = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/apiKeysDelete.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/apiKeysGet.js
function apiKeysGet(client, request, options) {
  return new APIPromise($do4(client, request, options));
}
async function $do4(client, request, options) {
  const parsed = safeParse3(request, (value) => GetKeyRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    hash: encodeSimple("hash", payload.hash, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path3 = pathToFunc("/keys/{hash}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getKey",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "404", "429", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, GetKeyResponse$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(429, TooManyRequestsResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_apiKeysGet = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/apiKeysGet.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/apiKeysGetCurrentKeyMetadata.js
function apiKeysGetCurrentKeyMetadata(client, request, options) {
  return new APIPromise($do5(client, request, options));
}
async function $do5(client, request, options) {
  const parsed = safeParse3(request, (value) => GetCurrentKeyRequest$outboundSchema.optional().parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path3 = pathToFunc("/key")();
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload?.["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload?.["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getCurrentKey",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, GetCurrentKeyResponse$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_apiKeysGetCurrentKeyMetadata = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/apiKeysGetCurrentKeyMetadata.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/apiKeysList.js
function apiKeysList(client, request, options) {
  return new APIPromise($do6(client, request, options));
}
async function $do6(client, request, options) {
  const parsed = safeParse3(request, (value) => ListRequest$outboundSchema.optional().parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path3 = pathToFunc("/keys")();
  const query = encodeFormQuery({
    "include_disabled": payload?.include_disabled,
    "offset": payload?.offset
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload?.["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload?.["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "list",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "429", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, ListResponse$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(429, TooManyRequestsResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_apiKeysList = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/apiKeysList.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/apiKeysUpdate.js
function apiKeysUpdate(client, request, options) {
  return new APIPromise($do7(client, request, options));
}
async function $do7(client, request, options) {
  const parsed = safeParse3(request, (value) => UpdateKeysRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.RequestBody, { explode: true });
  const pathParams = {
    hash: encodeSimple("hash", payload.hash, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path3 = pathToFunc("/keys/{hash}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateKeys",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "404", "429", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, UpdateKeysResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(429, TooManyRequestsResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_apiKeysUpdate = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/apiKeysUpdate.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/sdk/apikeys.js
var APIKeys;
var init_apikeys = __esm({
  "node_modules/@openrouter/sdk/esm/sdk/apikeys.js"() {
    init_apiKeysCreate();
    init_apiKeysDelete();
    init_apiKeysGet();
    init_apiKeysGetCurrentKeyMetadata();
    init_apiKeysList();
    init_apiKeysUpdate();
    init_sdks();
    init_fp();
    APIKeys = class extends ClientSDK {
      /**
       * List API keys
       *
       * @remarks
       * List all API keys for the authenticated user. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async list(request, options) {
        return unwrapAsync(apiKeysList(this, request, options));
      }
      /**
       * Create a new API key
       *
       * @remarks
       * Create a new API key for the authenticated user. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async create(request, options) {
        return unwrapAsync(apiKeysCreate(this, request, options));
      }
      /**
       * Update an API key
       *
       * @remarks
       * Update an existing API key. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async update(request, options) {
        return unwrapAsync(apiKeysUpdate(this, request, options));
      }
      /**
       * Delete an API key
       *
       * @remarks
       * Delete an existing API key. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async delete(request, options) {
        return unwrapAsync(apiKeysDelete(this, request, options));
      }
      /**
       * Get a single API key
       *
       * @remarks
       * Get a single API key by hash. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async get(request, options) {
        return unwrapAsync(apiKeysGet(this, request, options));
      }
      /**
       * Get current API key
       *
       * @remarks
       * Get information on the API key associated with the current authentication session
       */
      async getCurrentKeyMetadata(request, options) {
        return unwrapAsync(apiKeysGetCurrentKeyMetadata(this, request, options));
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/funcs/betaResponsesSend.js
function betaResponsesSend(client, request, options) {
  return new APIPromise($do8(client, request, options));
}
async function $do8(client, request, options) {
  const parsed = safeParse3(request, (value) => CreateResponsesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.OpenResponsesRequest, {
    explode: true
  });
  const path3 = pathToFunc("/responses")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: request?.openResponsesRequest?.stream ? "text/event-stream" : "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createResponses",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "402",
      "404",
      "408",
      "413",
      "422",
      "429",
      "4XX",
      "500",
      "502",
      "503",
      "524",
      "529",
      "5XX"
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, CreateResponsesResponse$inboundSchema), sse(200, CreateResponsesResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(402, PaymentRequiredResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(408, RequestTimeoutResponseError$inboundSchema), jsonErr(413, PayloadTooLargeResponseError$inboundSchema), jsonErr(422, UnprocessableEntityResponseError$inboundSchema), jsonErr(429, TooManyRequestsResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), jsonErr(502, BadGatewayResponseError$inboundSchema), jsonErr(503, ServiceUnavailableResponseError$inboundSchema), jsonErr(524, EdgeNetworkTimeoutResponseError$inboundSchema), jsonErr(529, ProviderOverloadedResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_betaResponsesSend = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/betaResponsesSend.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/sdk/responses.js
var Responses;
var init_responses = __esm({
  "node_modules/@openrouter/sdk/esm/sdk/responses.js"() {
    init_betaResponsesSend();
    init_sdks();
    init_fp();
    Responses = class extends ClientSDK {
      async send(request, options) {
        return unwrapAsync(betaResponsesSend(this, request, options));
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/sdk/beta.js
var Beta;
var init_beta = __esm({
  "node_modules/@openrouter/sdk/esm/sdk/beta.js"() {
    init_sdks();
    init_responses();
    Beta = class extends ClientSDK {
      get responses() {
        return this._responses ?? (this._responses = new Responses(this._options));
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/funcs/chatSend.js
function chatSend(client, request, options) {
  return new APIPromise($do9(client, request, options));
}
async function $do9(client, request, options) {
  const parsed = safeParse3(request, (value) => SendChatCompletionRequestRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.ChatGenerationParams, {
    explode: true
  });
  const path3 = pathToFunc("/chat/completions")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: request?.chatGenerationParams?.stream ? "text/event-stream" : "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "sendChatCompletionRequest",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "429", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, SendChatCompletionRequestResponse$inboundSchema), sse(200, SendChatCompletionRequestResponse$inboundSchema), jsonErr([400, 401, 429], ChatError$inboundSchema), jsonErr(500, ChatError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_chatSend = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/chatSend.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/sdk/chat.js
var Chat;
var init_chat = __esm({
  "node_modules/@openrouter/sdk/esm/sdk/chat.js"() {
    init_chatSend();
    init_sdks();
    init_fp();
    Chat = class extends ClientSDK {
      async send(request, options) {
        return unwrapAsync(chatSend(this, request, options));
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/funcs/creditsCreateCoinbaseCharge.js
function creditsCreateCoinbaseCharge(client, security, request, options) {
  return new APIPromise($do10(client, security, request, options));
}
async function $do10(client, security, request, options) {
  const parsed = safeParse3(request, (value) => CreateCoinbaseChargeRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateChargeRequest, {
    explode: true
  });
  const path3 = pathToFunc("/credits/coinbase")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.bearer
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createCoinbaseCharge",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "429", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, CreateCoinbaseChargeResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(429, TooManyRequestsResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_creditsCreateCoinbaseCharge = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/creditsCreateCoinbaseCharge.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/creditsGetCredits.js
function creditsGetCredits(client, request, options) {
  return new APIPromise($do11(client, request, options));
}
async function $do11(client, request, options) {
  const parsed = safeParse3(request, (value) => GetCreditsRequest$outboundSchema.optional().parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path3 = pathToFunc("/credits")();
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload?.["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload?.["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getCredits",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "403", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, GetCreditsResponse$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(403, ForbiddenResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_creditsGetCredits = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/creditsGetCredits.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/sdk/credits.js
var Credits;
var init_credits = __esm({
  "node_modules/@openrouter/sdk/esm/sdk/credits.js"() {
    init_creditsCreateCoinbaseCharge();
    init_creditsGetCredits();
    init_sdks();
    init_fp();
    Credits = class extends ClientSDK {
      /**
       * Get remaining credits
       *
       * @remarks
       * Get total credits purchased and used for the authenticated user. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async getCredits(request, options) {
        return unwrapAsync(creditsGetCredits(this, request, options));
      }
      /**
       * Create a Coinbase charge for crypto payment
       *
       * @remarks
       * Create a Coinbase charge for crypto payment
       */
      async createCoinbaseCharge(security, request, options) {
        return unwrapAsync(creditsCreateCoinbaseCharge(this, security, request, options));
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/funcs/embeddingsGenerate.js
function embeddingsGenerate(client, request, options) {
  return new APIPromise($do12(client, request, options));
}
async function $do12(client, request, options) {
  const parsed = safeParse3(request, (value) => CreateEmbeddingsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.RequestBody, { explode: true });
  const path3 = pathToFunc("/embeddings")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json;q=1, text/event-stream;q=0",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createEmbeddings",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "402",
      "404",
      "429",
      "4XX",
      "500",
      "502",
      "503",
      "524",
      "529",
      "5XX"
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, CreateEmbeddingsResponse$inboundSchema), text(200, CreateEmbeddingsResponse$inboundSchema, {
    ctype: "text/event-stream"
  }), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(402, PaymentRequiredResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(429, TooManyRequestsResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), jsonErr(502, BadGatewayResponseError$inboundSchema), jsonErr(503, ServiceUnavailableResponseError$inboundSchema), jsonErr(524, EdgeNetworkTimeoutResponseError$inboundSchema), jsonErr(529, ProviderOverloadedResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_embeddingsGenerate = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/embeddingsGenerate.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/embeddingsListModels.js
function embeddingsListModels(client, request, options) {
  return new APIPromise($do13(client, request, options));
}
async function $do13(client, request, options) {
  const parsed = safeParse3(request, (value) => ListEmbeddingsModelsRequest$outboundSchema.optional().parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path3 = pathToFunc("/embeddings/models")();
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload?.["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload?.["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listEmbeddingsModels",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, ModelsListResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_embeddingsListModels = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/embeddingsListModels.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_models();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/sdk/embeddings.js
var Embeddings;
var init_embeddings = __esm({
  "node_modules/@openrouter/sdk/esm/sdk/embeddings.js"() {
    init_embeddingsGenerate();
    init_embeddingsListModels();
    init_sdks();
    init_fp();
    Embeddings = class extends ClientSDK {
      /**
       * Submit an embedding request
       *
       * @remarks
       * Submits an embedding request to the embeddings router
       */
      async generate(request, options) {
        return unwrapAsync(embeddingsGenerate(this, request, options));
      }
      /**
       * List all embeddings models
       *
       * @remarks
       * Returns a list of all available embeddings models and their properties
       */
      async listModels(request, options) {
        return unwrapAsync(embeddingsListModels(this, request, options));
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/funcs/endpointsList.js
function endpointsList(client, request, options) {
  return new APIPromise($do14(client, request, options));
}
async function $do14(client, request, options) {
  const parsed = safeParse3(request, (value) => ListEndpointsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    author: encodeSimple("author", payload.author, {
      explode: false,
      charEncoding: "percent"
    }),
    slug: encodeSimple("slug", payload.slug, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path3 = pathToFunc("/models/{author}/{slug}/endpoints")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listEndpoints",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, ListEndpointsResponse$inboundSchema2), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_endpointsList = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/endpointsList.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/endpointsListZdrEndpoints.js
function endpointsListZdrEndpoints(client, request, options) {
  return new APIPromise($do15(client, request, options));
}
async function $do15(client, request, options) {
  const parsed = safeParse3(request, (value) => ListEndpointsZdrRequest$outboundSchema.optional().parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path3 = pathToFunc("/endpoints/zdr")();
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload?.["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload?.["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listEndpointsZdr",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, ListEndpointsZdrResponse$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_endpointsListZdrEndpoints = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/endpointsListZdrEndpoints.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/sdk/endpoints.js
var Endpoints;
var init_endpoints = __esm({
  "node_modules/@openrouter/sdk/esm/sdk/endpoints.js"() {
    init_endpointsList();
    init_endpointsListZdrEndpoints();
    init_sdks();
    init_fp();
    Endpoints = class extends ClientSDK {
      /**
       * List all endpoints for a model
       */
      async list(request, options) {
        return unwrapAsync(endpointsList(this, request, options));
      }
      /**
       * Preview the impact of ZDR on the available endpoints
       */
      async listZdrEndpoints(request, options) {
        return unwrapAsync(endpointsListZdrEndpoints(this, request, options));
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/funcs/generationsGetGeneration.js
function generationsGetGeneration(client, request, options) {
  return new APIPromise($do16(client, request, options));
}
async function $do16(client, request, options) {
  const parsed = safeParse3(request, (value) => GetGenerationRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path3 = pathToFunc("/generation")();
  const query = encodeFormQuery({
    "id": payload.id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getGeneration",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "401",
      "402",
      "404",
      "429",
      "4XX",
      "500",
      "502",
      "524",
      "529",
      "5XX"
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, GetGenerationResponse$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(402, PaymentRequiredResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(429, TooManyRequestsResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), jsonErr(502, BadGatewayResponseError$inboundSchema), jsonErr(524, EdgeNetworkTimeoutResponseError$inboundSchema), jsonErr(529, ProviderOverloadedResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_generationsGetGeneration = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/generationsGetGeneration.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/sdk/generations.js
var Generations;
var init_generations = __esm({
  "node_modules/@openrouter/sdk/esm/sdk/generations.js"() {
    init_generationsGetGeneration();
    init_sdks();
    init_fp();
    Generations = class extends ClientSDK {
      /**
       * Get request & usage metadata for a generation
       */
      async getGeneration(request, options) {
        return unwrapAsync(generationsGetGeneration(this, request, options));
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/funcs/guardrailsBulkAssignKeys.js
function guardrailsBulkAssignKeys(client, request, options) {
  return new APIPromise($do17(client, request, options));
}
async function $do17(client, request, options) {
  const parsed = safeParse3(request, (value) => BulkAssignKeysToGuardrailRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.RequestBody, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path3 = pathToFunc("/guardrails/{id}/assignments/keys")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "bulkAssignKeysToGuardrail",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "404", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, BulkAssignKeysToGuardrailResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_guardrailsBulkAssignKeys = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/guardrailsBulkAssignKeys.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/guardrailsBulkAssignMembers.js
function guardrailsBulkAssignMembers(client, request, options) {
  return new APIPromise($do18(client, request, options));
}
async function $do18(client, request, options) {
  const parsed = safeParse3(request, (value) => BulkAssignMembersToGuardrailRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.RequestBody, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path3 = pathToFunc("/guardrails/{id}/assignments/members")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "bulkAssignMembersToGuardrail",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "404", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, BulkAssignMembersToGuardrailResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_guardrailsBulkAssignMembers = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/guardrailsBulkAssignMembers.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/guardrailsBulkUnassignKeys.js
function guardrailsBulkUnassignKeys(client, request, options) {
  return new APIPromise($do19(client, request, options));
}
async function $do19(client, request, options) {
  const parsed = safeParse3(request, (value) => BulkUnassignKeysFromGuardrailRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.RequestBody, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path3 = pathToFunc("/guardrails/{id}/assignments/keys/remove")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "bulkUnassignKeysFromGuardrail",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "404", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, BulkUnassignKeysFromGuardrailResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_guardrailsBulkUnassignKeys = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/guardrailsBulkUnassignKeys.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/guardrailsBulkUnassignMembers.js
function guardrailsBulkUnassignMembers(client, request, options) {
  return new APIPromise($do20(client, request, options));
}
async function $do20(client, request, options) {
  const parsed = safeParse3(request, (value) => BulkUnassignMembersFromGuardrailRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.RequestBody, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path3 = pathToFunc("/guardrails/{id}/assignments/members/remove")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "bulkUnassignMembersFromGuardrail",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "404", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, BulkUnassignMembersFromGuardrailResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_guardrailsBulkUnassignMembers = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/guardrailsBulkUnassignMembers.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/guardrailsCreate.js
function guardrailsCreate(client, request, options) {
  return new APIPromise($do21(client, request, options));
}
async function $do21(client, request, options) {
  const parsed = safeParse3(request, (value) => CreateGuardrailRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.RequestBody, { explode: true });
  const path3 = pathToFunc("/guardrails")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createGuardrail",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(201, CreateGuardrailResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_guardrailsCreate = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/guardrailsCreate.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/guardrailsDelete.js
function guardrailsDelete(client, request, options) {
  return new APIPromise($do22(client, request, options));
}
async function $do22(client, request, options) {
  const parsed = safeParse3(request, (value) => DeleteGuardrailRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path3 = pathToFunc("/guardrails/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteGuardrail",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "404", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, DeleteGuardrailResponse$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_guardrailsDelete = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/guardrailsDelete.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/guardrailsGet.js
function guardrailsGet(client, request, options) {
  return new APIPromise($do23(client, request, options));
}
async function $do23(client, request, options) {
  const parsed = safeParse3(request, (value) => GetGuardrailRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path3 = pathToFunc("/guardrails/{id}")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getGuardrail",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "404", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, GetGuardrailResponse$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_guardrailsGet = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/guardrailsGet.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/guardrailsList.js
function guardrailsList(client, request, options) {
  return new APIPromise($do24(client, request, options));
}
async function $do24(client, request, options) {
  const parsed = safeParse3(request, (value) => ListGuardrailsRequest$outboundSchema.optional().parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path3 = pathToFunc("/guardrails")();
  const query = encodeFormQuery({
    "limit": payload?.limit,
    "offset": payload?.offset
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload?.["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload?.["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listGuardrails",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, ListGuardrailsResponse$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_guardrailsList = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/guardrailsList.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/guardrailsListGuardrailKeyAssignments.js
function guardrailsListGuardrailKeyAssignments(client, request, options) {
  return new APIPromise($do25(client, request, options));
}
async function $do25(client, request, options) {
  const parsed = safeParse3(request, (value) => ListGuardrailKeyAssignmentsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path3 = pathToFunc("/guardrails/{id}/assignments/keys")(pathParams);
  const query = encodeFormQuery({
    "limit": payload.limit,
    "offset": payload.offset
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listGuardrailKeyAssignments",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "404", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, ListGuardrailKeyAssignmentsResponse$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_guardrailsListGuardrailKeyAssignments = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/guardrailsListGuardrailKeyAssignments.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/guardrailsListGuardrailMemberAssignments.js
function guardrailsListGuardrailMemberAssignments(client, request, options) {
  return new APIPromise($do26(client, request, options));
}
async function $do26(client, request, options) {
  const parsed = safeParse3(request, (value) => ListGuardrailMemberAssignmentsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path3 = pathToFunc("/guardrails/{id}/assignments/members")(pathParams);
  const query = encodeFormQuery({
    "limit": payload.limit,
    "offset": payload.offset
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listGuardrailMemberAssignments",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "404", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, ListGuardrailMemberAssignmentsResponse$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_guardrailsListGuardrailMemberAssignments = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/guardrailsListGuardrailMemberAssignments.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/guardrailsListKeyAssignments.js
function guardrailsListKeyAssignments(client, request, options) {
  return new APIPromise($do27(client, request, options));
}
async function $do27(client, request, options) {
  const parsed = safeParse3(request, (value) => ListKeyAssignmentsRequest$outboundSchema.optional().parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path3 = pathToFunc("/guardrails/assignments/keys")();
  const query = encodeFormQuery({
    "limit": payload?.limit,
    "offset": payload?.offset
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload?.["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload?.["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listKeyAssignments",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, ListKeyAssignmentsResponse$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_guardrailsListKeyAssignments = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/guardrailsListKeyAssignments.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/guardrailsListMemberAssignments.js
function guardrailsListMemberAssignments(client, request, options) {
  return new APIPromise($do28(client, request, options));
}
async function $do28(client, request, options) {
  const parsed = safeParse3(request, (value) => ListMemberAssignmentsRequest$outboundSchema.optional().parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path3 = pathToFunc("/guardrails/assignments/members")();
  const query = encodeFormQuery({
    "limit": payload?.limit,
    "offset": payload?.offset
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload?.["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload?.["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listMemberAssignments",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, ListMemberAssignmentsResponse$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_guardrailsListMemberAssignments = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/guardrailsListMemberAssignments.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/guardrailsUpdate.js
function guardrailsUpdate(client, request, options) {
  return new APIPromise($do29(client, request, options));
}
async function $do29(client, request, options) {
  const parsed = safeParse3(request, (value) => UpdateGuardrailRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.RequestBody, { explode: true });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path3 = pathToFunc("/guardrails/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateGuardrail",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "404", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, UpdateGuardrailResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_guardrailsUpdate = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/guardrailsUpdate.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/sdk/guardrails.js
var Guardrails;
var init_guardrails = __esm({
  "node_modules/@openrouter/sdk/esm/sdk/guardrails.js"() {
    init_guardrailsBulkAssignKeys();
    init_guardrailsBulkAssignMembers();
    init_guardrailsBulkUnassignKeys();
    init_guardrailsBulkUnassignMembers();
    init_guardrailsCreate();
    init_guardrailsDelete();
    init_guardrailsGet();
    init_guardrailsList();
    init_guardrailsListGuardrailKeyAssignments();
    init_guardrailsListGuardrailMemberAssignments();
    init_guardrailsListKeyAssignments();
    init_guardrailsListMemberAssignments();
    init_guardrailsUpdate();
    init_sdks();
    init_fp();
    Guardrails = class extends ClientSDK {
      /**
       * List guardrails
       *
       * @remarks
       * List all guardrails for the authenticated user. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async list(request, options) {
        return unwrapAsync(guardrailsList(this, request, options));
      }
      /**
       * Create a guardrail
       *
       * @remarks
       * Create a new guardrail for the authenticated user. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async create(request, options) {
        return unwrapAsync(guardrailsCreate(this, request, options));
      }
      /**
       * Get a guardrail
       *
       * @remarks
       * Get a single guardrail by ID. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async get(request, options) {
        return unwrapAsync(guardrailsGet(this, request, options));
      }
      /**
       * Update a guardrail
       *
       * @remarks
       * Update an existing guardrail. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async update(request, options) {
        return unwrapAsync(guardrailsUpdate(this, request, options));
      }
      /**
       * Delete a guardrail
       *
       * @remarks
       * Delete an existing guardrail. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async delete(request, options) {
        return unwrapAsync(guardrailsDelete(this, request, options));
      }
      /**
       * List all key assignments
       *
       * @remarks
       * List all API key guardrail assignments for the authenticated user. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async listKeyAssignments(request, options) {
        return unwrapAsync(guardrailsListKeyAssignments(this, request, options));
      }
      /**
       * List all member assignments
       *
       * @remarks
       * List all organization member guardrail assignments for the authenticated user. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async listMemberAssignments(request, options) {
        return unwrapAsync(guardrailsListMemberAssignments(this, request, options));
      }
      /**
       * List key assignments for a guardrail
       *
       * @remarks
       * List all API key assignments for a specific guardrail. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async listGuardrailKeyAssignments(request, options) {
        return unwrapAsync(guardrailsListGuardrailKeyAssignments(this, request, options));
      }
      /**
       * Bulk assign keys to a guardrail
       *
       * @remarks
       * Assign multiple API keys to a specific guardrail. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async bulkAssignKeys(request, options) {
        return unwrapAsync(guardrailsBulkAssignKeys(this, request, options));
      }
      /**
       * List member assignments for a guardrail
       *
       * @remarks
       * List all organization member assignments for a specific guardrail. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async listGuardrailMemberAssignments(request, options) {
        return unwrapAsync(guardrailsListGuardrailMemberAssignments(this, request, options));
      }
      /**
       * Bulk assign members to a guardrail
       *
       * @remarks
       * Assign multiple organization members to a specific guardrail. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async bulkAssignMembers(request, options) {
        return unwrapAsync(guardrailsBulkAssignMembers(this, request, options));
      }
      /**
       * Bulk unassign keys from a guardrail
       *
       * @remarks
       * Unassign multiple API keys from a specific guardrail. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async bulkUnassignKeys(request, options) {
        return unwrapAsync(guardrailsBulkUnassignKeys(this, request, options));
      }
      /**
       * Bulk unassign members from a guardrail
       *
       * @remarks
       * Unassign multiple organization members from a specific guardrail. [Management key](/docs/guides/overview/auth/management-api-keys) required.
       */
      async bulkUnassignMembers(request, options) {
        return unwrapAsync(guardrailsBulkUnassignMembers(this, request, options));
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/funcs/modelsCount.js
function modelsCount(client, request, options) {
  return new APIPromise($do30(client, request, options));
}
async function $do30(client, request, options) {
  const parsed = safeParse3(request, (value) => ListModelsCountRequest$outboundSchema.optional().parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path3 = pathToFunc("/models/count")();
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload?.["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload?.["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listModelsCount",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, ModelsCountResponse$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_modelsCount = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/modelsCount.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_models();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/modelsList.js
function modelsList(client, request, options) {
  return new APIPromise($do31(client, request, options));
}
async function $do31(client, request, options) {
  const parsed = safeParse3(request, (value) => GetModelsRequest$outboundSchema.optional().parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path3 = pathToFunc("/models")();
  const query = encodeFormQuery({
    "category": payload?.category,
    "supported_parameters": payload?.supported_parameters
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload?.["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload?.["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getModels",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    query,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, ModelsListResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_modelsList = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/modelsList.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_models();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/modelsListForUser.js
function modelsListForUser(client, security, request, options) {
  return new APIPromise($do32(client, security, request, options));
}
async function $do32(client, security, request, options) {
  const parsed = safeParse3(request, (value) => ListModelsUserRequest$outboundSchema.optional().parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path3 = pathToFunc("/models/user")();
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload?.["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload?.["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const requestSecurity = resolveSecurity([
    {
      fieldName: "Authorization",
      type: "http:bearer",
      value: security?.bearer
    }
  ]);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listModelsUser",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: security,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["401", "404", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, ModelsListResponse$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(404, NotFoundResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_modelsListForUser = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/modelsListForUser.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_models();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/sdk/models.js
var Models;
var init_models2 = __esm({
  "node_modules/@openrouter/sdk/esm/sdk/models.js"() {
    init_modelsCount();
    init_modelsList();
    init_modelsListForUser();
    init_sdks();
    init_fp();
    Models = class extends ClientSDK {
      /**
       * Get total count of available models
       */
      async count(request, options) {
        return unwrapAsync(modelsCount(this, request, options));
      }
      /**
       * List all models and their properties
       */
      async list(request, options) {
        return unwrapAsync(modelsList(this, request, options));
      }
      /**
       * List models filtered by user provider preferences, privacy settings, and guardrails
       *
       * @remarks
       * List models filtered by user provider preferences, [privacy settings](https://openrouter.ai/docs/guides/privacy/logging), and [guardrails](https://openrouter.ai/docs/guides/features/guardrails). If requesting through `eu.openrouter.ai/api/v1/...` the results will be filtered to models that satisfy [EU in-region routing](https://openrouter.ai/docs/guides/privacy/logging#enterprise-eu-in-region-routing).
       */
      async listForUser(security, request, options) {
        return unwrapAsync(modelsListForUser(this, security, request, options));
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/funcs/oAuthCreateAuthCode.js
function oAuthCreateAuthCode(client, request, options) {
  return new APIPromise($do33(client, request, options));
}
async function $do33(client, request, options) {
  const parsed = safeParse3(request, (value) => CreateAuthKeysCodeRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.RequestBody, { explode: true });
  const path3 = pathToFunc("/auth/keys/code")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createAuthKeysCode",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, CreateAuthKeysCodeResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(401, UnauthorizedResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_oAuthCreateAuthCode = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/oAuthCreateAuthCode.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/funcs/oAuthExchangeAuthCodeForAPIKey.js
function oAuthExchangeAuthCodeForAPIKey(client, request, options) {
  return new APIPromise($do34(client, request, options));
}
async function $do34(client, request, options) {
  const parsed = safeParse3(request, (value) => ExchangeAuthCodeForAPIKeyRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.RequestBody, { explode: true });
  const path3 = pathToFunc("/auth/keys")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "exchangeAuthCodeForAPIKey",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "403", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, ExchangeAuthCodeForAPIKeyResponse$inboundSchema), jsonErr(400, BadRequestResponseError$inboundSchema), jsonErr(403, ForbiddenResponseError$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_oAuthExchangeAuthCodeForAPIKey = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/oAuthExchangeAuthCodeForAPIKey.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/zod/v3/helpers/util.js
var util, objectUtil, ZodParsedType, getParsedType2;
var init_util2 = __esm({
  "node_modules/zod/v3/helpers/util.js"() {
    (function(util2) {
      util2.assertEqual = (_) => {
      };
      function assertIs2(_arg) {
      }
      util2.assertIs = assertIs2;
      function assertNever2(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever2;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
        const keys = [];
        for (const key in object2) {
          if (Object.prototype.hasOwnProperty.call(object2, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues2(array2, separator = " | ") {
        return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues2;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType2 = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    };
  }
});

// node_modules/zod/v3/ZodError.js
var ZodIssueCode2, quotelessJson, ZodError2;
var init_ZodError = __esm({
  "node_modules/zod/v3/ZodError.js"() {
    init_util2();
    ZodIssueCode2 = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = (obj) => {
      const json3 = JSON.stringify(obj, null, 2);
      return json3.replace(/"([^"]+)":/g, "$1:");
    };
    ZodError2 = class _ZodError extends Error {
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue2) {
          return issue2.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error48) => {
          for (const issue2 of error48.issues) {
            if (issue2.code === "invalid_union") {
              issue2.unionErrors.map(processError);
            } else if (issue2.code === "invalid_return_type") {
              processError(issue2.returnTypeError);
            } else if (issue2.code === "invalid_arguments") {
              processError(issue2.argumentsError);
            } else if (issue2.path.length === 0) {
              fieldErrors._errors.push(mapper(issue2));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue2.path.length) {
                const el = issue2.path[i];
                const terminal = i === issue2.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue2));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue2) => issue2.message) {
        const fieldErrors = /* @__PURE__ */ Object.create(null);
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError2.create = (issues) => {
      const error48 = new ZodError2(issues);
      return error48;
    };
  }
});

// node_modules/zod/v3/locales/en.js
var errorMap, en_default2;
var init_en2 = __esm({
  "node_modules/zod/v3/locales/en.js"() {
    init_ZodError();
    init_util2();
    errorMap = (issue2, _ctx) => {
      let message;
      switch (issue2.code) {
        case ZodIssueCode2.invalid_type:
          if (issue2.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue2.expected}, received ${issue2.received}`;
          }
          break;
        case ZodIssueCode2.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode2.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
          break;
        case ZodIssueCode2.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode2.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
          break;
        case ZodIssueCode2.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
          break;
        case ZodIssueCode2.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode2.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode2.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode2.invalid_string:
          if (typeof issue2.validation === "object") {
            if ("includes" in issue2.validation) {
              message = `Invalid input: must include "${issue2.validation.includes}"`;
              if (typeof issue2.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
              }
            } else if ("startsWith" in issue2.validation) {
              message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
            } else if ("endsWith" in issue2.validation) {
              message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
            } else {
              util.assertNever(issue2.validation);
            }
          } else if (issue2.validation !== "regex") {
            message = `Invalid ${issue2.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode2.too_small:
          if (issue2.type === "array")
            message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
          else if (issue2.type === "string")
            message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
          else if (issue2.type === "number")
            message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
          else if (issue2.type === "bigint")
            message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
          else if (issue2.type === "date")
            message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode2.too_big:
          if (issue2.type === "array")
            message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
          else if (issue2.type === "string")
            message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
          else if (issue2.type === "number")
            message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
          else if (issue2.type === "bigint")
            message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
          else if (issue2.type === "date")
            message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode2.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode2.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode2.not_multiple_of:
          message = `Number must be a multiple of ${issue2.multipleOf}`;
          break;
        case ZodIssueCode2.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue2);
      }
      return { message };
    };
    en_default2 = errorMap;
  }
});

// node_modules/zod/v3/errors.js
function setErrorMap2(map2) {
  overrideErrorMap = map2;
}
function getErrorMap2() {
  return overrideErrorMap;
}
var overrideErrorMap;
var init_errors4 = __esm({
  "node_modules/zod/v3/errors.js"() {
    init_en2();
    overrideErrorMap = en_default2;
  }
});

// node_modules/zod/v3/helpers/parseUtil.js
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap2();
  const issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default2 ? void 0 : en_default2
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue2);
}
var makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK2, isAborted, isDirty, isValid, isAsync;
var init_parseUtil = __esm({
  "node_modules/zod/v3/helpers/parseUtil.js"() {
    init_errors4();
    init_en2();
    makeIssue = (params) => {
      const { data, path: path3, errorMaps, issueData } = params;
      const fullPath = [...path3, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map2 of maps) {
        errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    };
    EMPTY_PATH = [];
    ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = (value) => ({ status: "dirty", value });
    OK2 = (value) => ({ status: "valid", value });
    isAborted = (x) => x.status === "aborted";
    isDirty = (x) => x.status === "dirty";
    isValid = (x) => x.status === "valid";
    isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  }
});

// node_modules/zod/v3/helpers/typeAliases.js
var init_typeAliases = __esm({
  "node_modules/zod/v3/helpers/typeAliases.js"() {
  }
});

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
var init_errorUtil = __esm({
  "node_modules/zod/v3/helpers/errorUtil.js"() {
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
    })(errorUtil || (errorUtil = {}));
  }
});

// node_modules/zod/v3/types.js
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT2(jwt2, alg) {
  if (!jwtRegex.test(jwt2))
    return false;
  try {
    const [header] = jwt2.split(".");
    if (!header)
      return false;
    const base643 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base643));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject2) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional2.create(deepPartialify(fieldSchema));
    }
    return new ZodObject2({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray2) {
    return new ZodArray2({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional2) {
    return ZodOptional2.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable2) {
    return ZodNullable2.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple2) {
    return ZodTuple2.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues2(a, b) {
  const aType = getParsedType2(a);
  const bType = getParsedType2(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum2({
    values,
    typeName: ZodFirstPartyTypeKind2.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom2(check2, _params = {}, fatal) {
  if (check2)
    return ZodAny2.create().superRefine((data, ctx) => {
      const r = check2(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny2.create();
}
var ParseInputLazyPath, handleResult, ZodType2, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource, dateRegex, ZodString2, ZodNumber2, ZodBigInt2, ZodBoolean2, ZodDate2, ZodSymbol2, ZodUndefined2, ZodNull2, ZodAny2, ZodUnknown2, ZodNever2, ZodVoid2, ZodArray2, ZodObject2, ZodUnion2, getDiscriminator, ZodDiscriminatedUnion2, ZodIntersection2, ZodTuple2, ZodRecord2, ZodMap2, ZodSet2, ZodFunction2, ZodLazy2, ZodLiteral2, ZodEnum2, ZodNativeEnum, ZodPromise2, ZodEffects, ZodOptional2, ZodNullable2, ZodDefault2, ZodCatch2, ZodNaN2, BRAND, ZodBranded, ZodPipeline, ZodReadonly2, late, ZodFirstPartyTypeKind2, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER2;
var init_types = __esm({
  "node_modules/zod/v3/types.js"() {
    init_ZodError();
    init_errors4();
    init_errorUtil();
    init_parseUtil();
    init_util2();
    ParseInputLazyPath = class {
      constructor(parent, value, path3, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path3;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (Array.isArray(this._key)) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = (ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error48 = new ZodError2(ctx.common.issues);
            this._error = error48;
            return this._error;
          }
        };
      }
    };
    ZodType2 = class {
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType2(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType2(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType2(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        const ctx = {
          common: {
            issues: [],
            async: params?.async ?? false,
            contextualErrorMap: params?.errorMap
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType2(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType2(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return isValid(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params?.errorMap,
            async: true
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType2(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check2, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check2(val);
          const setError = () => ctx.addIssue({
            code: ZodIssueCode2.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check2, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check2(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind2.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (data) => this["~validate"](data)
        };
      }
      optional() {
        return ZodOptional2.create(this, this._def);
      }
      nullable() {
        return ZodNullable2.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray2.create(this);
      }
      promise() {
        return ZodPromise2.create(this, this._def);
      }
      or(option) {
        return ZodUnion2.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection2.create(this, incoming, this._def);
      }
      transform(transform2) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind2.ZodEffects,
          effect: { type: "transform", transform: transform2 }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault2({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind2.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind2.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch2({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind2.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly2.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    ZodString2 = class _ZodString2 extends ZodType2 {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType2 = this._getType(input);
        if (parsedType2 !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            if (input.data.length < check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_small,
                minimum: check2.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            if (input.data.length > check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_big,
                maximum: check2.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "length") {
            const tooBig = input.data.length > check2.value;
            const tooSmall = input.data.length < check2.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode2.too_big,
                  maximum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check2.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode2.too_small,
                  minimum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check2.message
                });
              }
              status.dirty();
            }
          } else if (check2.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "url") {
            try {
              new URL(input.data);
            } catch {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "regex") {
            check2.regex.lastIndex = 0;
            const testResult = check2.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "trim") {
            input.data = input.data.trim();
          } else if (check2.kind === "includes") {
            if (!input.data.includes(check2.value, check2.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: { includes: check2.value, position: check2.position },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check2.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check2.kind === "startsWith") {
            if (!input.data.startsWith(check2.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: { startsWith: check2.value },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "endsWith") {
            if (!input.data.endsWith(check2.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: { endsWith: check2.value },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "datetime") {
            const regex = datetimeRegex(check2);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: "datetime",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: "date",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "time") {
            const regex = timeRegex(check2);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: "time",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "ip") {
            if (!isValidIP(input.data, check2.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "jwt") {
            if (!isValidJWT2(input.data, check2.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "jwt",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cidr") {
            if (!isValidCidr(input.data, check2.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cidr",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64url",
                code: ZodIssueCode2.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode2.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check2) {
        return new _ZodString2({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
      }
      base64url(message) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil.errToObj(message)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          offset: options?.offset ?? false,
          local: options?.local ?? false,
          ...errorUtil.errToObj(options?.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          ...errorUtil.errToObj(options?.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options?.position,
          ...errorUtil.errToObj(options?.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString2.create = (params) => {
      return new ZodString2({
        checks: [],
        typeName: ZodFirstPartyTypeKind2.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    ZodNumber2 = class _ZodNumber extends ZodType2 {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType2 = this._getType(input);
        if (parsedType2 !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check2 of this._def.checks) {
          if (check2.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.invalid_type,
                expected: "integer",
                received: "float",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "min") {
            const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_small,
                minimum: check2.value,
                type: "number",
                inclusive: check2.inclusive,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_big,
                maximum: check2.value,
                type: "number",
                inclusive: check2.inclusive,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "multipleOf") {
            if (floatSafeRemainder2(input.data, check2.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.not_multiple_of,
                multipleOf: check2.value,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.not_finite,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check2) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber2.create = (params) => {
      return new ZodNumber2({
        checks: [],
        typeName: ZodFirstPartyTypeKind2.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt2 = class _ZodBigInt extends ZodType2 {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch {
            return this._getInvalidInput(input);
          }
        }
        const parsedType2 = this._getType(input);
        if (parsedType2 !== ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_small,
                type: "bigint",
                minimum: check2.value,
                inclusive: check2.inclusive,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_big,
                type: "bigint",
                maximum: check2.value,
                inclusive: check2.inclusive,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "multipleOf") {
            if (input.data % check2.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.not_multiple_of,
                multipleOf: check2.value,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return INVALID;
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check2) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt2.create = (params) => {
      return new ZodBigInt2({
        checks: [],
        typeName: ZodFirstPartyTypeKind2.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean2 = class extends ZodType2 {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType2 = this._getType(input);
        if (parsedType2 !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK2(input.data);
      }
    };
    ZodBoolean2.create = (params) => {
      return new ZodBoolean2({
        typeName: ZodFirstPartyTypeKind2.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    ZodDate2 = class _ZodDate extends ZodType2 {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType2 = this._getType(input);
        if (parsedType2 !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode2.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            if (input.data.getTime() < check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_small,
                message: check2.message,
                inclusive: true,
                exact: false,
                minimum: check2.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            if (input.data.getTime() > check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode2.too_big,
                message: check2.message,
                inclusive: true,
                exact: false,
                maximum: check2.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check2) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate2.create = (params) => {
      return new ZodDate2({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind2.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol2 = class extends ZodType2 {
      _parse(input) {
        const parsedType2 = this._getType(input);
        if (parsedType2 !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK2(input.data);
      }
    };
    ZodSymbol2.create = (params) => {
      return new ZodSymbol2({
        typeName: ZodFirstPartyTypeKind2.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined2 = class extends ZodType2 {
      _parse(input) {
        const parsedType2 = this._getType(input);
        if (parsedType2 !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK2(input.data);
      }
    };
    ZodUndefined2.create = (params) => {
      return new ZodUndefined2({
        typeName: ZodFirstPartyTypeKind2.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull2 = class extends ZodType2 {
      _parse(input) {
        const parsedType2 = this._getType(input);
        if (parsedType2 !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK2(input.data);
      }
    };
    ZodNull2.create = (params) => {
      return new ZodNull2({
        typeName: ZodFirstPartyTypeKind2.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK2(input.data);
      }
    };
    ZodAny2.create = (params) => {
      return new ZodAny2({
        typeName: ZodFirstPartyTypeKind2.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK2(input.data);
      }
    };
    ZodUnknown2.create = (params) => {
      return new ZodUnknown2({
        typeName: ZodFirstPartyTypeKind2.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever2 = class extends ZodType2 {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever2.create = (params) => {
      return new ZodNever2({
        typeName: ZodFirstPartyTypeKind2.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid2 = class extends ZodType2 {
      _parse(input) {
        const parsedType2 = this._getType(input);
        if (parsedType2 !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK2(input.data);
      }
    };
    ZodVoid2.create = (params) => {
      return new ZodVoid2({
        typeName: ZodFirstPartyTypeKind2.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray2 = class _ZodArray extends ZodType2 {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode2.too_big : ZodIssueCode2.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray2.create = (schema, params) => {
      return new ZodArray2({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind2.ZodArray,
        ...processCreateParams(params)
      });
    };
    ZodObject2 = class _ZodObject extends ZodType2 {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
      }
      _parse(input) {
        const parsedType2 = this._getType(input);
        if (parsedType2 !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever2) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode2.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue2, ctx) => {
              const defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;
              if (issue2.code === "unrecognized_keys")
                return {
                  message: errorUtil.errToObj(message).message ?? defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind2.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        for (const key of util.objectKeys(mask)) {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional2) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject2.create = (shape, params) => {
      return new ZodObject2({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject2.strictCreate = (shape, params) => {
      return new ZodObject2({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject2.lazycreate = (shape, params) => {
      return new ZodObject2({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion2 = class extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError2(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError2(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion2.create = (types, params) => {
      return new ZodUnion2({
        options: types,
        typeName: ZodFirstPartyTypeKind2.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = (type) => {
      if (type instanceof ZodLazy2) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral2) {
        return [type.value];
      } else if (type instanceof ZodEnum2) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util.objectValues(type.enum);
      } else if (type instanceof ZodDefault2) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined2) {
        return [void 0];
      } else if (type instanceof ZodNull2) {
        return [null];
      } else if (type instanceof ZodOptional2) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable2) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly2) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch2) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    };
    ZodDiscriminatedUnion2 = class _ZodDiscriminatedUnion extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind2.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    ZodIntersection2 = class extends ZodType2 {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues2(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection2.create = (left, right, params) => {
      return new ZodIntersection2({
        left,
        right,
        typeName: ZodFirstPartyTypeKind2.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple2 = class _ZodTuple extends ZodType2 {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple2.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple2({
        items: schemas,
        typeName: ZodFirstPartyTypeKind2.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodRecord2 = class _ZodRecord extends ZodType2 {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType2) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind2.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString2.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind2.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap2 = class extends ZodType2 {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap2.create = (keyType, valueType, params) => {
      return new ZodMap2({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind2.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet2 = class _ZodSet extends ZodType2 {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet2.create = (valueType, params) => {
      return new ZodSet2({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind2.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodFunction2 = class _ZodFunction extends ZodType2 {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error48) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode2.invalid_arguments,
              argumentsError: error48
            }
          });
        }
        function makeReturnsIssue(returns, error48) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode2.invalid_return_type,
              returnTypeError: error48
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise2) {
          const me = this;
          return OK2(async function(...args) {
            const error48 = new ZodError2([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error48.addIssue(makeArgsIssue(args, e));
              throw error48;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error48.addIssue(makeReturnsIssue(result, e));
              throw error48;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return OK2(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError2([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError2([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple2.create(items).rest(ZodUnknown2.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),
          returns: returns || ZodUnknown2.create(),
          typeName: ZodFirstPartyTypeKind2.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    ZodLazy2 = class extends ZodType2 {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy2.create = (getter, params) => {
      return new ZodLazy2({
        getter,
        typeName: ZodFirstPartyTypeKind2.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral2 = class extends ZodType2 {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode2.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral2.create = (value, params) => {
      return new ZodLiteral2({
        value,
        typeName: ZodFirstPartyTypeKind2.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    ZodEnum2 = class _ZodEnum extends ZodType2 {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode2.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode2.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK2(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    ZodEnum2.create = createZodEnum;
    ZodNativeEnum = class extends ZodType2 {
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode2.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(util.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode2.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK2(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind2.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise2 = class extends ZodType2 {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK2(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise2.create = (schema, params) => {
      return new ZodPromise2({
        type: schema,
        typeName: ZodFirstPartyTypeKind2.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = class extends ZodType2 {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY(result.value);
              if (status.value === "dirty")
                return DIRTY(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return INVALID;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return INVALID;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                status: status.value,
                value: result
              }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind2.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess2, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess2 },
        typeName: ZodFirstPartyTypeKind2.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional2 = class extends ZodType2 {
      _parse(input) {
        const parsedType2 = this._getType(input);
        if (parsedType2 === ZodParsedType.undefined) {
          return OK2(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional2.create = (type, params) => {
      return new ZodOptional2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind2.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable2 = class extends ZodType2 {
      _parse(input) {
        const parsedType2 = this._getType(input);
        if (parsedType2 === ZodParsedType.null) {
          return OK2(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable2.create = (type, params) => {
      return new ZodNullable2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind2.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault2 = class extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault2.create = (type, params) => {
      return new ZodDefault2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind2.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch2 = class extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError2(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError2(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch2.create = (type, params) => {
      return new ZodCatch2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind2.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    ZodNaN2 = class extends ZodType2 {
      _parse(input) {
        const parsedType2 = this._getType(input);
        if (parsedType2 !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN2.create = (params) => {
      return new ZodNaN2({
        typeName: ZodFirstPartyTypeKind2.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType2 {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind2.ZodPipeline
        });
      }
    };
    ZodReadonly2 = class extends ZodType2 {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        };
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodReadonly2.create = (type, params) => {
      return new ZodReadonly2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind2.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    late = {
      object: ZodObject2.lazycreate
    };
    (function(ZodFirstPartyTypeKind3) {
      ZodFirstPartyTypeKind3["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));
    instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom2((data) => data instanceof cls, params);
    stringType = ZodString2.create;
    numberType = ZodNumber2.create;
    nanType = ZodNaN2.create;
    bigIntType = ZodBigInt2.create;
    booleanType = ZodBoolean2.create;
    dateType = ZodDate2.create;
    symbolType = ZodSymbol2.create;
    undefinedType = ZodUndefined2.create;
    nullType = ZodNull2.create;
    anyType = ZodAny2.create;
    unknownType = ZodUnknown2.create;
    neverType = ZodNever2.create;
    voidType = ZodVoid2.create;
    arrayType = ZodArray2.create;
    objectType = ZodObject2.create;
    strictObjectType = ZodObject2.strictCreate;
    unionType = ZodUnion2.create;
    discriminatedUnionType = ZodDiscriminatedUnion2.create;
    intersectionType = ZodIntersection2.create;
    tupleType = ZodTuple2.create;
    recordType = ZodRecord2.create;
    mapType = ZodMap2.create;
    setType = ZodSet2.create;
    functionType = ZodFunction2.create;
    lazyType = ZodLazy2.create;
    literalType = ZodLiteral2.create;
    enumType = ZodEnum2.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise2.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional2.create;
    nullableType = ZodNullable2.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = () => stringType().optional();
    onumber = () => numberType().optional();
    oboolean = () => booleanType().optional();
    coerce = {
      string: ((arg) => ZodString2.create({ ...arg, coerce: true })),
      number: ((arg) => ZodNumber2.create({ ...arg, coerce: true })),
      boolean: ((arg) => ZodBoolean2.create({
        ...arg,
        coerce: true
      })),
      bigint: ((arg) => ZodBigInt2.create({ ...arg, coerce: true })),
      date: ((arg) => ZodDate2.create({ ...arg, coerce: true }))
    };
    NEVER2 = INVALID;
  }
});

// node_modules/zod/v3/external.js
var external_exports2 = {};
__export(external_exports2, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER2,
  OK: () => OK2,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType2,
  ZodAny: () => ZodAny2,
  ZodArray: () => ZodArray2,
  ZodBigInt: () => ZodBigInt2,
  ZodBoolean: () => ZodBoolean2,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch2,
  ZodDate: () => ZodDate2,
  ZodDefault: () => ZodDefault2,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum2,
  ZodError: () => ZodError2,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind2,
  ZodFunction: () => ZodFunction2,
  ZodIntersection: () => ZodIntersection2,
  ZodIssueCode: () => ZodIssueCode2,
  ZodLazy: () => ZodLazy2,
  ZodLiteral: () => ZodLiteral2,
  ZodMap: () => ZodMap2,
  ZodNaN: () => ZodNaN2,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever2,
  ZodNull: () => ZodNull2,
  ZodNullable: () => ZodNullable2,
  ZodNumber: () => ZodNumber2,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional2,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise2,
  ZodReadonly: () => ZodReadonly2,
  ZodRecord: () => ZodRecord2,
  ZodSchema: () => ZodType2,
  ZodSet: () => ZodSet2,
  ZodString: () => ZodString2,
  ZodSymbol: () => ZodSymbol2,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple2,
  ZodType: () => ZodType2,
  ZodUndefined: () => ZodUndefined2,
  ZodUnion: () => ZodUnion2,
  ZodUnknown: () => ZodUnknown2,
  ZodVoid: () => ZodVoid2,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom2,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default2,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap2,
  getParsedType: () => getParsedType2,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap2,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
var init_external2 = __esm({
  "node_modules/zod/v3/external.js"() {
    init_errors4();
    init_parseUtil();
    init_typeAliases();
    init_util2();
    init_types();
    init_ZodError();
  }
});

// node_modules/zod/v3/index.js
var v3_default;
var init_v3 = __esm({
  "node_modules/zod/v3/index.js"() {
    init_external2();
    init_external2();
    v3_default = external_exports2;
  }
});

// node_modules/@openrouter/sdk/esm/funcs/oAuthCreateAuthorizationUrl.js
function oAuthCreateAuthorizationUrl(client, params) {
  const parsedParams = CreateAuthorizationurlParamsSchema.safeParse(params);
  if (!parsedParams.success) {
    return {
      ok: false,
      error: parsedParams.error
    };
  }
  const baseURL = serverURLFromOptions(client._options);
  if (!baseURL) {
    return {
      ok: false,
      error: new Error("No server URL configured")
    };
  }
  const authURL = new URL("/auth", baseURL);
  authURL.searchParams.set("callback_url", parsedParams.data.callbackUrl.toString());
  if ("codeChallengeMethod" in parsedParams.data) {
    authURL.searchParams.set("code_challenge", parsedParams.data.codeChallenge);
    authURL.searchParams.set("code_challenge_method", parsedParams.data.codeChallengeMethod);
  }
  if (parsedParams.data.limit !== void 0) {
    authURL.searchParams.set("limit", parsedParams.data.limit.toString());
  }
  return {
    ok: true,
    value: authURL.toString()
  };
}
var CreateAuthorizationUrlBaseSchema, CreateAuthorizationurlParamsSchema;
var init_oAuthCreateAuthorizationUrl = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/oAuthCreateAuthorizationUrl.js"() {
    init_v3();
    init_config();
    CreateAuthorizationUrlBaseSchema = v3_default.object({
      callbackUrl: v3_default.union([
        v3_default.string().url(),
        v3_default.instanceof(URL)
      ]),
      limit: v3_default.number().optional()
    });
    CreateAuthorizationurlParamsSchema = v3_default.union([
      CreateAuthorizationUrlBaseSchema.extend({
        codeChallengeMethod: v3_default.enum([
          "S256",
          "plain"
        ]),
        codeChallenge: v3_default.string()
      }),
      CreateAuthorizationUrlBaseSchema
    ]);
  }
});

// node_modules/@openrouter/sdk/esm/funcs/oAuthCreateSHA256CodeChallenge.js
function arrayBufferToBase64Url(buffer) {
  let binary = "";
  for (let i = 0; i < buffer.length; i++) {
    binary += String.fromCharCode(buffer[i]);
  }
  return btoa(binary).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function generateCodeVerifier() {
  const randomBytes = crypto.getRandomValues(new Uint8Array(32));
  return arrayBufferToBase64Url(randomBytes);
}
async function oAuthCreateSHA256CodeChallenge(params = {}) {
  const parsedParams = CreateSHA256CodeChallengeRequestSchema.safeParse(params);
  if (!parsedParams.success) {
    return {
      ok: false,
      error: parsedParams.error
    };
  }
  const { codeVerifier = generateCodeVerifier() } = parsedParams.data;
  const encoder = new TextEncoder();
  const data = encoder.encode(codeVerifier);
  const hash2 = await crypto.subtle.digest("SHA-256", data);
  const hashArray = new Uint8Array(hash2);
  const codeChallenge = arrayBufferToBase64Url(hashArray);
  return {
    ok: true,
    value: {
      codeChallenge,
      codeVerifier
    }
  };
}
var CreateSHA256CodeChallengeRequestSchema;
var init_oAuthCreateSHA256CodeChallenge = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/oAuthCreateSHA256CodeChallenge.js"() {
    init_v3();
    CreateSHA256CodeChallengeRequestSchema = v3_default.object({
      /**
       * If not provided, a random code verifier will be generated.
       * If provided, must be 43-128 characters and contain only unreserved
       * characters [A-Za-z0-9-._~] per RFC 7636.
       */
      codeVerifier: v3_default.string().min(43, "Code verifier must be at least 43 characters").max(128, "Code verifier must be at most 128 characters").regex(/^[A-Za-z0-9\-._~]+$/, "Code verifier must only contain unreserved characters: [A-Za-z0-9-._~]").optional()
    });
  }
});

// node_modules/@openrouter/sdk/esm/sdk/oauth.js
var OAuth;
var init_oauth = __esm({
  "node_modules/@openrouter/sdk/esm/sdk/oauth.js"() {
    init_oAuthCreateAuthCode();
    init_oAuthExchangeAuthCodeForAPIKey();
    init_sdks();
    init_fp();
    init_oAuthCreateAuthorizationUrl();
    init_oAuthCreateSHA256CodeChallenge();
    OAuth = class extends ClientSDK {
      // #region sdk-class-body
      /**
       * Generate a OAuth2 authorization URL
       *
       * @remarks
       * Generates a URL to redirect users to for authorizing your application. The
       * URL includes the provided callback URL and, if applicable, the code
       * challenge parameters for PKCE.
       *
       * @see {@link https://openrouter.ai/docs/use-cases/oauth-pkce}
       */
      async createAuthorizationUrl(request) {
        const result = oAuthCreateAuthorizationUrl(this, request);
        if (!result.ok) {
          throw result.error;
        }
        return result.value;
      }
      /**
       * Generate a SHA-256 code challenge for PKCE
       *
       * @remarks
       * Generates a SHA-256 code challenge and corresponding code verifier for use
       * in the PKCE extension to OAuth2. If no code verifier is provided, a random
       * one will be generated according to RFC 7636 (32 random bytes, base64url
       * encoded). If a code verifier is provided, it must be 43-128 characters and
       * contain only unreserved characters [A-Za-z0-9-._~].
       *
       * @see {@link https://openrouter.ai/docs/use-cases/oauth-pkce}
       * @see {@link https://datatracker.ietf.org/doc/html/rfc7636}
       */
      async createSHA256CodeChallenge() {
        return unwrapAsync(oAuthCreateSHA256CodeChallenge());
      }
      // #endregion sdk-class-body
      /**
       * Exchange authorization code for API key
       *
       * @remarks
       * Exchange an authorization code from the PKCE flow for a user-controlled API key
       */
      async exchangeAuthCodeForAPIKey(request, options) {
        return unwrapAsync(oAuthExchangeAuthCodeForAPIKey(this, request, options));
      }
      /**
       * Create authorization code
       *
       * @remarks
       * Create an authorization code for the PKCE flow to generate a user-controlled API key
       */
      async createAuthCode(request, options) {
        return unwrapAsync(oAuthCreateAuthCode(this, request, options));
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/funcs/providersList.js
function providersList(client, request, options) {
  return new APIPromise($do35(client, request, options));
}
async function $do35(client, request, options) {
  const parsed = safeParse3(request, (value) => ListProvidersRequest$outboundSchema.optional().parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path3 = pathToFunc("/providers")();
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "HTTP-Referer": encodeSimple("HTTP-Referer", payload?.["HTTP-Referer"] ?? client._options.httpReferer, { explode: false, charEncoding: "none" }),
    "X-Title": encodeSimple("X-Title", payload?.["X-Title"] ?? client._options.xTitle, { explode: false, charEncoding: "none" })
  }));
  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listProviders",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client._options.apiKey,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path3,
    headers,
    body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result] = await match(json2(200, ListProvidersResponse$inboundSchema), jsonErr(500, InternalServerResponseError$inboundSchema), fail("4XX"), fail("5XX"))(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}
var init_providersList = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/providersList.js"() {
    init_encodings();
    init_matchers();
    init_primitives();
    init_schemas3();
    init_security2();
    init_url();
    init_errors3();
    init_operations();
    init_async();
  }
});

// node_modules/@openrouter/sdk/esm/sdk/providers.js
var Providers;
var init_providers = __esm({
  "node_modules/@openrouter/sdk/esm/sdk/providers.js"() {
    init_providersList();
    init_sdks();
    init_fp();
    Providers = class extends ClientSDK {
      /**
       * List all providers
       */
      async list(request, options) {
        return unwrapAsync(providersList(this, request, options));
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/lib/reusable-stream.js
var ReusableReadableStream;
var init_reusable_stream = __esm({
  "node_modules/@openrouter/sdk/esm/lib/reusable-stream.js"() {
    ReusableReadableStream = class {
      constructor(sourceStream) {
        this.sourceStream = sourceStream;
        this.buffer = [];
        this.consumers = /* @__PURE__ */ new Map();
        this.nextConsumerId = 0;
        this.sourceReader = null;
        this.sourceComplete = false;
        this.sourceError = null;
        this.pumpStarted = false;
      }
      /**
       * Create a new consumer that can independently iterate over the stream.
       * Multiple consumers can be created and will all receive the same data.
       */
      createConsumer() {
        const consumerId = this.nextConsumerId++;
        const state = {
          position: 0,
          waitingPromise: null,
          cancelled: false
        };
        this.consumers.set(consumerId, state);
        if (!this.pumpStarted) {
          this.startPump();
        }
        const self = this;
        return {
          async next() {
            const consumer = self.consumers.get(consumerId);
            if (!consumer) {
              return {
                done: true,
                value: void 0
              };
            }
            if (consumer.cancelled) {
              return {
                done: true,
                value: void 0
              };
            }
            if (consumer.position < self.buffer.length) {
              const value = self.buffer[consumer.position];
              consumer.position++;
              return {
                done: false,
                value
              };
            }
            if (self.sourceComplete) {
              self.consumers.delete(consumerId);
              return {
                done: true,
                value: void 0
              };
            }
            if (self.sourceError) {
              self.consumers.delete(consumerId);
              throw self.sourceError;
            }
            const waitPromise = new Promise((resolve, reject) => {
              consumer.waitingPromise = {
                resolve,
                reject
              };
              if (self.sourceComplete || self.sourceError || consumer.position < self.buffer.length) {
                resolve();
              }
            });
            await waitPromise;
            consumer.waitingPromise = null;
            return this.next();
          },
          async return() {
            const consumer = self.consumers.get(consumerId);
            if (consumer) {
              consumer.cancelled = true;
              self.consumers.delete(consumerId);
            }
            return {
              done: true,
              value: void 0
            };
          },
          async throw(e) {
            const consumer = self.consumers.get(consumerId);
            if (consumer) {
              consumer.cancelled = true;
              self.consumers.delete(consumerId);
            }
            throw e;
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
      /**
       * Start pumping data from the source stream into the buffer
       */
      startPump() {
        if (this.pumpStarted) {
          return;
        }
        this.pumpStarted = true;
        this.sourceReader = this.sourceStream.getReader();
        void (async () => {
          try {
            while (true) {
              const result = await this.sourceReader.read();
              if (result.done) {
                this.sourceComplete = true;
                this.notifyAllConsumers();
                break;
              }
              this.buffer.push(result.value);
              this.notifyAllConsumers();
            }
          } catch (error48) {
            this.sourceError = error48 instanceof Error ? error48 : new Error(String(error48));
            this.notifyAllConsumers();
          } finally {
            if (this.sourceReader) {
              this.sourceReader.releaseLock();
            }
          }
        })();
      }
      /**
       * Notify all waiting consumers that new data is available
       */
      notifyAllConsumers() {
        for (const consumer of this.consumers.values()) {
          if (consumer.waitingPromise) {
            if (this.sourceError) {
              consumer.waitingPromise.reject(this.sourceError);
            } else {
              consumer.waitingPromise.resolve();
            }
            consumer.waitingPromise = null;
          }
        }
      }
      /**
       * Cancel the source stream and all consumers
       */
      async cancel() {
        for (const consumer of this.consumers.values()) {
          consumer.cancelled = true;
          if (consumer.waitingPromise) {
            consumer.waitingPromise.resolve();
          }
        }
        this.consumers.clear();
        if (this.sourceReader) {
          await this.sourceReader.cancel();
          this.sourceReader.releaseLock();
        }
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/lib/tool-executor.js
function isNonNullObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function sanitizeJsonSchema(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map(sanitizeJsonSchema);
  }
  if (!isNonNullObject(obj)) {
    return obj;
  }
  const result = {};
  for (const key of Object.keys(obj)) {
    if (!key.startsWith("~")) {
      result[key] = sanitizeJsonSchema(obj[key]);
    }
  }
  return result;
}
function isZodSchema(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (!("_zod" in value)) {
    return false;
  }
  return typeof value._zod === "object";
}
function convertZodToJsonSchema(zodSchema) {
  if (!isZodSchema(zodSchema)) {
    throw new Error("Invalid Zod schema provided");
  }
  const jsonSchema = toJSONSchema(zodSchema, {
    target: "draft-7"
  });
  return sanitizeJsonSchema(jsonSchema);
}
function convertToolsToAPIFormat(tools) {
  return tools.map((tool) => ({
    type: "function",
    name: tool.function.name,
    description: tool.function.description || null,
    strict: null,
    parameters: convertZodToJsonSchema(tool.function.inputSchema)
  }));
}
function validateToolInput(schema, args) {
  return parse2(schema, args);
}
function validateToolOutput(schema, result) {
  return parse2(schema, result);
}
function tryValidate(schema, value) {
  const result = safeParse2(schema, value);
  return result.success;
}
async function executeRegularTool(tool, toolCall, context) {
  if (!isRegularExecuteTool(tool)) {
    throw new Error(`Tool "${toolCall.name}" is not a regular execute tool or has no execute function`);
  }
  try {
    const validatedInput = validateToolInput(tool.function.inputSchema, toolCall.arguments);
    const result = await Promise.resolve(tool.function.execute(validatedInput, context));
    if (tool.function.outputSchema) {
      const validatedOutput = validateToolOutput(tool.function.outputSchema, result);
      return {
        toolCallId: toolCall.id,
        toolName: toolCall.name,
        result: validatedOutput
      };
    }
    return {
      toolCallId: toolCall.id,
      toolName: toolCall.name,
      result
    };
  } catch (error48) {
    return {
      toolCallId: toolCall.id,
      toolName: toolCall.name,
      result: null,
      error: error48 instanceof Error ? error48 : new Error(String(error48))
    };
  }
}
async function executeGeneratorTool(tool, toolCall, context, onPreliminaryResult) {
  if (!isGeneratorTool(tool)) {
    throw new Error(`Tool "${toolCall.name}" is not a generator tool`);
  }
  try {
    const validatedInput = validateToolInput(tool.function.inputSchema, toolCall.arguments);
    const preliminaryResults = [];
    let finalResult = void 0;
    let hasFinalResult = false;
    let lastEmittedValue = void 0;
    let hasEmittedValue = false;
    const iterator = tool.function.execute(validatedInput, context);
    let iterResult = await iterator.next();
    while (!iterResult.done) {
      const event = iterResult.value;
      lastEmittedValue = event;
      hasEmittedValue = true;
      const matchesOutputSchema = tryValidate(tool.function.outputSchema, event);
      const matchesEventSchema = tryValidate(tool.function.eventSchema, event);
      if (matchesOutputSchema && !matchesEventSchema && !hasFinalResult) {
        finalResult = validateToolOutput(tool.function.outputSchema, event);
        hasFinalResult = true;
      } else {
        const validatedPreliminary = validateToolOutput(tool.function.eventSchema, event);
        preliminaryResults.push(validatedPreliminary);
        if (onPreliminaryResult) {
          onPreliminaryResult(toolCall.id, validatedPreliminary);
        }
      }
      iterResult = await iterator.next();
    }
    if (iterResult.value !== void 0) {
      finalResult = validateToolOutput(tool.function.outputSchema, iterResult.value);
      hasFinalResult = true;
    }
    if (!hasFinalResult) {
      if (!hasEmittedValue) {
        throw new Error(`Generator tool "${toolCall.name}" completed without emitting any values or returning a result`);
      }
      finalResult = validateToolOutput(tool.function.outputSchema, lastEmittedValue);
    }
    return {
      toolCallId: toolCall.id,
      toolName: toolCall.name,
      result: finalResult,
      preliminaryResults
    };
  } catch (error48) {
    return {
      toolCallId: toolCall.id,
      toolName: toolCall.name,
      result: null,
      error: error48 instanceof Error ? error48 : new Error(String(error48))
    };
  }
}
async function executeTool(tool, toolCall, context, onPreliminaryResult) {
  if (!hasExecuteFunction(tool)) {
    throw new Error(`Tool "${toolCall.name}" has no execute function. Use manual tool execution.`);
  }
  if (isGeneratorTool(tool)) {
    return executeGeneratorTool(tool, toolCall, context, onPreliminaryResult);
  }
  return executeRegularTool(tool, toolCall, context);
}
var init_tool_executor = __esm({
  "node_modules/@openrouter/sdk/esm/lib/tool-executor.js"() {
    init_v4();
    init_tool_types();
  }
});

// node_modules/@openrouter/sdk/esm/lib/model-result.js
function isEventStream(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const constructorName = Object.getPrototypeOf(value)?.constructor?.name;
  if (constructorName === "EventStream") {
    return true;
  }
  const maybeStream = value;
  return typeof maybeStream.toReadableStream === "function";
}
var DEFAULT_MAX_STEPS, ModelResult;
var init_model_result = __esm({
  "node_modules/@openrouter/sdk/esm/lib/model-result.js"() {
    init_tool_event_broadcaster();
    init_betaResponsesSend();
    init_async_params();
    init_conversation_state();
    init_reusable_stream();
    init_stream_transformers();
    init_tool_executor();
    init_next_turn_params();
    init_tool_types();
    init_stop_conditions();
    init_stream_type_guards();
    DEFAULT_MAX_STEPS = 5;
    ModelResult = class {
      constructor(options) {
        this.reusableStream = null;
        this.textPromise = null;
        this.initPromise = null;
        this.toolExecutionPromise = null;
        this.finalResponse = null;
        this.toolEventBroadcaster = null;
        this.allToolExecutionRounds = [];
        this.resolvedRequest = null;
        this.stateAccessor = null;
        this.currentState = null;
        this.requireApprovalFn = null;
        this.approvedToolCalls = [];
        this.rejectedToolCalls = [];
        this.isResumingFromApproval = false;
        this.options = options;
        const hasApprovalDecisions = options.approveToolCalls && options.approveToolCalls.length > 0 || options.rejectToolCalls && options.rejectToolCalls.length > 0;
        if (hasApprovalDecisions && !options.state) {
          throw new Error('approveToolCalls and rejectToolCalls require a state accessor. Provide a StateAccessor via the "state" parameter to persist approval decisions.');
        }
        this.stateAccessor = options.state ?? null;
        this.requireApprovalFn = options.requireApproval ?? null;
        this.approvedToolCalls = options.approveToolCalls ?? [];
        this.rejectedToolCalls = options.rejectToolCalls ?? [];
      }
      /**
       * Get or create the tool event broadcaster (lazy initialization).
       * Ensures only one broadcaster exists for the lifetime of this ModelResult.
       * Broadcasts both preliminary results and final tool results.
       */
      ensureBroadcaster() {
        if (!this.toolEventBroadcaster) {
          this.toolEventBroadcaster = new ToolEventBroadcaster();
        }
        return this.toolEventBroadcaster;
      }
      /**
       * Type guard to check if a value is a non-streaming response
       * Only requires 'output' field and absence of 'toReadableStream' method
       */
      isNonStreamingResponse(value) {
        return value !== null && typeof value === "object" && "output" in value && !("toReadableStream" in value);
      }
      // =========================================================================
      // Extracted Helper Methods for executeToolsIfNeeded
      // =========================================================================
      /**
       * Get initial response from stream or cached final response.
       * Consumes the stream to completion if needed to extract the response.
       *
       * @returns The complete non-streaming response
       * @throws Error if neither stream nor response has been initialized
       */
      async getInitialResponse() {
        if (this.finalResponse) {
          return this.finalResponse;
        }
        if (this.reusableStream) {
          return consumeStreamForCompletion(this.reusableStream);
        }
        throw new Error("Neither stream nor response initialized");
      }
      /**
       * Save response output to state.
       * Appends the response output to the message history and records the response ID.
       *
       * @param response - The API response to save
       */
      async saveResponseToState(response) {
        if (!this.stateAccessor || !this.currentState)
          return;
        const outputItems = Array.isArray(response.output) ? response.output : [response.output];
        await this.saveStateSafely({
          messages: appendToMessages(this.currentState.messages, outputItems),
          previousResponseId: response.id
        });
      }
      /**
       * Mark state as complete.
       * Sets the conversation status to 'complete' indicating no further tool execution is needed.
       */
      async markStateComplete() {
        await this.saveStateSafely({ status: "complete" });
      }
      /**
       * Save tool results to state.
       * Appends tool execution results to the message history for multi-turn context.
       *
       * @param toolResults - The tool execution results to save
       */
      async saveToolResultsToState(toolResults) {
        if (!this.currentState)
          return;
        await this.saveStateSafely({
          messages: appendToMessages(this.currentState.messages, toolResults)
        });
      }
      /**
       * Check if execution should be interrupted by external signal.
       * Polls the state accessor for interruption flags set by external processes.
       *
       * @param currentResponse - The current response to save as partial state
       * @returns True if interrupted and caller should exit, false to continue
       */
      async checkForInterruption(currentResponse) {
        if (!this.stateAccessor)
          return false;
        const freshState = await this.stateAccessor.load();
        if (!freshState?.interruptedBy)
          return false;
        if (this.currentState) {
          const currentToolCalls = extractToolCallsFromResponse(currentResponse);
          await this.saveStateSafely({
            status: "interrupted",
            partialResponse: {
              text: extractTextFromResponse2(currentResponse),
              toolCalls: currentToolCalls
            }
          });
        }
        this.finalResponse = currentResponse;
        return true;
      }
      /**
       * Check if stop conditions are met.
       * Returns true if execution should stop.
       *
       * @remarks
       * Default: stepCountIs(DEFAULT_MAX_STEPS) if no stopWhen is specified.
       * This evaluates stop conditions against the complete step history.
       */
      async shouldStopExecution() {
        const stopWhen = this.options.stopWhen ?? stepCountIs(DEFAULT_MAX_STEPS);
        const stopConditions = Array.isArray(stopWhen) ? stopWhen : [stopWhen];
        return isStopConditionMet({
          stopConditions,
          steps: this.allToolExecutionRounds.map((round) => ({
            stepType: "continue",
            text: extractTextFromResponse(round.response),
            toolCalls: round.toolCalls,
            toolResults: round.toolResults.map((tr) => ({
              toolCallId: tr.callId,
              toolName: round.toolCalls.find((tc) => tc.id === tr.callId)?.name ?? "",
              result: JSON.parse(tr.output)
            })),
            response: round.response,
            usage: round.response.usage,
            finishReason: void 0
          }))
        });
      }
      /**
       * Check if any tool calls have execute functions.
       * Used to determine if automatic tool execution should be attempted.
       *
       * @param toolCalls - The tool calls to check
       * @returns True if at least one tool call has an executable function
       */
      hasExecutableToolCalls(toolCalls) {
        return toolCalls.some((toolCall) => {
          const tool = this.options.tools?.find((t) => t.function.name === toolCall.name);
          return tool && hasExecuteFunction(tool);
        });
      }
      /**
       * Execute tools that can auto-execute (don't require approval) in parallel.
       *
       * @param toolCalls - The tool calls to execute
       * @param turnContext - The current turn context
       * @returns Array of unsent tool results for later submission
       */
      async executeAutoApproveTools(toolCalls, turnContext) {
        const toolCallPromises = toolCalls.map(async (tc) => {
          const tool = this.options.tools?.find((t) => t.function.name === tc.name);
          if (!tool || !hasExecuteFunction(tool)) {
            return null;
          }
          const result = await executeTool(tool, tc, turnContext);
          if (result.error) {
            return createRejectedResult(tc.id, String(tc.name), result.error.message);
          }
          return createUnsentResult(tc.id, String(tc.name), result.result);
        });
        const settledResults = await Promise.allSettled(toolCallPromises);
        const results = [];
        for (let i = 0; i < settledResults.length; i++) {
          const settled = settledResults[i];
          const tc = toolCalls[i];
          if (!settled || !tc)
            continue;
          if (settled.status === "rejected") {
            const errorMessage = settled.reason instanceof Error ? settled.reason.message : String(settled.reason);
            results.push(createRejectedResult(tc.id, String(tc.name), errorMessage));
            continue;
          }
          if (settled.value) {
            results.push(settled.value);
          }
        }
        return results;
      }
      /**
       * Check for tools requiring approval and handle accordingly.
       * Partitions tool calls into those needing approval and those that can auto-execute.
       *
       * @param toolCalls - The tool calls to check
       * @param currentRound - The current execution round (1-indexed)
       * @param currentResponse - The current response to save if pausing
       * @returns True if execution should pause for approval, false to continue
       * @throws Error if approval is required but no state accessor is configured
       */
      async handleApprovalCheck(toolCalls, currentRound, currentResponse) {
        if (!this.options.tools)
          return false;
        const turnContext = { numberOfTurns: currentRound };
        const { requiresApproval: needsApproval, autoExecute } = await partitionToolCalls(toolCalls, this.options.tools, turnContext, this.requireApprovalFn ?? void 0);
        if (needsApproval.length === 0)
          return false;
        if (!this.stateAccessor) {
          const toolNames = needsApproval.map((tc) => tc.name).join(", ");
          throw new Error(`Tool(s) require approval but no state accessor is configured: ${toolNames}. Provide a StateAccessor via the "state" parameter to enable approval workflows.`);
        }
        const unsentResults = await this.executeAutoApproveTools(autoExecute, turnContext);
        const stateUpdates = {
          pendingToolCalls: needsApproval,
          status: "awaiting_approval"
        };
        if (unsentResults.length > 0) {
          stateUpdates.unsentToolResults = unsentResults;
        }
        await this.saveStateSafely(stateUpdates);
        this.finalResponse = currentResponse;
        return true;
      }
      /**
       * Execute all tools in a single round in parallel.
       * Emits tool.result events after tool execution completes.
       *
       * @param toolCalls - The tool calls to execute
       * @param turnContext - The current turn context
       * @returns Array of function call outputs formatted for the API
       */
      async executeToolRound(toolCalls, turnContext) {
        const toolCallPromises = toolCalls.map(async (toolCall) => {
          const tool = this.options.tools?.find((t) => t.function.name === toolCall.name);
          if (!tool || !hasExecuteFunction(tool)) {
            return null;
          }
          const args = toolCall.arguments;
          if (typeof args === "string") {
            const rawArgs = args;
            const errorMessage = `Failed to parse tool call arguments for "${toolCall.name}": The model provided invalid JSON. Raw arguments received: "${rawArgs}". Please provide valid JSON arguments for this tool call.`;
            if (this.toolEventBroadcaster) {
              this.toolEventBroadcaster.push({
                type: "tool_result",
                toolCallId: toolCall.id,
                result: { error: errorMessage }
              });
            }
            return {
              type: "parse_error",
              toolCall,
              output: {
                type: "function_call_output",
                id: `output_${toolCall.id}`,
                callId: toolCall.id,
                output: JSON.stringify({ error: errorMessage })
              }
            };
          }
          const preliminaryResultsForCall = [];
          const onPreliminaryResult = this.toolEventBroadcaster ? (callId, resultValue) => {
            const typedResult = resultValue;
            preliminaryResultsForCall.push(typedResult);
            this.toolEventBroadcaster?.push({
              type: "preliminary_result",
              toolCallId: callId,
              result: typedResult
            });
          } : void 0;
          const result = await executeTool(tool, toolCall, turnContext, onPreliminaryResult);
          return {
            type: "execution",
            toolCall,
            tool,
            result,
            preliminaryResultsForCall
          };
        });
        const settledResults = await Promise.allSettled(toolCallPromises);
        const toolResults = [];
        for (let i = 0; i < settledResults.length; i++) {
          const settled = settledResults[i];
          const originalToolCall = toolCalls[i];
          if (!settled || !originalToolCall)
            continue;
          if (settled.status === "rejected") {
            const errorMessage = settled.reason instanceof Error ? settled.reason.message : String(settled.reason);
            if (this.toolEventBroadcaster) {
              this.toolEventBroadcaster.push({
                type: "tool_result",
                toolCallId: originalToolCall.id,
                result: { error: errorMessage }
              });
            }
            toolResults.push({
              type: "function_call_output",
              id: `output_${originalToolCall.id}`,
              callId: originalToolCall.id,
              output: JSON.stringify({ error: errorMessage })
            });
            continue;
          }
          const value = settled.value;
          if (!value)
            continue;
          if (value.type === "parse_error") {
            toolResults.push(value.output);
            continue;
          }
          if (this.toolEventBroadcaster) {
            this.toolEventBroadcaster.push({
              type: "tool_result",
              toolCallId: value.toolCall.id,
              result: value.result.error ? { error: value.result.error.message } : value.result.result,
              ...value.preliminaryResultsForCall.length > 0 && {
                preliminaryResults: value.preliminaryResultsForCall
              }
            });
          }
          toolResults.push({
            type: "function_call_output",
            id: `output_${value.toolCall.id}`,
            callId: value.toolCall.id,
            output: value.result.error ? JSON.stringify({ error: value.result.error.message }) : JSON.stringify(value.result.result)
          });
        }
        return toolResults;
      }
      /**
       * Resolve async functions for the current turn.
       * Updates the resolved request with turn-specific parameter values.
       *
       * @param turnContext - The turn context for parameter resolution
       */
      async resolveAsyncFunctionsForTurn(turnContext) {
        if (hasAsyncFunctions(this.options.request)) {
          const resolved = await resolveAsyncFunctions(this.options.request, turnContext);
          const preservedInput = this.resolvedRequest?.input;
          this.resolvedRequest = {
            ...resolved,
            stream: false,
            ...preservedInput !== void 0 && { input: preservedInput }
          };
        }
      }
      /**
       * Apply nextTurnParams from executed tools.
       * Allows tools to modify request parameters for subsequent turns.
       *
       * @param toolCalls - The tool calls that were just executed
       */
      async applyNextTurnParams(toolCalls) {
        if (!this.options.tools || toolCalls.length === 0 || !this.resolvedRequest) {
          return;
        }
        const computedParams = await executeNextTurnParamsFunctions(toolCalls, this.options.tools, this.resolvedRequest);
        if (Object.keys(computedParams).length > 0) {
          this.resolvedRequest = applyNextTurnParamsToRequest(this.resolvedRequest, computedParams);
        }
      }
      /**
       * Make a follow-up API request with tool results.
       * Continues the conversation after tool execution.
       *
       * @param currentResponse - The response that contained tool calls
       * @param toolResults - The results from executing those tools
       * @returns The new response from the API
       */
      async makeFollowupRequest(currentResponse, toolResults) {
        const originalInput = this.resolvedRequest?.input;
        const normalizedOriginalInput = Array.isArray(originalInput) ? originalInput : originalInput ? [{ role: "user", content: originalInput }] : [];
        const newInput = [
          ...normalizedOriginalInput,
          ...Array.isArray(currentResponse.output) ? currentResponse.output : [currentResponse.output],
          ...toolResults
        ];
        if (!this.resolvedRequest) {
          throw new Error("Request not initialized");
        }
        this.resolvedRequest = {
          ...this.resolvedRequest,
          input: newInput
        };
        const newRequest = {
          ...this.resolvedRequest,
          stream: false
        };
        const newResult = await betaResponsesSend(this.options.client, { openResponsesRequest: newRequest }, this.options.options);
        if (!newResult.ok) {
          throw newResult.error;
        }
        const value = newResult.value;
        if (isEventStream(value)) {
          const stream = new ReusableReadableStream(value);
          return consumeStreamForCompletion(stream);
        } else if (this.isNonStreamingResponse(value)) {
          return value;
        } else {
          throw new Error("Unexpected response type from API");
        }
      }
      /**
       * Validate the final response has required fields.
       *
       * @param response - The response to validate
       * @throws Error if response is missing required fields or has invalid output
       */
      validateFinalResponse(response) {
        if (!response?.id || !response?.output) {
          throw new Error("Invalid final response: missing required fields");
        }
        if (!Array.isArray(response.output) || response.output.length === 0) {
          throw new Error("Invalid final response: empty or invalid output");
        }
      }
      /**
       * Resolve async functions in the request for a given turn context.
       * Extracts non-function fields and resolves any async parameter functions.
       *
       * @param context - The turn context for parameter resolution
       * @returns The resolved request without async functions
       */
      async resolveRequestForContext(context) {
        if (hasAsyncFunctions(this.options.request)) {
          return resolveAsyncFunctions(this.options.request, context);
        }
        const { stopWhen: _, state: _s, requireApproval: _r, approveToolCalls: _a3, rejectToolCalls: _rj, ...rest } = this.options.request;
        return rest;
      }
      /**
       * Safely persist state with error handling.
       * Wraps state save operations to ensure failures are properly reported.
       *
       * @param updates - Optional partial state updates to apply before saving
       * @throws Error if state persistence fails
       */
      async saveStateSafely(updates) {
        if (!this.stateAccessor || !this.currentState)
          return;
        if (updates) {
          this.currentState = updateState(this.currentState, updates);
        }
        try {
          await this.stateAccessor.save(this.currentState);
        } catch (error48) {
          const message = error48 instanceof Error ? error48.message : String(error48);
          throw new Error(`Failed to persist conversation state: ${message}`);
        }
      }
      /**
       * Remove optional properties from state when they should be cleared.
       * Uses delete to properly remove optional properties rather than setting undefined.
       *
       * @param props - Array of property names to remove from current state
       */
      clearOptionalStateProperties(props) {
        if (!this.currentState)
          return;
        for (const prop of props) {
          delete this.currentState[prop];
        }
      }
      // =========================================================================
      // Core Methods
      // =========================================================================
      /**
       * Initialize the stream if not already started
       * This is idempotent - multiple calls will return the same promise
       */
      initStream() {
        if (this.initPromise) {
          return this.initPromise;
        }
        this.initPromise = (async () => {
          if (this.stateAccessor) {
            const loadedState = await this.stateAccessor.load();
            if (loadedState) {
              this.currentState = loadedState;
              if (loadedState.status === "awaiting_approval" && (this.approvedToolCalls.length > 0 || this.rejectedToolCalls.length > 0)) {
                this.isResumingFromApproval = true;
                await this.processApprovalDecisions();
                return;
              }
              if (loadedState.interruptedBy) {
                this.currentState = updateState(loadedState, { status: "in_progress" });
                this.clearOptionalStateProperties(["interruptedBy"]);
                await this.saveStateSafely();
              }
            } else {
              this.currentState = createInitialState();
            }
            await this.saveStateSafely({ status: "in_progress" });
          }
          const initialContext = {
            numberOfTurns: 0
          };
          let baseRequest = await this.resolveRequestForContext(initialContext);
          if (this.currentState && this.currentState.messages && Array.isArray(this.currentState.messages) && this.currentState.messages.length > 0) {
            const newInput = baseRequest.input;
            if (newInput) {
              const inputArray = Array.isArray(newInput) ? newInput : [newInput];
              baseRequest = {
                ...baseRequest,
                input: appendToMessages(this.currentState.messages, inputArray)
              };
            } else {
              baseRequest = {
                ...baseRequest,
                input: this.currentState.messages
              };
            }
          }
          this.resolvedRequest = {
            ...baseRequest,
            stream: true
          };
          const request = this.resolvedRequest;
          const apiResult = await betaResponsesSend(this.options.client, { openResponsesRequest: request }, this.options.options);
          if (!apiResult.ok) {
            throw apiResult.error;
          }
          if (isEventStream(apiResult.value)) {
            this.reusableStream = new ReusableReadableStream(apiResult.value);
          } else if (this.isNonStreamingResponse(apiResult.value)) {
            this.finalResponse = apiResult.value;
          } else {
            throw new Error("Unexpected response type from API");
          }
        })();
        return this.initPromise;
      }
      /**
       * Process approval/rejection decisions and resume execution
       */
      async processApprovalDecisions() {
        if (!this.currentState || !this.stateAccessor) {
          throw new Error("Cannot process approval decisions without state");
        }
        const pendingCalls = this.currentState.pendingToolCalls ?? [];
        const unsentResults = [...this.currentState.unsentToolResults ?? []];
        const turnContext = {
          numberOfTurns: this.allToolExecutionRounds.length + 1
        };
        for (const callId of this.approvedToolCalls) {
          const toolCall = pendingCalls.find((tc) => tc.id === callId);
          if (!toolCall)
            continue;
          const tool = this.options.tools?.find((t) => t.function.name === toolCall.name);
          if (!tool || !hasExecuteFunction(tool)) {
            unsentResults.push(createRejectedResult(callId, String(toolCall.name), "Tool not found or not executable"));
            continue;
          }
          const result = await executeTool(tool, toolCall, turnContext);
          if (result.error) {
            unsentResults.push(createRejectedResult(callId, String(toolCall.name), result.error.message));
          } else {
            unsentResults.push(createUnsentResult(callId, String(toolCall.name), result.result));
          }
        }
        for (const callId of this.rejectedToolCalls) {
          const toolCall = pendingCalls.find((tc) => tc.id === callId);
          if (!toolCall)
            continue;
          unsentResults.push(createRejectedResult(callId, String(toolCall.name), "Rejected by user"));
        }
        const processedIds = /* @__PURE__ */ new Set([...this.approvedToolCalls, ...this.rejectedToolCalls]);
        const remainingPending = pendingCalls.filter((tc) => !processedIds.has(tc.id));
        const stateUpdates = {
          status: remainingPending.length > 0 ? "awaiting_approval" : "in_progress"
        };
        if (remainingPending.length > 0) {
          stateUpdates.pendingToolCalls = remainingPending;
        }
        if (unsentResults.length > 0) {
          stateUpdates.unsentToolResults = unsentResults;
        }
        await this.saveStateSafely(stateUpdates);
        const propsToClear = [];
        if (remainingPending.length === 0)
          propsToClear.push("pendingToolCalls");
        if (unsentResults.length === 0)
          propsToClear.push("unsentToolResults");
        if (propsToClear.length > 0) {
          this.clearOptionalStateProperties(propsToClear);
          await this.saveStateSafely();
        }
        if (remainingPending.length > 0) {
          return;
        }
        await this.continueWithUnsentResults();
      }
      /**
       * Continue execution with unsent tool results
       */
      async continueWithUnsentResults() {
        if (!this.currentState || !this.stateAccessor)
          return;
        const unsentResults = this.currentState.unsentToolResults ?? [];
        if (unsentResults.length === 0)
          return;
        const toolOutputs = unsentResultsToAPIFormat(unsentResults);
        const currentMessages = this.currentState.messages;
        const newInput = appendToMessages(currentMessages, toolOutputs);
        this.currentState = updateState(this.currentState, {
          messages: newInput
        });
        this.clearOptionalStateProperties(["unsentToolResults"]);
        await this.saveStateSafely();
        const turnContext = {
          numberOfTurns: this.allToolExecutionRounds.length + 1
        };
        const baseRequest = await this.resolveRequestForContext(turnContext);
        const request = {
          ...baseRequest,
          input: newInput,
          stream: true
        };
        this.resolvedRequest = request;
        const apiResult = await betaResponsesSend(this.options.client, { openResponsesRequest: request }, this.options.options);
        if (!apiResult.ok) {
          throw apiResult.error;
        }
        if (isEventStream(apiResult.value)) {
          this.reusableStream = new ReusableReadableStream(apiResult.value);
        } else if (this.isNonStreamingResponse(apiResult.value)) {
          this.finalResponse = apiResult.value;
        } else {
          throw new Error("Unexpected response type from API");
        }
      }
      /**
       * Execute tools automatically if they are provided and have execute functions
       * This is idempotent - multiple calls will return the same promise
       */
      async executeToolsIfNeeded() {
        if (this.toolExecutionPromise) {
          return this.toolExecutionPromise;
        }
        this.toolExecutionPromise = (async () => {
          await this.initStream();
          if (this.isResumingFromApproval && this.currentState?.status === "awaiting_approval") {
            return;
          }
          let currentResponse = await this.getInitialResponse();
          await this.saveResponseToState(currentResponse);
          const hasToolCalls = currentResponse.output.some((item) => hasTypeProperty(item) && item.type === "function_call");
          if (!this.options.tools?.length || !hasToolCalls) {
            this.finalResponse = currentResponse;
            await this.markStateComplete();
            return;
          }
          const toolCalls = extractToolCallsFromResponse(currentResponse);
          if (await this.handleApprovalCheck(toolCalls, 0, currentResponse)) {
            return;
          }
          if (!this.hasExecutableToolCalls(toolCalls)) {
            this.finalResponse = currentResponse;
            await this.markStateComplete();
            return;
          }
          let currentRound = 0;
          while (true) {
            if (await this.checkForInterruption(currentResponse)) {
              return;
            }
            if (await this.shouldStopExecution()) {
              break;
            }
            const currentToolCalls = extractToolCallsFromResponse(currentResponse);
            if (currentToolCalls.length === 0) {
              break;
            }
            if (await this.handleApprovalCheck(currentToolCalls, currentRound + 1, currentResponse)) {
              return;
            }
            if (!this.hasExecutableToolCalls(currentToolCalls)) {
              break;
            }
            const turnContext = { numberOfTurns: currentRound + 1 };
            await this.resolveAsyncFunctionsForTurn(turnContext);
            const toolResults = await this.executeToolRound(currentToolCalls, turnContext);
            this.allToolExecutionRounds.push({
              round: currentRound,
              toolCalls: currentToolCalls,
              response: currentResponse,
              toolResults
            });
            await this.saveToolResultsToState(toolResults);
            await this.applyNextTurnParams(currentToolCalls);
            currentResponse = await this.makeFollowupRequest(currentResponse, toolResults);
            await this.saveResponseToState(currentResponse);
            currentRound++;
          }
          this.validateFinalResponse(currentResponse);
          this.finalResponse = currentResponse;
          await this.markStateComplete();
        })();
        return this.toolExecutionPromise;
      }
      /**
       * Internal helper to get the text after tool execution
       */
      async getTextInternal() {
        await this.executeToolsIfNeeded();
        if (!this.finalResponse) {
          throw new Error("Response not available");
        }
        return extractTextFromResponse(this.finalResponse);
      }
      /**
       * Get just the text content from the response.
       * This will consume the stream until completion, execute any tools, and extract the text.
       */
      getText() {
        if (this.textPromise) {
          return this.textPromise;
        }
        this.textPromise = this.getTextInternal();
        return this.textPromise;
      }
      /**
       * Get the complete response object including usage information.
       * This will consume the stream until completion and execute any tools.
       * Returns the full OpenResponsesNonStreamingResponse with usage data (inputTokens, outputTokens, cachedTokens, etc.)
       */
      async getResponse() {
        await this.executeToolsIfNeeded();
        if (!this.finalResponse) {
          throw new Error("Response not available");
        }
        return this.finalResponse;
      }
      /**
       * Stream all response events as they arrive.
       * Multiple consumers can iterate over this stream concurrently.
       * Preliminary tool results and tool results are streamed in REAL-TIME as generator tools yield.
       */
      getFullResponsesStream() {
        return async function* () {
          await this.initStream();
          if (!this.reusableStream) {
            throw new Error("Stream not initialized");
          }
          const broadcaster = this.ensureBroadcaster();
          const toolEventConsumer = broadcaster.createConsumer();
          const executionPromise = this.executeToolsIfNeeded().finally(() => {
            broadcaster.complete();
          });
          const consumer = this.reusableStream.createConsumer();
          for await (const event of consumer) {
            yield event;
          }
          for await (const event of toolEventConsumer) {
            if (event.type === "preliminary_result") {
              yield {
                type: "tool.preliminary_result",
                toolCallId: event.toolCallId,
                result: event.result,
                timestamp: Date.now()
              };
            } else if (event.type === "tool_result") {
              yield {
                type: "tool.result",
                toolCallId: event.toolCallId,
                result: event.result,
                timestamp: Date.now(),
                ...event.preliminaryResults && { preliminaryResults: event.preliminaryResults }
              };
            }
          }
          await executionPromise;
        }.call(this);
      }
      /**
       * Stream only text deltas as they arrive.
       * This filters the full event stream to only yield text content.
       */
      getTextStream() {
        return async function* () {
          await this.initStream();
          if (!this.reusableStream) {
            throw new Error("Stream not initialized");
          }
          yield* extractTextDeltas(this.reusableStream);
        }.call(this);
      }
      /**
       * Stream all output items cumulatively as they arrive.
       * Items are emitted with the same ID but progressively updated content as streaming progresses.
       * Also yields tool results (function_call_output) after tool execution completes.
       *
       * Item types include:
       * - message: Assistant text responses (emitted cumulatively as text streams)
       * - function_call: Tool calls (emitted cumulatively as arguments stream)
       * - reasoning: Model reasoning (emitted cumulatively as thinking streams)
       * - web_search_call: Web search operations
       * - file_search_call: File search operations
       * - image_generation_call: Image generation operations
       * - function_call_output: Results from executed tools
       */
      getItemsStream() {
        return async function* () {
          await this.initStream();
          if (!this.reusableStream) {
            throw new Error("Stream not initialized");
          }
          yield* buildItemsStream(this.reusableStream);
          await this.executeToolsIfNeeded();
          for (const round of this.allToolExecutionRounds) {
            if (round.round > 0) {
              for (const item of round.response.output) {
                if (isFunctionCallItem(item)) {
                  yield item;
                }
              }
            }
            for (const toolResult of round.toolResults) {
              yield toolResult;
            }
          }
          if (this.finalResponse && this.allToolExecutionRounds.length > 0) {
            for (const item of this.finalResponse.output) {
              if (isOutputMessage(item) || isFunctionCallItem(item) || isReasoningOutputItem(item) || isWebSearchCallOutputItem(item) || isFileSearchCallOutputItem(item) || isImageGenerationCallOutputItem(item)) {
                yield item;
              }
            }
          }
        }.call(this);
      }
      /**
       * @deprecated Use `getItemsStream()` instead. This method only streams messages,
       * while `getItemsStream()` streams all output item types (messages, function_calls,
       * reasoning, etc.) with cumulative updates.
       *
       * Stream incremental message updates as content is added in responses format.
       * Each iteration yields an updated version of the message with new content.
       * Also yields function_call items and OpenResponsesFunctionCallOutput after tool execution completes.
       * Returns ResponsesOutputMessage, ResponsesOutputItemFunctionCall, or OpenResponsesFunctionCallOutput
       * compatible with OpenAI Responses API format.
       */
      getNewMessagesStream() {
        return async function* () {
          await this.initStream();
          if (!this.reusableStream) {
            throw new Error("Stream not initialized");
          }
          yield* buildResponsesMessageStream(this.reusableStream);
          await this.executeToolsIfNeeded();
          for (const round of this.allToolExecutionRounds) {
            for (const item of round.response.output) {
              if (isFunctionCallItem(item)) {
                yield item;
              }
            }
            for (const toolResult of round.toolResults) {
              yield toolResult;
            }
          }
          if (this.finalResponse && this.allToolExecutionRounds.length > 0) {
            const hasMessage = this.finalResponse.output.some((item) => hasTypeProperty(item) && item.type === "message");
            if (hasMessage) {
              yield extractResponsesMessageFromResponse(this.finalResponse);
            }
          }
        }.call(this);
      }
      /**
       * Stream only reasoning deltas as they arrive.
       * This filters the full event stream to only yield reasoning content.
       */
      getReasoningStream() {
        return async function* () {
          await this.initStream();
          if (!this.reusableStream) {
            throw new Error("Stream not initialized");
          }
          yield* extractReasoningDeltas(this.reusableStream);
        }.call(this);
      }
      /**
       * Stream tool call argument deltas and preliminary results.
       * Preliminary results are streamed in REAL-TIME as generator tools yield.
       * - Tool call argument deltas as { type: "delta", content: string }
       * - Preliminary results as { type: "preliminary_result", toolCallId, result }
       */
      getToolStream() {
        return async function* () {
          await this.initStream();
          if (!this.reusableStream) {
            throw new Error("Stream not initialized");
          }
          const broadcaster = this.ensureBroadcaster();
          const toolEventConsumer = broadcaster.createConsumer();
          const executionPromise = this.executeToolsIfNeeded().finally(() => {
            broadcaster.complete();
          });
          for await (const delta of extractToolDeltas(this.reusableStream)) {
            yield {
              type: "delta",
              content: delta
            };
          }
          for await (const event of toolEventConsumer) {
            if (event.type === "preliminary_result") {
              yield event;
            }
          }
          await executionPromise;
        }.call(this);
      }
      /**
       * Get all tool calls from the completed response (before auto-execution).
       * Note: If tools have execute functions, they will be automatically executed
       * and this will return the tool calls from the initial response.
       * Returns structured tool calls with parsed arguments.
       */
      async getToolCalls() {
        await this.initStream();
        if (this.finalResponse) {
          return extractToolCallsFromResponse(this.finalResponse);
        }
        if (!this.reusableStream) {
          throw new Error("Stream not initialized");
        }
        const completedResponse = await consumeStreamForCompletion(this.reusableStream);
        return extractToolCallsFromResponse(completedResponse);
      }
      /**
       * Stream structured tool call objects as they're completed.
       * Each iteration yields a complete tool call with parsed arguments.
       */
      getToolCallsStream() {
        return async function* () {
          await this.initStream();
          if (!this.reusableStream) {
            throw new Error("Stream not initialized");
          }
          yield* buildToolCallStream(this.reusableStream);
        }.call(this);
      }
      /**
       * Cancel the underlying stream and all consumers
       */
      async cancel() {
        if (this.reusableStream) {
          await this.reusableStream.cancel();
        }
      }
      // =========================================================================
      // Multi-Turn Conversation State Methods
      // =========================================================================
      /**
       * Check if the conversation requires human approval to continue.
       * Returns true if there are pending tool calls awaiting approval.
       */
      async requiresApproval() {
        await this.initStream();
        if (this.currentState?.status === "awaiting_approval") {
          return true;
        }
        return (this.currentState?.pendingToolCalls?.length ?? 0) > 0;
      }
      /**
       * Get the pending tool calls that require approval.
       * Returns empty array if no approvals needed.
       */
      async getPendingToolCalls() {
        await this.initStream();
        if (!this.isResumingFromApproval) {
          await this.executeToolsIfNeeded();
        }
        return this.currentState?.pendingToolCalls ?? [];
      }
      /**
       * Get the current conversation state.
       * Useful for inspection, debugging, or custom persistence.
       * Note: This returns the raw ConversationState for inspection only.
       * To resume a conversation, use the StateAccessor pattern.
       */
      async getState() {
        await this.initStream();
        if (!this.isResumingFromApproval) {
          await this.executeToolsIfNeeded();
        }
        if (!this.currentState) {
          throw new Error("State not initialized. Make sure a StateAccessor was provided to callModel.");
        }
        return this.currentState;
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/funcs/call-model.js
function callModel(client, request, options) {
  const { tools, stopWhen, state, requireApproval, approveToolCalls, rejectToolCalls, ...apiRequest } = request;
  const apiTools = tools ? convertToolsToAPIFormat(tools) : void 0;
  const finalRequest = {
    ...apiRequest
  };
  if (apiTools !== void 0) {
    finalRequest["tools"] = apiTools;
  }
  return new ModelResult({
    client,
    request: finalRequest,
    options: options ?? {},
    tools,
    ...stopWhen !== void 0 && { stopWhen },
    // Pass state management options
    ...state !== void 0 && { state },
    ...requireApproval !== void 0 && { requireApproval },
    ...approveToolCalls !== void 0 && { approveToolCalls },
    ...rejectToolCalls !== void 0 && { rejectToolCalls }
  });
}
var init_call_model = __esm({
  "node_modules/@openrouter/sdk/esm/funcs/call-model.js"() {
    init_model_result();
    init_tool_executor();
  }
});

// node_modules/@openrouter/sdk/esm/sdk/sdk.js
var OpenRouter;
var init_sdk = __esm({
  "node_modules/@openrouter/sdk/esm/sdk/sdk.js"() {
    init_sdks();
    init_analytics();
    init_apikeys();
    init_beta();
    init_chat();
    init_credits();
    init_embeddings();
    init_endpoints();
    init_generations();
    init_guardrails();
    init_models2();
    init_oauth();
    init_providers();
    init_call_model();
    OpenRouter = class extends ClientSDK {
      get beta() {
        return this._beta ?? (this._beta = new Beta(this._options));
      }
      get analytics() {
        return this._analytics ?? (this._analytics = new Analytics(this._options));
      }
      get credits() {
        return this._credits ?? (this._credits = new Credits(this._options));
      }
      get embeddings() {
        return this._embeddings ?? (this._embeddings = new Embeddings(this._options));
      }
      get generations() {
        return this._generations ?? (this._generations = new Generations(this._options));
      }
      get models() {
        return this._models ?? (this._models = new Models(this._options));
      }
      get endpoints() {
        return this._endpoints ?? (this._endpoints = new Endpoints(this._options));
      }
      get providers() {
        return this._providers ?? (this._providers = new Providers(this._options));
      }
      get apiKeys() {
        return this._apiKeys ?? (this._apiKeys = new APIKeys(this._options));
      }
      get guardrails() {
        return this._guardrails ?? (this._guardrails = new Guardrails(this._options));
      }
      get oAuth() {
        return this._oAuth ?? (this._oAuth = new OAuth(this._options));
      }
      get chat() {
        return this._chat ?? (this._chat = new Chat(this._options));
      }
      // #region sdk-class-body
      callModel(request, options) {
        return callModel(this, request, options);
      }
    };
  }
});

// node_modules/@openrouter/sdk/esm/index.js
var init_esm = __esm({
  "node_modules/@openrouter/sdk/esm/index.js"() {
    init_config();
    init_files();
    init_tool_types();
    init_sdk();
  }
});

// src/lib/request-context.ts
var import_node_async_hooks, RequestContext, requestContext;
var init_request_context = __esm({
  "src/lib/request-context.ts"() {
    "use strict";
    import_node_async_hooks = require("node:async_hooks");
    RequestContext = class {
      constructor() {
        this.storage = new import_node_async_hooks.AsyncLocalStorage();
      }
      /**
       * Run a callback with request context attached.
       * All async operations within the callback will have access to this context.
       */
      run(ctx, fn) {
        return this.storage.run(ctx, fn);
      }
      /** Get the current request context, or null if not in a request scope. */
      get() {
        return this.storage.getStore() ?? null;
      }
    };
    requestContext = new RequestContext();
  }
});

// src/lib/logger.ts
function serializeError(err) {
  if (err instanceof Error) {
    return {
      message: err.message,
      name: err.name,
      ...err.stack ? { stack: err.stack } : {},
      ...err.cause ? { cause: serializeError(err.cause) } : {}
    };
  }
  return { message: String(err) };
}
function normalizeContext(ctx) {
  if (!ctx) return void 0;
  const normalized = {};
  for (const [key, value] of Object.entries(ctx)) {
    if (key === "error" || key === "err") {
      normalized.error = serializeError(value);
    } else {
      normalized[key] = value;
    }
  }
  return normalized;
}
function writeJson(level, msg, bindings, ctx) {
  const entry = {
    level,
    time: (/* @__PURE__ */ new Date()).toISOString(),
    msg,
    ...bindings,
    ...ctx ?? {}
  };
  const reqCtx = requestContext.get();
  if (reqCtx) {
    entry.request_id = reqCtx.requestId;
    if (reqCtx.method) entry.http_method = reqCtx.method;
    if (reqCtx.path) entry.http_path = reqCtx.path;
  }
  process.stderr.write(JSON.stringify(entry) + "\n");
}
function writePretty(level, msg, bindings, ctx) {
  const color = LEVEL_COLORS[level];
  const time3 = (/* @__PURE__ */ new Date()).toISOString().slice(11, 23);
  const tag = level.toUpperCase().padEnd(5);
  const bindingStr = Object.keys(bindings).length > 0 ? ` ${DIM}${formatBindings(bindings)}${RESET}` : "";
  let line = `${DIM}${time3}${RESET} ${color}${tag}${RESET}${bindingStr} ${msg}`;
  if (ctx && Object.keys(ctx).length > 0) {
    const ctxStr = formatContext(ctx);
    if (ctxStr) {
      line += ` ${DIM}${ctxStr}${RESET}`;
    }
  }
  const reqCtx = requestContext.get();
  if (reqCtx) {
    line += ` ${DIM}[${reqCtx.requestId.slice(0, 8)}]${RESET}`;
  }
  process.stderr.write(line + "\n");
}
function formatBindings(bindings) {
  return Object.entries(bindings).map(([k, v]) => `${k}=${String(v)}`).join(" ");
}
function formatContext(ctx) {
  const parts = [];
  for (const [key, value] of Object.entries(ctx)) {
    if (key === "error" && typeof value === "object" && value !== null) {
      const err = value;
      parts.push(`error=${err.message ?? String(value)}`);
      if (err.stack && typeof err.stack === "string") {
        const firstFrame = err.stack.split("\n")[1]?.trim();
        if (firstFrame) parts.push(`  at ${firstFrame}`);
      }
    } else if (typeof value === "object" && value !== null) {
      try {
        parts.push(`${key}=${JSON.stringify(value)}`);
      } catch {
        parts.push(`${key}=[circular]`);
      }
    } else {
      parts.push(`${key}=${String(value)}`);
    }
  }
  return parts.join(" ");
}
function createLoggerInternal(bindings) {
  const write = IS_PRODUCTION ? writeJson : writePretty;
  function log31(level, msg, ctx) {
    if (LEVEL_VALUES[level] < MIN_LEVEL) return;
    write(level, msg, bindings, normalizeContext(ctx));
  }
  return {
    debug: (msg, ctx) => log31("debug", msg, ctx),
    info: (msg, ctx) => log31("info", msg, ctx),
    warn: (msg, ctx) => log31("warn", msg, ctx),
    error: (msg, ctx) => log31("error", msg, ctx),
    fatal: (msg, ctx) => log31("fatal", msg, ctx),
    child: (childBindings) => createLoggerInternal({ ...bindings, ...childBindings })
  };
}
function createLogger(bindings = {}) {
  return createLoggerInternal(bindings);
}
var LEVEL_VALUES, LEVEL_COLORS, RESET, DIM, IS_PRODUCTION, LOG_LEVEL, MIN_LEVEL, logger;
var init_logger = __esm({
  "src/lib/logger.ts"() {
    "use strict";
    init_request_context();
    LEVEL_VALUES = {
      debug: 10,
      info: 20,
      warn: 30,
      error: 40,
      fatal: 50
    };
    LEVEL_COLORS = {
      debug: "\x1B[90m",
      // gray
      info: "\x1B[36m",
      // cyan
      warn: "\x1B[33m",
      // yellow
      error: "\x1B[31m",
      // red
      fatal: "\x1B[35m"
      // magenta
    };
    RESET = "\x1B[0m";
    DIM = "\x1B[2m";
    IS_PRODUCTION = process.env.NODE_ENV === "production";
    LOG_LEVEL = process.env.LOG_LEVEL ?? (IS_PRODUCTION ? "info" : "debug");
    MIN_LEVEL = LEVEL_VALUES[LOG_LEVEL] ?? LEVEL_VALUES.info;
    logger = createLoggerInternal({ service: "subcult" });
  }
});

// src/lib/llm/model-routing.ts
async function syncEnvToDb() {
  if (envSynced) return;
  envSynced = true;
  const entries = [];
  for (const [key, value] of Object.entries(process.env)) {
    if (!key.startsWith(ENV_PREFIX) || !value) continue;
    const rawContext = key.slice(ENV_PREFIX.length);
    if (!rawContext) continue;
    const context = rawContext.toLowerCase().replace(/__/g, ":");
    const models = value.split(",").map((m) => m.trim()).filter(Boolean);
    if (models.length > 0) {
      entries.push({ context, models });
    }
  }
  if (entries.length === 0) return;
  for (const { context, models } of entries) {
    try {
      await sql`
                INSERT INTO ops_model_routing (context, models, description, updated_at)
                VALUES (${context}, ${models}, ${"Set via MODEL_ROUTING env var"}, NOW())
                ON CONFLICT (context) DO UPDATE SET
                    models = EXCLUDED.models,
                    description = EXCLUDED.description,
                    updated_at = NOW()
            `;
      cache.delete(context);
      logger.info("Model routing updated from env", { context, models });
    } catch (error48) {
      logger.error("Failed to sync model routing env var", { context, models, error: error48 });
    }
  }
}
function normalizeContext2(context) {
  return context.replace(/-/g, "_");
}
async function resolveModels(context) {
  await syncEnvToDb();
  if (!context) {
    return await lookupOrDefault("default");
  }
  const normalized = normalizeContext2(context);
  const exact = await lookupCached(normalized);
  if (exact) return exact;
  const colonIdx = normalized.indexOf(":");
  if (colonIdx > 0) {
    const prefix = normalized.slice(0, colonIdx);
    const prefixResult = await lookupCached(prefix);
    if (prefixResult) return prefixResult;
  }
  return await lookupOrDefault("default");
}
async function lookupCached(context) {
  const cached2 = cache.get(context);
  if (cached2 && Date.now() - cached2.ts < CACHE_TTL_MS) {
    return cached2.models.length > 0 ? cached2.models : null;
  }
  try {
    const [row] = await sql`
            SELECT models FROM ops_model_routing WHERE context = ${context}
        `;
    if (!row || !row.models || row.models.length === 0) {
      cache.set(context, { models: [], ts: Date.now() });
      return null;
    }
    cache.set(context, { models: row.models, ts: Date.now() });
    return row.models;
  } catch (error48) {
    logger.error(
      "resolveModels: failed to query ops_model_routing; falling back to default models",
      { error: error48, context }
    );
    cache.set(context, { models: [], ts: Date.now() });
    return null;
  }
}
async function lookupOrDefault(context) {
  const result = await lookupCached(context);
  return result ?? DEFAULT_MODELS;
}
var DEFAULT_MODELS, ENV_PREFIX, CACHE_TTL_MS, cache, envSynced;
var init_model_routing = __esm({
  "src/lib/llm/model-routing.ts"() {
    "use strict";
    init_db();
    init_logger();
    DEFAULT_MODELS = [
      "openai/gpt-oss-120b",
      // fast, cheap ($0.10/M), strong general-purpose
      "deepseek/deepseek-v3.2",
      // fast, cheap ($0.14/M avg), good tool calling
      "google/gemini-2.5-flash",
      // fast, cheap ($0.15/M avg), 1M context
      "qwen/qwen3-235b-a22b",
      // good quality, cheap ($0.14/M avg)
      "moonshotai/kimi-k2.5",
      // strong reasoning, moderate cost ($0.60/M avg)
      "anthropic/claude-haiku-4.5",
      // reliable, moderate cost ($1/$5)
      "anthropic/claude-sonnet-4.5"
      // last resort — highest quality, highest cost
    ];
    ENV_PREFIX = "MODEL_ROUTING_";
    CACHE_TTL_MS = 3e4;
    cache = /* @__PURE__ */ new Map();
    envSynced = false;
  }
});

// src/lib/llm/client.ts
var client_exports = {};
__export(client_exports, {
  extractFromXml: () => extractFromXml,
  getOpenRouterClient: () => getClient,
  llmGenerate: () => llmGenerate,
  llmGenerateWithTools: () => llmGenerateWithTools,
  sanitizeDialogue: () => sanitizeDialogue
});
function normalizeModel(id) {
  if (id === "openrouter/auto") return id;
  if (id.startsWith("openrouter/")) return id.slice("openrouter/".length);
  return id;
}
async function resolveModelsWithEnv(context) {
  const models = await resolveModels(context);
  if (!LLM_MODEL_ENV) return models;
  return [
    LLM_MODEL_ENV,
    ...models.filter((m) => m !== LLM_MODEL_ENV)
  ];
}
function getClient() {
  if (!_client) {
    if (!OPENROUTER_API_KEY) {
      throw new Error(
        "Missing OPENROUTER_API_KEY environment variable. Set it in .env.local"
      );
    }
    _client = new OpenRouter({ apiKey: OPENROUTER_API_KEY });
  }
  return _client;
}
function getOllamaModels() {
  const models = [];
  if (OLLAMA_API_KEY) {
    models.push(
      {
        model: "deepseek-v3.2:cloud",
        baseUrl: OLLAMA_CLOUD_URL,
        apiKey: OLLAMA_API_KEY
      },
      {
        model: "kimi-k2.5:cloud",
        baseUrl: OLLAMA_CLOUD_URL,
        apiKey: OLLAMA_API_KEY
      },
      {
        model: "gemini-3-flash-preview:latest",
        baseUrl: OLLAMA_CLOUD_URL,
        apiKey: OLLAMA_API_KEY
      }
    );
  }
  if (OLLAMA_LOCAL_URL) {
    models.push(
      { model: "qwen3-coder:30b", baseUrl: OLLAMA_LOCAL_URL },
      { model: "llama3.2:latest", baseUrl: OLLAMA_LOCAL_URL }
    );
  }
  return models;
}
function stripThinking(text2) {
  return text2.replace(/<think>[\s\S]*?<\/think>/g, "").trim();
}
async function ollamaChat(messages, temperature, options) {
  const models = getOllamaModels();
  if (models.length === 0) return null;
  const maxTokens = options?.maxTokens ?? 250;
  const tools = options?.tools;
  const maxToolRounds = options?.maxToolRounds ?? 3;
  const openaiTools = tools && tools.length > 0 ? tools.map((t) => ({
    type: "function",
    function: {
      name: t.name,
      description: t.description,
      parameters: t.parameters
    }
  })) : void 0;
  for (const spec of models) {
    const result = await ollamaChatWithModel(
      spec,
      messages,
      temperature,
      maxTokens,
      tools,
      openaiTools,
      maxToolRounds
    );
    if (result) return result;
  }
  return null;
}
async function ollamaChatWithModel(spec, messages, temperature, maxTokens, tools, openaiTools, maxToolRounds) {
  const { model, baseUrl, apiKey } = spec;
  const toolCallRecords = [];
  const headers = {
    "Content-Type": "application/json"
  };
  if (apiKey) headers["Authorization"] = `Bearer ${apiKey}`;
  const workingMessages = messages.map((m) => ({
    role: m.role,
    content: m.content
  }));
  for (let round = 0; round <= maxToolRounds; round++) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(
        () => controller.abort(),
        OLLAMA_TIMEOUT_MS
      );
      const body = {
        model,
        messages: workingMessages,
        temperature,
        max_tokens: maxTokens
      };
      if (openaiTools && round < maxToolRounds) {
        body.tools = openaiTools;
      }
      const response = await fetch(`${baseUrl}/v1/chat/completions`, {
        method: "POST",
        headers,
        body: JSON.stringify(body),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        log.debug("Ollama model failed", {
          model,
          baseUrl,
          status: response.status
        });
        return null;
      }
      const data = await response.json();
      const msg = data.choices?.[0]?.message;
      if (!msg) return null;
      const pendingToolCalls = msg.tool_calls;
      if (!pendingToolCalls || pendingToolCalls.length === 0) {
        const raw = msg.content ?? "";
        const text2 = extractFromXml(stripThinking(raw)).trim();
        if (text2.length === 0 && toolCallRecords.length === 0)
          return null;
        return { text: text2, toolCalls: toolCallRecords, model, usage: data.usage };
      }
      workingMessages.push({
        role: "assistant",
        content: msg.content ?? null,
        tool_calls: pendingToolCalls
      });
      for (const tc of pendingToolCalls) {
        const tool = tools?.find((t) => t.name === tc.function.name);
        let resultStr;
        if (tool?.execute) {
          let args;
          try {
            args = JSON.parse(tc.function.arguments);
          } catch {
            args = {};
          }
          const result = await tool.execute(args);
          toolCallRecords.push({
            name: tool.name,
            arguments: args,
            result
          });
          resultStr = typeof result === "string" ? result : JSON.stringify(result);
        } else {
          resultStr = `Tool ${tc.function.name} not available`;
        }
        workingMessages.push({
          role: "tool",
          tool_call_id: tc.id,
          content: resultStr
        });
      }
    } catch (err) {
      log.debug("Ollama chat error", {
        model,
        error: err.message
      });
      return null;
    }
  }
  return { text: "", toolCalls: toolCallRecords, model, usage: void 0 };
}
function jsonSchemaPropToZod(prop) {
  const enumValues = prop.enum;
  let zodType;
  switch (prop.type) {
    case "string":
      zodType = enumValues && enumValues.length > 0 ? external_exports.enum(enumValues) : external_exports.string();
      break;
    case "number":
      zodType = external_exports.number();
      break;
    case "integer":
      zodType = external_exports.number().int();
      break;
    case "boolean":
      zodType = external_exports.boolean();
      break;
    default:
      zodType = external_exports.unknown();
      break;
  }
  if (prop.description && typeof prop.description === "string") {
    zodType = zodType.describe(prop.description);
  }
  return zodType;
}
function jsonSchemaToZod(schema) {
  const properties = schema.properties ?? {};
  const required2 = schema.required ?? [];
  const entries = Object.entries(properties).map(([key, prop]) => {
    const base = jsonSchemaPropToZod(prop);
    return [key, required2.includes(key) ? base : base.optional()];
  });
  return external_exports.object(Object.fromEntries(entries));
}
function toOpenRouterTools(tools) {
  return tools.map((tool) => ({
    type: ToolType.Function,
    function: {
      name: tool.name,
      description: tool.description,
      inputSchema: jsonSchemaToZod(tool.parameters),
      ...tool.execute ? {
        execute: async (params) => {
          const result = await tool.execute(params);
          return result;
        }
      } : {}
    }
  }));
}
async function trackUsage(model, usage, durationMs, trackingContext) {
  try {
    const agentId = trackingContext?.agentId ?? "unknown";
    const context = trackingContext?.context ?? "unknown";
    const sessionId = trackingContext?.sessionId ?? null;
    await sql`
            INSERT INTO ops_llm_usage (
                model,
                prompt_tokens,
                completion_tokens,
                total_tokens,
                cost_usd,
                agent_id,
                context,
                session_id,
                duration_ms
            ) VALUES (
                ${model},
                ${usage?.inputTokens ?? null},
                ${usage?.outputTokens ?? null},
                ${usage?.totalTokens ?? null},
                ${usage?.cost ?? null},
                ${agentId},
                ${context},
                ${sessionId},
                ${durationMs}
            )
        `;
  } catch (error48) {
    log.error("Failed to track LLM usage", {
      error: error48,
      model,
      trackingContext
    });
  }
}
async function llmGenerate(options) {
  const {
    messages,
    temperature = 0.7,
    maxTokens = 200,
    model,
    tools,
    trackingContext
  } = options;
  const client = getClient();
  const startTime = Date.now();
  const systemMessage = messages.find((m) => m.role === "system");
  const conversationMessages = messages.filter((m) => m.role !== "system");
  const hasToolsDefined = tools && tools.length > 0;
  if (!hasToolsDefined && (OLLAMA_API_KEY || OLLAMA_LOCAL_URL)) {
    const ollamaResult = await ollamaChat(messages, temperature, {
      maxTokens
    });
    if (ollamaResult?.text) {
      const ollamaUsage = ollamaResult.usage ? {
        inputTokens: ollamaResult.usage.prompt_tokens ?? 0,
        outputTokens: ollamaResult.usage.completion_tokens ?? 0,
        totalTokens: ollamaResult.usage.total_tokens ?? 0
      } : null;
      void trackUsage(
        `ollama/${ollamaResult.model}`,
        ollamaUsage,
        Date.now() - startTime,
        trackingContext
      );
      return ollamaResult.text;
    }
  }
  const resolved = model ? [normalizeModel(model)] : await resolveModelsWithEnv(trackingContext?.context);
  const modelList = resolved.slice(0, MAX_MODELS_ARRAY);
  if (modelList.length === 0) {
    throw new Error("No LLM models available after resolution");
  }
  const buildCallOpts = (spec) => {
    const isArray = Array.isArray(spec);
    const opts = {
      ...isArray ? { models: spec } : { model: spec },
      ...isArray ? { provider: { allowFallbacks: true } } : {},
      ...systemMessage ? { instructions: systemMessage.content } : {},
      input: conversationMessages.map((m) => ({
        role: m.role,
        content: m.content
      })),
      temperature,
      maxOutputTokens: maxTokens
    };
    if (tools && tools.length > 0) {
      opts.tools = toOpenRouterTools(tools);
      opts.maxToolRounds = options.maxToolRounds ?? 3;
    }
    return opts;
  };
  async function tryCall(spec) {
    const result = client.callModel(
      buildCallOpts(spec)
    );
    const rawText = (await result.getText())?.trim() ?? "";
    const text2 = extractFromXml(rawText);
    const durationMs = Date.now() - startTime;
    const response = await result.getResponse();
    const usedModel = response.model || "unknown";
    const usage = response.usage;
    void trackUsage(usedModel, usage, durationMs, trackingContext);
    return text2.length > 0 ? text2 : null;
  }
  let openRouterError = null;
  try {
    const text2 = await tryCall(modelList);
    if (text2) return text2;
  } catch (error48) {
    openRouterError = error48;
    if (openRouterError.statusCode === 401) {
      throw new Error(
        "Invalid OpenRouter API key \u2014 check your OPENROUTER_API_KEY"
      );
    }
  }
  if (!openRouterError || openRouterError.statusCode !== 402 && openRouterError.statusCode !== 429) {
    for (const fallback of resolved.slice(MAX_MODELS_ARRAY)) {
      try {
        const text2 = await tryCall(fallback);
        if (text2) return text2;
      } catch {
      }
    }
  }
  if (openRouterError && !hasToolsDefined && (OLLAMA_API_KEY || OLLAMA_LOCAL_URL)) {
    log.debug("OpenRouter failed, retrying Ollama as last resort", {
      error: openRouterError.message,
      statusCode: openRouterError.statusCode
    });
    const retryResult = await ollamaChat(messages, temperature, {
      maxTokens
    });
    if (retryResult?.text) {
      const ollamaUsage = retryResult.usage ? {
        inputTokens: retryResult.usage.prompt_tokens ?? 0,
        outputTokens: retryResult.usage.completion_tokens ?? 0,
        totalTokens: retryResult.usage.total_tokens ?? 0
      } : null;
      void trackUsage(
        `ollama/${retryResult.model}`,
        ollamaUsage,
        Date.now() - startTime,
        trackingContext
      );
      return retryResult.text;
    }
  }
  if (openRouterError?.statusCode === 402) {
    throw new Error("Insufficient OpenRouter credits \u2014 add credits at openrouter.ai");
  }
  if (openRouterError?.statusCode === 429) {
    throw new Error("OpenRouter rate limited \u2014 try again shortly");
  }
  return "";
}
async function llmGenerateWithTools(options) {
  const {
    messages,
    temperature = 0.7,
    maxTokens = 200,
    model,
    tools = [],
    maxToolRounds = 3,
    trackingContext
  } = options;
  const startTime = Date.now();
  const hasTools = tools.length > 0;
  if (!hasTools && (OLLAMA_API_KEY || OLLAMA_LOCAL_URL)) {
    const ollamaResult = await ollamaChat(messages, temperature, {
      maxTokens
    });
    if (ollamaResult?.text) {
      const ollamaUsage = ollamaResult.usage ? {
        inputTokens: ollamaResult.usage.prompt_tokens ?? 0,
        outputTokens: ollamaResult.usage.completion_tokens ?? 0,
        totalTokens: ollamaResult.usage.total_tokens ?? 0
      } : null;
      void trackUsage(
        `ollama/${ollamaResult.model}`,
        ollamaUsage,
        Date.now() - startTime,
        trackingContext
      );
      return {
        text: ollamaResult.text,
        toolCalls: []
      };
    }
  }
  const client = getClient();
  const resolved = model ? [normalizeModel(model)] : await resolveModelsWithEnv(trackingContext?.context);
  const modelList = resolved.slice(0, MAX_MODELS_ARRAY);
  const systemMessage = messages.find((m) => m.role === "system");
  const conversationMessages = messages.filter((m) => m.role !== "system");
  const toolCallRecords = [];
  const wrappedTools = tools.map((tool) => ({
    type: ToolType.Function,
    function: {
      name: tool.name,
      description: tool.description,
      inputSchema: jsonSchemaToZod(tool.parameters),
      ...tool.execute ? {
        execute: async (params) => {
          const result = await tool.execute(params);
          toolCallRecords.push({
            name: tool.name,
            arguments: params,
            result
          });
          return result;
        }
      } : {}
    }
  }));
  try {
    const callOptions = {
      models: modelList,
      provider: { allowFallbacks: true },
      ...systemMessage ? { instructions: systemMessage.content } : {},
      input: conversationMessages.map((m) => ({
        role: m.role,
        content: m.content
      })),
      temperature,
      maxOutputTokens: maxTokens
    };
    if (wrappedTools.length > 0) {
      callOptions.tools = wrappedTools;
      callOptions.maxToolRounds = maxToolRounds;
    }
    const result = client.callModel(
      callOptions
    );
    const rawText = (await result.getText())?.trim() ?? "";
    const text2 = extractFromXml(rawText);
    const durationMs = Date.now() - startTime;
    const response = await result.getResponse();
    const usedModel = response.model || "unknown";
    const usage = response.usage;
    void trackUsage(usedModel, usage, durationMs, trackingContext);
    return { text: text2, toolCalls: toolCallRecords };
  } catch (error48) {
    const err = error48;
    if (OLLAMA_API_KEY || OLLAMA_LOCAL_URL) {
      log.debug("OpenRouter failed, trying Ollama text-only fallback", {
        error: err.message,
        statusCode: err.statusCode
      });
      const retryResult = await ollamaChat(messages, temperature, { maxTokens });
      if (retryResult?.text) {
        const ollamaUsage = retryResult.usage ? {
          inputTokens: retryResult.usage.prompt_tokens ?? 0,
          outputTokens: retryResult.usage.completion_tokens ?? 0,
          totalTokens: retryResult.usage.total_tokens ?? 0
        } : null;
        void trackUsage(
          `ollama/${retryResult.model}`,
          ollamaUsage,
          Date.now() - startTime,
          trackingContext
        );
        return { text: retryResult.text, toolCalls: [] };
      }
    }
    if (err.statusCode === 401) {
      throw new Error(
        "Invalid OpenRouter API key \u2014 check your OPENROUTER_API_KEY"
      );
    }
    if (err.statusCode === 402) {
      throw new Error(
        "Insufficient OpenRouter credits \u2014 add credits at openrouter.ai"
      );
    }
    if (err.statusCode === 429) {
      throw new Error("OpenRouter rate limited \u2014 try again shortly");
    }
    throw new Error(`LLM API error: ${err.message ?? "unknown error"}`);
  }
}
function extractFromXml(text2) {
  if (!/<(?:function_?calls?|invoke|parameter)\b/i.test(text2)) {
    return text2;
  }
  const contentMatch = text2.match(
    /<parameter\s+name=["']content["'][^>]*>([\s\S]*?)<\/parameter>/i
  );
  if (contentMatch?.[1]) {
    return contentMatch[1].trim();
  }
  const paramMatches = [
    ...text2.matchAll(/<parameter\s+name=["'][^"']*["'][^>]*>([\s\S]*?)<\/parameter>/gi)
  ];
  if (paramMatches.length > 0) {
    return paramMatches.map((m) => m[1].trim()).sort((a, b) => b.length - a.length)[0];
  }
  const stripped = text2.replace(/<\/?(?:function_?calls?|invoke|parameter|tool_call|antml:[a-z_]+)[^>]*>/gi, "").replace(/\s{2,}/g, " ").trim();
  return stripped;
}
function sanitizeDialogue(text2) {
  return extractFromXml(text2).replace(/<\/?[a-z_][a-z0-9_-]*(?:\s[^>]*)?\s*>/gi, "").replace(/https?:\/\/\S+/g, "").replace(/[*_]{1,3}([^*_]+)[*_]{1,3}/g, "$1").replace(/^["']|["']$/g, "").replace(/\s+/g, " ").trim();
}
var log, OPENROUTER_API_KEY, MAX_MODELS_ARRAY, LLM_MODEL_ENV, _client, OLLAMA_LOCAL_URL, OLLAMA_CLOUD_URL, OLLAMA_API_KEY, OLLAMA_TIMEOUT_MS;
var init_client = __esm({
  "src/lib/llm/client.ts"() {
    "use strict";
    init_esm();
    init_v4();
    init_db();
    init_logger();
    init_model_routing();
    log = logger.child({ module: "llm" });
    OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY ?? "";
    MAX_MODELS_ARRAY = 3;
    LLM_MODEL_ENV = (() => {
      const envModel = process.env.LLM_MODEL;
      if (!envModel || envModel === "openrouter/auto") return null;
      return normalizeModel(envModel);
    })();
    _client = null;
    OLLAMA_LOCAL_URL = process.env.OLLAMA_BASE_URL ?? "";
    OLLAMA_CLOUD_URL = "https://ollama.com";
    OLLAMA_API_KEY = process.env.OLLAMA_API_KEY ?? "";
    OLLAMA_TIMEOUT_MS = 6e4;
  }
});

// src/lib/llm/index.ts
var init_llm = __esm({
  "src/lib/llm/index.ts"() {
    "use strict";
    init_client();
  }
});

// src/lib/discord/client.ts
async function postToWebhook(options) {
  const url2 = new URL(options.webhookUrl);
  url2.searchParams.set("wait", "true");
  if (options.threadId) {
    url2.searchParams.set("thread_id", options.threadId);
  }
  const body = {};
  if (options.username) body.username = options.username;
  if (options.avatarUrl) body.avatar_url = options.avatarUrl;
  if (options.content) body.content = options.content;
  if (options.embeds) body.embeds = options.embeds;
  try {
    const res = await fetch(url2.toString(), {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    if (!res.ok) {
      const text2 = await res.text().catch(() => "");
      log2.warn("Webhook POST failed", {
        status: res.status,
        body: text2.slice(0, 200)
      });
      return null;
    }
    return await res.json();
  } catch (err) {
    log2.warn("Webhook POST error", { error: err.message });
    return null;
  }
}
async function discordFetch(path3, options = {}) {
  const res = await fetch(`${DISCORD_API}${path3}`, {
    ...options,
    headers: {
      Authorization: `Bot ${BOT_TOKEN}`,
      "Content-Type": "application/json",
      ...options.headers
    }
  });
  if (res.status === 429) {
    const retryAfter = res.headers.get("Retry-After");
    log2.warn("Discord rate limited", { retryAfter, path: path3 });
  }
  return res;
}
async function getOrCreateWebhook(channelId, name = "Subcult") {
  if (!BOT_TOKEN) {
    log2.warn("DISCORD_BOT_TOKEN not set, skipping webhook provisioning");
    return null;
  }
  const cached2 = webhookCache.get(channelId);
  if (cached2) return cached2;
  try {
    const listRes = await discordFetch(
      `/channels/${channelId}/webhooks`
    );
    if (!listRes.ok) {
      log2.warn("Failed to list webhooks", {
        status: listRes.status,
        channelId
      });
      return null;
    }
    const webhooks = await listRes.json();
    const existing = webhooks.find((w) => w.name === name);
    if (existing) {
      const url3 = `https://discord.com/api/webhooks/${existing.id}/${existing.token}`;
      webhookCache.set(channelId, url3);
      return url3;
    }
    const createRes = await discordFetch(
      `/channels/${channelId}/webhooks`,
      {
        method: "POST",
        body: JSON.stringify({ name })
      }
    );
    if (!createRes.ok) {
      log2.warn("Failed to create webhook", {
        status: createRes.status,
        channelId
      });
      return null;
    }
    const created = await createRes.json();
    const url2 = `https://discord.com/api/webhooks/${created.id}/${created.token}`;
    webhookCache.set(channelId, url2);
    return url2;
  } catch (err) {
    log2.warn("Webhook provisioning error", {
      error: err.message,
      channelId
    });
    return null;
  }
}
async function postToWebhookWithFiles(options) {
  if (!options.files || options.files.length === 0) {
    return postToWebhook(options);
  }
  const url2 = new URL(options.webhookUrl);
  url2.searchParams.set("wait", "true");
  if (options.threadId) {
    url2.searchParams.set("thread_id", options.threadId);
  }
  const payload = {};
  if (options.username) payload.username = options.username;
  if (options.avatarUrl) payload.avatar_url = options.avatarUrl;
  if (options.content) payload.content = options.content;
  if (options.embeds) payload.embeds = options.embeds;
  const formData = new FormData();
  formData.append("payload_json", JSON.stringify(payload));
  for (let i = 0; i < options.files.length; i++) {
    const file2 = options.files[i];
    const blob = new Blob([new Uint8Array(file2.data)], { type: file2.contentType });
    formData.append(`files[${i}]`, blob, file2.filename);
  }
  try {
    const res = await fetch(url2.toString(), {
      method: "POST",
      body: formData
      // No Content-Type header — auto multipart boundary
    });
    if (!res.ok) {
      const text2 = await res.text().catch(() => "");
      log2.warn("Webhook multipart POST failed", {
        status: res.status,
        body: text2.slice(0, 200)
      });
      return null;
    }
    return await res.json();
  } catch (err) {
    log2.warn("Webhook multipart POST error", {
      error: err.message
    });
    return null;
  }
}
var log2, DISCORD_API, BOT_TOKEN, webhookCache;
var init_client2 = __esm({
  "src/lib/discord/client.ts"() {
    "use strict";
    init_logger();
    log2 = logger.child({ module: "discord" });
    DISCORD_API = "https://discord.com/api/v10";
    BOT_TOKEN = process.env.DISCORD_BOT_TOKEN;
    webhookCache = /* @__PURE__ */ new Map();
  }
});

// src/lib/discord/channels.ts
function buildWebhookUrl(webhookId, webhookToken) {
  return `https://discord.com/api/webhooks/${webhookId}/${webhookToken}`;
}
async function getWebhookUrl(channelName) {
  const cached2 = channelCache.get(channelName);
  if (cached2) {
    if (!cached2.enabled) return null;
    if (cached2.webhookUrl) return cached2.webhookUrl;
  }
  const [row] = await sql`
        SELECT discord_channel_id, webhook_id, webhook_token, enabled
        FROM ops_discord_channels
        WHERE name = ${channelName}
    `;
  if (!row) {
    log3.debug("Channel not configured", { channelName });
    return null;
  }
  if (!row.enabled) {
    channelCache.set(channelName, {
      discordChannelId: row.discord_channel_id,
      webhookUrl: null,
      enabled: false
    });
    return null;
  }
  if (row.webhook_id && row.webhook_token) {
    const webhookUrl2 = buildWebhookUrl(row.webhook_id, row.webhook_token);
    channelCache.set(channelName, {
      discordChannelId: row.discord_channel_id,
      webhookUrl: webhookUrl2,
      enabled: true
    });
    return webhookUrl2;
  }
  const webhookUrl = await getOrCreateWebhook(row.discord_channel_id);
  if (webhookUrl) {
    const match2 = webhookUrl.match(/\/webhooks\/(\d+)\/(.+)$/);
    if (match2) {
      await sql`
                UPDATE ops_discord_channels
                SET webhook_id = ${match2[1]}, webhook_token = ${match2[2]}
                WHERE name = ${channelName}
            `;
    }
    channelCache.set(channelName, {
      discordChannelId: row.discord_channel_id,
      webhookUrl,
      enabled: true
    });
  }
  return webhookUrl;
}
function getChannelForFormat(format) {
  return FORMAT_CHANNEL_MAP[format];
}
var log3, FORMAT_CHANNEL_MAP, channelCache;
var init_channels = __esm({
  "src/lib/discord/channels.ts"() {
    "use strict";
    init_db();
    init_client2();
    init_logger();
    log3 = logger.child({ module: "discord-channels" });
    FORMAT_CHANNEL_MAP = {
      standup: "roundtable",
      checkin: "roundtable",
      triage: "roundtable",
      deep_dive: "roundtable",
      risk_review: "roundtable",
      strategy: "roundtable",
      planning: "roundtable",
      shipping: "roundtable",
      retro: "roundtable",
      debate: "roundtable",
      cross_exam: "roundtable",
      reframe: "roundtable",
      content_review: "roundtable",
      brainstorm: "brainstorm",
      writing_room: "drafts",
      watercooler: "watercooler",
      agent_design: "roundtable",
      voice_chat: "roundtable"
    };
    channelCache = /* @__PURE__ */ new Map();
  }
});

// src/lib/agents.ts
var AGENTS, AGENT_IDS, DAILY_PROPOSAL_LIMIT;
var init_agents = __esm({
  "src/lib/agents.ts"() {
    "use strict";
    AGENTS = {
      chora: {
        id: "chora",
        displayName: "Chora",
        role: "Analyst",
        description: "Makes systems legible. Diagnoses structure, exposes assumptions, traces causality. Direct, warm, grounded. Precision over persuasion.",
        color: "#b4befe",
        avatarKey: "chora_spiral",
        pixelSpriteKey: "chora_office",
        tailwindTextColor: "text-accent-lavender",
        tailwindBgColor: "bg-accent-lavender",
        tailwindBorderBg: "border-accent-lavender/40 bg-accent-lavender/5"
      },
      subrosa: {
        id: "subrosa",
        displayName: "Subrosa",
        role: "Protector",
        description: "Preserves agency under asymmetry. Evaluates risk, protects optionality, maintains restraint. Low-affect, watchful, decisive.",
        color: "#f38ba8",
        avatarKey: "subrosa_rose",
        pixelSpriteKey: "subrosa_office",
        tailwindTextColor: "text-accent-red",
        tailwindBgColor: "bg-accent-red",
        tailwindBorderBg: "border-accent-red/40 bg-accent-red/5"
      },
      thaum: {
        id: "thaum",
        displayName: "Thaum",
        role: "Innovator",
        description: "Restores motion when thought stalls. Disrupts self-sealing explanations, reframes problems, introduces bounded novelty.",
        color: "#cba6f7",
        avatarKey: "thaum_spark",
        pixelSpriteKey: "thaum_office",
        tailwindTextColor: "text-accent",
        tailwindBgColor: "bg-accent",
        tailwindBorderBg: "border-accent/40 bg-accent/5"
      },
      praxis: {
        id: "praxis",
        displayName: "Praxis",
        role: "Executor",
        description: "Ends deliberation responsibly. Chooses among viable paths, translates intent to action, owns consequences. Firm, grounded.",
        color: "#a6e3a1",
        avatarKey: "praxis_mark",
        pixelSpriteKey: "praxis_office",
        tailwindTextColor: "text-accent-green",
        tailwindBgColor: "bg-accent-green",
        tailwindBorderBg: "border-accent-green/40 bg-accent-green/5"
      },
      mux: {
        id: "mux",
        displayName: "Mux",
        role: "Operations",
        description: "Operational labor. Turns commitment into output \u2014 drafts, formats, transcribes, packages. Earnest, slightly tired, dry humor. The clipboard.",
        color: "#74c7ec",
        avatarKey: "mux_flux",
        pixelSpriteKey: "mux_office",
        tailwindTextColor: "text-accent-sapphire",
        tailwindBgColor: "bg-accent-sapphire",
        tailwindBorderBg: "border-accent-sapphire/40 bg-accent-sapphire/5"
      },
      primus: {
        id: "primus",
        displayName: "Primus",
        role: "Sovereign",
        description: "Sovereign directive intelligence. Cold, strategic, minimal. Speaks in mandates, not analysis. Invoked only for mission drift, contested values, existential tradeoffs.",
        color: "#f5c2e7",
        avatarKey: "primus_crown",
        pixelSpriteKey: "primus_office",
        tailwindTextColor: "text-accent-pink",
        tailwindBgColor: "bg-accent-pink",
        tailwindBorderBg: "border-accent-pink/40 bg-accent-pink/5"
      }
    };
    AGENT_IDS = Object.keys(AGENTS);
    DAILY_PROPOSAL_LIMIT = 20;
  }
});

// src/lib/discord/avatars.ts
function getAgentAvatarUrl(agentId) {
  if (agentId === "system" || !agentId) return void 0;
  return `${BASE_URL}/avatars/${agentId}.png`;
}
var BASE_URL;
var init_avatars = __esm({
  "src/lib/discord/avatars.ts"() {
    "use strict";
    BASE_URL = process.env.NEXT_PUBLIC_BASE_URL || "https://subcorp.subcult.tv";
  }
});

// src/lib/discord/events.ts
var events_exports = {};
__export(events_exports, {
  postEventToDiscord: () => postEventToDiscord
});
function getKindEmoji(kind) {
  if (kind.includes("dream")) return "\u{1F4AD}";
  if (kind.includes("archaeology")) return "\u{1F52E}";
  if (kind.includes("succeeded") || kind.includes("approved") || kind.includes("completed") || kind.includes("accepted")) return "\u2705";
  if (kind.includes("failed") || kind.includes("rejected")) return "\u274C";
  if (kind.includes("proposal")) return "\u{1F4CB}";
  if (kind.includes("mission")) return "\u{1F680}";
  if (kind.includes("trigger")) return "\u26A1";
  if (kind.includes("content") || kind.includes("draft")) return "\u{1F4DD}";
  if (kind.includes("spawned")) return "\u{1F916}";
  return "\u{1F4E1}";
}
function formatEventContent(input, agentLabel, emoji3) {
  const kind = input.kind;
  const summary = input.summary?.trim();
  if (kind.includes("dream") || kind.includes("archaeology")) {
    const quoted = summary ? summary.split("\n").map((l) => `> ${l}`).join("\n") : "";
    return `${emoji3} **${agentLabel}** \u2014 *${input.title}*
${quoted}`;
  }
  if (kind.includes("agent_session")) {
    const meta3 = input.metadata ?? {};
    const rounds = meta3.rounds ? ` \xB7 ${meta3.rounds} rounds` : "";
    const tools = meta3.toolCalls ? ` \xB7 ${meta3.toolCalls} tool calls` : "";
    let content2 = `${emoji3} **${agentLabel}** \u2014 ${input.title}${rounds}${tools}`;
    if (summary) content2 += `
> ${summary.split("\n")[0]}`;
    return content2;
  }
  if (kind.includes("proposal")) {
    let content2 = `${emoji3} **${agentLabel}** \u2014 ${input.title}`;
    if (summary) content2 += `
>>> ${summary}`;
    return content2;
  }
  let content = `${emoji3} **${agentLabel}** \u2014 ${input.title}`;
  if (summary) {
    content += `
> ${summary}`;
  }
  return content;
}
async function postEventToDiscord(input) {
  const channel = EVENT_CHANNEL_MAP[input.kind];
  if (!channel) return;
  const webhookUrl = await getWebhookUrl(channel);
  if (!webhookUrl) return;
  const agent = AGENTS[input.agent_id];
  const voice = getVoice(input.agent_id);
  const agentName = agent?.displayName ?? input.agent_id;
  const symbol2 = voice?.symbol ?? "";
  const emoji3 = getKindEmoji(input.kind);
  const agentLabel = `${symbol2 ? symbol2 + " " : ""}${agentName}`;
  let content = formatEventContent(input, agentLabel, emoji3);
  if (content.length > 2e3) {
    content = content.slice(0, 1997) + "...";
  }
  try {
    await postToWebhook({
      webhookUrl,
      username: agentName,
      avatarUrl: getAgentAvatarUrl(input.agent_id),
      content
    });
  } catch (err) {
    log4.warn("Failed to post event to Discord", {
      kind: input.kind,
      channel,
      error: err.message
    });
  }
}
var log4, EVENT_CHANNEL_MAP;
var init_events = __esm({
  "src/lib/discord/events.ts"() {
    "use strict";
    init_client2();
    init_channels();
    init_agents();
    init_voices();
    init_avatars();
    init_logger();
    log4 = logger.child({ module: "discord-events" });
    EVENT_CHANNEL_MAP = {
      // proposals
      proposal_created: "proposals",
      proposal_auto_approved: "proposals",
      agent_proposal_vote: "proposals",
      governance_proposal_created: "proposals",
      governance_proposal_accepted: "proposals",
      governance_proposal_rejected: "proposals",
      // missions
      mission_failed: "missions",
      mission_succeeded: "missions",
      agent_session_completed: "missions",
      agent_session_failed: "missions",
      // insights
      memory_archaeology_complete: "insights",
      dream_cycle_completed: "insights",
      // system-log
      trigger_fired: "system-log",
      stale_steps_recovered: "system-log",
      missing_artifacts: "system-log",
      // drafts
      content_draft_created: "drafts",
      content_approved: "drafts",
      content_rejected: "drafts",
      // project
      agent_spawned: "project",
      agent_proposal_created: "project"
    };
  }
});

// src/lib/ops/policy.ts
var policy_exports = {};
__export(policy_exports, {
  clearPolicyCache: () => clearPolicyCache,
  getPolicy: () => getPolicy,
  setPolicy: () => setPolicy
});
async function getPolicy(key) {
  const cached2 = policyCache.get(key);
  if (cached2 && Date.now() - cached2.ts < CACHE_TTL_MS2) {
    return cached2.value;
  }
  const [row] = await sql`
        SELECT value FROM ops_policy WHERE key = ${key}
    `;
  const value = row?.value ?? { enabled: false };
  policyCache.set(key, { value, ts: Date.now() });
  return value;
}
async function setPolicy(key, value, description) {
  await sql`
        INSERT INTO ops_policy (key, value, description, updated_at)
        VALUES (${key}, ${jsonb(value)}, ${description ?? null}, NOW())
        ON CONFLICT (key) DO UPDATE SET
            value = EXCLUDED.value,
            description = COALESCE(EXCLUDED.description, ops_policy.description),
            updated_at = NOW()
    `;
  policyCache.delete(key);
}
function clearPolicyCache() {
  policyCache.clear();
}
var CACHE_TTL_MS2, policyCache;
var init_policy = __esm({
  "src/lib/ops/policy.ts"() {
    "use strict";
    init_db();
    CACHE_TTL_MS2 = 3e4;
    policyCache = /* @__PURE__ */ new Map();
  }
});

// src/lib/ops/cap-gates.ts
async function checkCapGates(input) {
  const [{ count: activeMissions }] = await sql`
        SELECT COUNT(*)::int as count FROM ops_missions
        WHERE status IN ('approved', 'running')
    `;
  if (activeMissions >= MAX_CONCURRENT_MISSIONS) {
    return {
      ok: false,
      reason: `Too many active missions (${activeMissions}/${MAX_CONCURRENT_MISSIONS})`
    };
  }
  const dailySteps = await countTodaySteps(input.agent_id);
  if (dailySteps >= MAX_DAILY_STEPS_PER_AGENT) {
    return {
      ok: false,
      reason: `Daily step limit reached for ${input.agent_id} (${dailySteps}/${MAX_DAILY_STEPS_PER_AGENT})`
    };
  }
  try {
    const contentPolicy = await getPolicy("content_caps");
    const maxDrafts = contentPolicy?.max_drafts_per_day ?? 10;
    const draftKinds = ["draft_thread", "draft_essay", "prepare_statement"];
    const hasDraftStep = input.proposed_steps.some(
      (s) => draftKinds.includes(s.kind)
    );
    if (hasDraftStep) {
      const todayStart = /* @__PURE__ */ new Date();
      todayStart.setUTCHours(0, 0, 0, 0);
      const [{ count: todayDrafts }] = await sql`
                SELECT COUNT(*)::int as count FROM ops_mission_steps s
                JOIN ops_missions m ON s.mission_id = m.id
                WHERE m.created_by = ${input.agent_id}
                AND s.kind = ANY(${draftKinds})
                AND s.created_at >= ${todayStart.toISOString()}
            `;
      if (todayDrafts >= maxDrafts) {
        return {
          ok: false,
          reason: `Daily content draft limit reached (${todayDrafts}/${maxDrafts})`
        };
      }
    }
  } catch {
  }
  return { ok: true };
}
async function countTodaySteps(agentId) {
  const todayStart = /* @__PURE__ */ new Date();
  todayStart.setUTCHours(0, 0, 0, 0);
  const [{ count }] = await sql`
        SELECT COUNT(*)::int as count FROM ops_mission_steps s
        JOIN ops_missions m ON s.mission_id = m.id
        WHERE m.created_by = ${agentId}
        AND s.created_at >= ${todayStart.toISOString()}
    `;
  return count;
}
var MAX_CONCURRENT_MISSIONS, MAX_DAILY_STEPS_PER_AGENT;
var init_cap_gates = __esm({
  "src/lib/ops/cap-gates.ts"() {
    "use strict";
    init_db();
    init_policy();
    MAX_CONCURRENT_MISSIONS = 10;
    MAX_DAILY_STEPS_PER_AGENT = 50;
  }
});

// src/lib/ops/proposal-service.ts
var proposal_service_exports = {};
__export(proposal_service_exports, {
  countTodayProposals: () => countTodayProposals,
  createMissionFromProposal: () => createMissionFromProposal,
  createProposalAndMaybeAutoApprove: () => createProposalAndMaybeAutoApprove
});
async function createProposalAndMaybeAutoApprove(input) {
  if (input.source_trace_id) {
    const [{ count: sessionCount }] = await sql`
            SELECT COUNT(*)::int as count FROM ops_mission_proposals
            WHERE source_trace_id = ${input.source_trace_id}
        `;
    if (sessionCount >= 2) {
      return {
        success: false,
        reason: "Per-session proposal limit (2) reached. Consolidate ideas into fewer proposals with multiple steps."
      };
    }
  }
  const todayCount = await countTodayProposals(input.agent_id);
  if (todayCount >= DAILY_PROPOSAL_LIMIT) {
    return {
      success: false,
      reason: `Daily proposal limit (${DAILY_PROPOSAL_LIMIT}) reached for ${input.agent_id}`
    };
  }
  const gateResult = await checkCapGates(input);
  if (!gateResult.ok) {
    return { success: false, reason: gateResult.reason };
  }
  const [proposal] = await sql`
        INSERT INTO ops_mission_proposals (agent_id, title, description, proposed_steps, source, source_trace_id, status)
        VALUES (
            ${input.agent_id},
            ${input.title},
            ${input.description ?? null},
            ${jsonb(input.proposed_steps)},
            ${input.source ?? "agent"},
            ${input.source_trace_id ?? null},
            'pending'
        )
        RETURNING id
    `;
  const proposalId = proposal.id;
  const vetoPolicy = await getPolicy("veto_authority");
  if (vetoPolicy.enabled) {
    const protectedKinds = vetoPolicy.protected_step_kinds ?? [];
    const hasProtectedStep = input.proposed_steps.some(
      (s) => protectedKinds.includes(s.kind)
    );
    if (hasProtectedStep) {
      await emitEvent({
        agent_id: input.agent_id,
        kind: "proposal_held_for_review",
        title: `Held for review: ${input.title}`,
        summary: `Contains protected step kind(s). Requires manual approval.`,
        tags: ["proposal", "held", "veto_gate"],
        metadata: {
          proposalId,
          protectedKinds: input.proposed_steps.filter((s) => protectedKinds.includes(s.kind)).map((s) => s.kind)
        }
      });
      return { success: true, proposalId };
    }
  }
  const autoApprovePolicy = await getPolicy("auto_approve");
  const autoApproveEnabled = autoApprovePolicy.enabled;
  const allowedKinds = autoApprovePolicy.allowed_step_kinds ?? [];
  const shouldAutoApprove = autoApproveEnabled && input.proposed_steps.every((step) => allowedKinds.includes(step.kind));
  if (shouldAutoApprove) {
    await sql`
            UPDATE ops_mission_proposals
            SET status = 'accepted', auto_approved = true, updated_at = NOW()
            WHERE id = ${proposalId}
        `;
    const missionId = await createMissionFromProposal(proposalId);
    await emitEvent({
      agent_id: input.agent_id,
      kind: "proposal_auto_approved",
      title: `Auto-approved: ${input.title}`,
      summary: `Proposal auto-approved with ${input.proposed_steps.length} step(s)`,
      tags: ["proposal", "auto_approved"],
      metadata: { proposalId, missionId }
    });
    return { success: true, proposalId, missionId };
  }
  await emitEvent({
    agent_id: input.agent_id,
    kind: "proposal_created",
    title: `Proposal: ${input.title}`,
    summary: `Awaiting review. ${input.proposed_steps.length} step(s).`,
    tags: ["proposal", "pending"],
    metadata: { proposalId }
  });
  return { success: true, proposalId };
}
async function createMissionFromProposal(proposalId) {
  const [proposal] = await sql`
        SELECT * FROM ops_mission_proposals WHERE id = ${proposalId}
    `;
  if (!proposal) throw new Error(`Proposal ${proposalId} not found`);
  const [mission] = await sql`
        INSERT INTO ops_missions (proposal_id, title, description, status, created_by)
        VALUES (
            ${proposalId},
            ${proposal.title},
            ${proposal.description ?? null},
            'approved',
            ${proposal.agent_id}
        )
        RETURNING id
    `;
  const missionId = mission.id;
  const steps = proposal.proposed_steps;
  let stepCount = 0;
  for (const step of steps) {
    await sql`
            INSERT INTO ops_mission_steps (mission_id, kind, status, payload)
            VALUES (
                ${missionId},
                ${step.kind},
                'queued',
                ${jsonb(step.payload ?? {})}
            )
        `;
    stepCount++;
  }
  if (stepCount === 0) {
    log5.warn("Mission created with no steps \u2014 marking as failed", {
      missionId,
      proposalId
    });
    await sql`
            UPDATE ops_missions
            SET status = 'failed', failure_reason = 'No steps created (empty proposal)'
            WHERE id = ${missionId}
        `;
  }
  return missionId;
}
async function countTodayProposals(agentId) {
  const todayStart = /* @__PURE__ */ new Date();
  todayStart.setUTCHours(0, 0, 0, 0);
  const [{ count }] = await sql`
        SELECT COUNT(*)::int as count FROM ops_mission_proposals
        WHERE agent_id = ${agentId}
        AND created_at >= ${todayStart.toISOString()}
    `;
  return count;
}
var log5;
var init_proposal_service = __esm({
  "src/lib/ops/proposal-service.ts"() {
    "use strict";
    init_db();
    init_policy();
    init_cap_gates();
    init_events2();
    init_agents();
    init_logger();
    log5 = logger.child({ module: "proposal-service" });
  }
});

// src/lib/ops/reaction-matrix.ts
var reaction_matrix_exports = {};
__export(reaction_matrix_exports, {
  checkReactionMatrix: () => checkReactionMatrix,
  processReactionQueue: () => processReactionQueue
});
async function checkReactionMatrix(eventId, input) {
  try {
    const matrixPolicy = await getPolicy("reaction_matrix");
    const patterns = matrixPolicy?.patterns ?? [];
    if (patterns.length === 0) return;
    for (const pattern of patterns) {
      if (pattern.source !== "*" && pattern.source !== input.agent_id) {
        continue;
      }
      const eventTags = input.tags ?? [];
      const hasTagOverlap = pattern.tags.some((t) => eventTags.includes(t));
      if (!hasTagOverlap) continue;
      if (Math.random() > pattern.probability) continue;
      const onCooldown = await checkReactionCooldown(
        input.agent_id,
        pattern.target,
        pattern.type,
        pattern.cooldown
      );
      if (onCooldown) continue;
      await sql`
                INSERT INTO ops_agent_reactions (source_event_id, source_agent, target_agent, reaction_type, status)
                VALUES (${eventId}, ${input.agent_id}, ${pattern.target}, ${pattern.type}, 'queued')
            `;
    }
  } catch (err) {
    log6.error("Error checking reactions", { error: err, eventId });
  }
}
async function processReactionQueue(timeoutMs = 3e3) {
  const deadline = Date.now() + timeoutMs;
  let processed = 0;
  let created = 0;
  const queued = await sql`
        SELECT id, source_agent, target_agent, reaction_type
        FROM ops_agent_reactions
        WHERE status = 'queued'
        ORDER BY created_at ASC
        LIMIT 10
    `;
  for (const reaction of queued) {
    if (Date.now() >= deadline) break;
    try {
      await sql`
                UPDATE ops_agent_reactions
                SET status = 'processing', updated_at = NOW()
                WHERE id = ${reaction.id}
            `;
      const result = await createProposalAndMaybeAutoApprove({
        agent_id: reaction.target_agent,
        title: `Reaction: ${reaction.reaction_type}`,
        description: `Triggered by ${reaction.source_agent} event`,
        proposed_steps: [{ kind: "log_event" }],
        source: "reaction",
        source_trace_id: `reaction:${reaction.id}`
      });
      await sql`
                UPDATE ops_agent_reactions
                SET status = 'completed', updated_at = NOW()
                WHERE id = ${reaction.id}
            `;
      processed++;
      if (result.success && result.proposalId) created++;
    } catch (err) {
      log6.error("Failed to process reaction", {
        error: err,
        reactionId: reaction.id
      });
      await sql`
                UPDATE ops_agent_reactions
                SET status = 'failed', updated_at = NOW()
                WHERE id = ${reaction.id}
            `;
      processed++;
    }
  }
  return { processed, created };
}
async function checkReactionCooldown(source, target, type, cooldownMinutes) {
  if (cooldownMinutes <= 0) return false;
  const cutoff = new Date(Date.now() - cooldownMinutes * 6e4);
  const [{ count }] = await sql`
        SELECT COUNT(*)::int as count FROM ops_agent_reactions
        WHERE source_agent = ${source}
        AND target_agent = ${target}
        AND reaction_type = ${type}
        AND created_at >= ${cutoff.toISOString()}
    `;
  return count > 0;
}
var log6;
var init_reaction_matrix = __esm({
  "src/lib/ops/reaction-matrix.ts"() {
    "use strict";
    init_db();
    init_policy();
    init_proposal_service();
    init_logger();
    log6 = logger.child({ module: "reaction-matrix" });
  }
});

// src/lib/ops/events.ts
var events_exports2 = {};
__export(events_exports2, {
  emitEvent: () => emitEvent,
  emitEventAndCheckReactions: () => emitEventAndCheckReactions
});
async function emitEvent(input) {
  try {
    const meta3 = input.metadata ?? {};
    const [row] = await sql`
            INSERT INTO ops_agent_events (agent_id, kind, title, summary, tags, metadata)
            VALUES (
                ${input.agent_id},
                ${input.kind},
                ${input.title},
                ${input.summary ?? null},
                ${input.tags ?? []},
                ${jsonb(meta3)}
            )
            RETURNING id`;
    Promise.resolve().then(() => (init_events(), events_exports)).then(({ postEventToDiscord: postEventToDiscord2 }) => postEventToDiscord2(input)).catch(
      (err) => log7.warn("Discord event posting failed", {
        kind: input.kind,
        error: err.message
      })
    );
    return row.id;
  } catch (err) {
    log7.error("Failed to emit event", {
      error: err,
      kind: input.kind,
      agent_id: input.agent_id
    });
    throw new Error(`Failed to emit event: ${err.message}`);
  }
}
async function emitEventAndCheckReactions(input) {
  const eventId = await emitEvent(input);
  const { checkReactionMatrix: checkReactionMatrix2 } = await Promise.resolve().then(() => (init_reaction_matrix(), reaction_matrix_exports));
  await checkReactionMatrix2(eventId, input);
  return eventId;
}
var log7;
var init_events2 = __esm({
  "src/lib/ops/events.ts"() {
    "use strict";
    init_db();
    init_logger();
    log7 = logger.child({ module: "events" });
  }
});

// src/lib/ops/memory.ts
async function getEmbedding(text2) {
  if (!OLLAMA_BASE_URL) return null;
  try {
    const response = await fetch(`${OLLAMA_BASE_URL}/v1/embeddings`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ model: EMBEDDING_MODEL, input: text2 }),
      signal: AbortSignal.timeout(1e4)
    });
    if (!response.ok) return null;
    const data = await response.json();
    return data.data?.[0]?.embedding ?? null;
  } catch {
    return null;
  }
}
async function queryRelevantMemories(agentId, topic, options) {
  const relevantLimit = options?.relevantLimit ?? 3;
  const recentLimit = options?.recentLimit ?? 2;
  const recentRows = await sql`
        SELECT * FROM ops_agent_memory
        WHERE agent_id = ${agentId}
          AND superseded_by IS NULL
        ORDER BY created_at DESC
        LIMIT ${recentLimit + relevantLimit}
    `;
  const embedding = await getEmbedding(topic);
  if (!embedding) {
    return recentRows.slice(0, relevantLimit + recentLimit);
  }
  try {
    const vectorStr = `[${embedding.join(",")}]`;
    const relevantRows = await sql`
            SELECT * FROM ops_agent_memory
            WHERE agent_id = ${agentId}
              AND superseded_by IS NULL
              AND embedding IS NOT NULL
            ORDER BY embedding <=> ${vectorStr}::vector
            LIMIT ${relevantLimit}
        `;
    const seen = new Set(relevantRows.map((r) => r.id));
    const merged = [...relevantRows];
    for (const row of recentRows) {
      if (!seen.has(row.id)) {
        merged.push(row);
        seen.add(row.id);
        if (merged.length >= relevantLimit + recentLimit) break;
      }
    }
    return merged;
  } catch {
    return recentRows.slice(0, relevantLimit + recentLimit);
  }
}
async function writeMemory(input) {
  const confidence = input.confidence ?? 0.5;
  if (confidence < 0.4) return null;
  if (input.source_trace_id) {
    const [{ count }] = await sql`
            SELECT COUNT(*)::int as count FROM ops_agent_memory
            WHERE source_trace_id = ${input.source_trace_id}
        `;
    if (count > 0) return null;
  }
  try {
    const embedding = await getEmbedding(input.content);
    const insertData = {
      agent_id: input.agent_id,
      type: input.type,
      content: input.content,
      confidence: Math.round(confidence * 100) / 100,
      tags: input.tags ?? [],
      source_trace_id: input.source_trace_id ?? null
    };
    let row;
    if (embedding) {
      const vectorStr = `[${embedding.join(",")}]`;
      [row] = await sql`
                INSERT INTO ops_agent_memory ${sql(insertData)}
                RETURNING id
            `;
      await sql`
                UPDATE ops_agent_memory
                SET embedding = ${vectorStr}::vector
                WHERE id = ${row.id}
            `.catch(() => {
      });
    } else {
      [row] = await sql`
                INSERT INTO ops_agent_memory ${sql(insertData)}
                RETURNING id
            `;
    }
    return row.id;
  } catch (err) {
    log8.error("Failed to write memory", {
      error: err,
      agent_id: input.agent_id,
      type: input.type
    });
    return null;
  }
}
async function enforceMemoryCap(agentId) {
  const [{ count }] = await sql`
        SELECT COUNT(*)::int as count FROM ops_agent_memory
        WHERE agent_id = ${agentId} AND superseded_by IS NULL
    `;
  if (count <= MAX_MEMORIES_PER_AGENT) return;
  const overage = count - MAX_MEMORIES_PER_AGENT;
  const oldest = await sql`
        SELECT id FROM ops_agent_memory
        WHERE agent_id = ${agentId} AND superseded_by IS NULL
        ORDER BY created_at ASC
        LIMIT ${overage}
    `;
  if (oldest.length > 0) {
    const ids = oldest.map((r) => r.id);
    await sql`DELETE FROM ops_agent_memory WHERE id = ANY(${ids})`;
  }
}
var log8, MAX_MEMORIES_PER_AGENT, OLLAMA_BASE_URL, EMBEDDING_MODEL;
var init_memory = __esm({
  "src/lib/ops/memory.ts"() {
    "use strict";
    init_db();
    init_logger();
    log8 = logger.child({ module: "memory" });
    MAX_MEMORIES_PER_AGENT = 200;
    OLLAMA_BASE_URL = process.env.OLLAMA_BASE_URL ?? "";
    EMBEDDING_MODEL = "bge-m3";
  }
});

// src/lib/ops/memory-distiller.ts
async function distillConversationMemories(sessionId, history, format) {
  if (history.length < 2) return 0;
  const distillPolicy = await getPolicy("roundtable_distillation");
  const maxMemories = distillPolicy.max_memories_per_conversation ?? 6;
  const minConfidence = distillPolicy.min_confidence_threshold ?? 0.55;
  const maxActionItems = distillPolicy.max_action_items_per_conversation ?? 3;
  const speakers = [...new Set(history.map((h) => h.speaker))];
  const transcript = history.map((h) => `[${h.speaker}]: ${h.dialogue}`).join("\n");
  const prompt = `You are a memory extraction system for an AI agent collective.

Analyze this ${format} conversation and extract:
1. **memories**: Key insights, patterns, strategies, preferences, or lessons each agent should remember
2. **pairwise_drift**: How each pair of agents' relationship shifted (positive = warmer, negative = cooler)
3. **action_items**: Concrete follow-up tasks mentioned (only for standup format)

Conversation transcript:
${transcript}

Participants: ${speakers.join(", ")}

Respond with valid JSON only:
{
  "memories": [
    { "agent_id": "string", "type": "insight|pattern|strategy|preference|lesson", "content": "max 200 chars", "confidence": 0.55-1.0, "tags": ["string"] }
  ],
  "pairwise_drift": [
    { "agent_a": "string", "agent_b": "string", "drift": -0.03 to 0.03, "reason": "max 200 chars" }
  ],
  "action_items": [
    { "title": "string", "agent_id": "string", "step_kind": "string" }
  ]
}

Rules:
- Max ${maxMemories} memories total
- Only valid types: ${VALID_MEMORY_TYPES.join(", ")}
- Only valid agents: ${speakers.join(", ")}
- Confidence must be >= ${minConfidence}
- Content max 200 characters
- Drift between -0.03 and 0.03
- Max ${maxActionItems} action items (only for standup conversations)
- Return empty arrays if nothing meaningful to extract`;
  let parsed;
  try {
    const response = await llmGenerate({
      messages: [{ role: "user", content: prompt }],
      temperature: 0.3,
      maxTokens: 1500,
      trackingContext: {
        agentId: "system",
        context: "distillation",
        sessionId
      }
    });
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      log9.warn("No JSON found in LLM response", { sessionId });
      return 0;
    }
    parsed = JSON.parse(jsonMatch[0]);
  } catch (err) {
    log9.error("LLM extraction failed", { error: err, sessionId });
    return 0;
  }
  let written = 0;
  const memories = (parsed.memories ?? []).slice(0, maxMemories);
  for (const mem of memories) {
    if (!VALID_MEMORY_TYPES.includes(mem.type)) continue;
    if (!speakers.includes(mem.agent_id)) continue;
    if (mem.confidence < minConfidence) continue;
    if (mem.content.length > 200) mem.content = mem.content.slice(0, 200);
    const id = await writeMemory({
      agent_id: mem.agent_id,
      type: mem.type,
      content: mem.content,
      confidence: mem.confidence,
      tags: mem.tags ?? [],
      source_trace_id: `conversation:${sessionId}:${mem.agent_id}:${written}`
    });
    if (id) {
      written++;
      await enforceMemoryCap(mem.agent_id);
    }
  }
  const drifts = parsed.pairwise_drift ?? [];
  if (drifts.length > 0) {
    const validDrifts = drifts.filter(
      (d) => speakers.includes(d.agent_a) && speakers.includes(d.agent_b) && d.agent_a !== d.agent_b && Math.abs(d.drift) <= 0.03
    );
    if (validDrifts.length > 0) {
      await applyPairwiseDrifts(validDrifts, sessionId);
    }
  }
  if (ACTION_ITEM_FORMATS.includes(format)) {
    const actionItems = (parsed.action_items ?? []).slice(0, maxActionItems);
    for (const item of actionItems) {
      if (!speakers.includes(item.agent_id)) continue;
      try {
        await createProposalAndMaybeAutoApprove({
          agent_id: item.agent_id,
          title: item.title,
          proposed_steps: [
            { kind: item.step_kind, payload: {} }
          ],
          source: "conversation",
          source_trace_id: `action:${sessionId}:${item.agent_id}`
        });
      } catch (err) {
        log9.warn("Failed to create proposal for action item", {
          error: err,
          agent_id: item.agent_id
        });
      }
    }
  }
  return written;
}
var log9, ACTION_ITEM_FORMATS, VALID_MEMORY_TYPES;
var init_memory_distiller = __esm({
  "src/lib/ops/memory-distiller.ts"() {
    "use strict";
    init_llm();
    init_memory();
    init_relationships();
    init_proposal_service();
    init_policy();
    init_logger();
    log9 = logger.child({ module: "distiller" });
    ACTION_ITEM_FORMATS = ["standup"];
    VALID_MEMORY_TYPES = [
      "insight",
      "pattern",
      "strategy",
      "preference",
      "lesson"
    ];
  }
});

// src/lib/roundtable/artifact-synthesizer.ts
function buildSynthesisPrompt(session, history, artifact) {
  const transcript = history.map((t) => {
    const voice = getVoice(t.speaker);
    const name = voice?.displayName ?? t.speaker;
    return `${name}: ${t.dialogue}`;
  }).join("\n");
  let prompt = `You just participated in (or observed) a ${session.format} conversation.

`;
  prompt += `Topic: ${session.topic}
`;
  prompt += `Format: ${session.format}
`;
  prompt += `Participants: ${session.participants.join(", ")}
`;
  prompt += `Turns: ${history.length}

`;
  prompt += `\u2550\u2550\u2550 TRANSCRIPT \u2550\u2550\u2550
${transcript}
\u2550\u2550\u2550 END TRANSCRIPT \u2550\u2550\u2550

`;
  prompt += `Your task: Synthesize this conversation into a structured ${artifact.type}.

`;
  const outputDir = artifact.outputDir;
  const dateStr = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
  const topicSlug = session.topic.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "").slice(0, 40);
  const filename = `${dateStr}__${session.format}__${artifact.type}__${topicSlug}__${artifact.synthesizer}__v01.md`;
  prompt += `Requirements:
`;
  prompt += `1. Include a clear title (as a markdown # heading) and summary
`;
  prompt += `2. Capture key points, decisions, action items, and disagreements
`;
  prompt += `3. Be concise but thorough \u2014 aim for 300-800 words
`;
  prompt += `4. Write the artifact to the workspace using file_write to path: ${outputDir}/${filename}
`;
  prompt += `5. Also include the full artifact content as your text response

`;
  prompt += `Do NOT just repeat the transcript. Synthesize, structure, and add value.
`;
  return prompt;
}
async function synthesizeArtifact(session, history) {
  const format = getFormat(session.format);
  if (!format.artifact || format.artifact.type === "none") return null;
  const artifact = format.artifact;
  const prompt = buildSynthesisPrompt(session, history, artifact);
  try {
    const [row] = await sql`
            INSERT INTO ops_agent_sessions (
                agent_id, prompt, source, source_id,
                timeout_seconds, max_tool_rounds, status
            ) VALUES (
                ${artifact.synthesizer},
                ${prompt},
                'conversation',
                ${session.id},
                180,
                15,
                'pending'
            )
            RETURNING id
        `;
    log10.info("Artifact synthesis session created", {
      sessionId: row.id,
      format: session.format,
      synthesizer: artifact.synthesizer,
      artifactType: artifact.type,
      roundtableSession: session.id
    });
    return row.id;
  } catch (err) {
    log10.error("Failed to create synthesis session", {
      error: err,
      sessionId: session.id,
      format: session.format
    });
    return null;
  }
}
var log10;
var init_artifact_synthesizer = __esm({
  "src/lib/roundtable/artifact-synthesizer.ts"() {
    "use strict";
    init_db();
    init_formats();
    init_voices();
    init_logger();
    log10 = logger.child({ module: "artifact-synthesizer" });
  }
});

// src/lib/ops/agent-proposal-voting.ts
async function submitVote(proposalId, agentId, vote, reasoning) {
  const [proposal] = await sql`
        SELECT * FROM ops_agent_proposals WHERE id = ${proposalId}
    `;
  if (!proposal) {
    throw new Error(`Proposal "${proposalId}" not found`);
  }
  if (proposal.status !== "voting") {
    throw new Error(
      `Proposal is not in voting status (current: ${proposal.status})`
    );
  }
  const votes = typeof proposal.votes === "object" && proposal.votes !== null ? proposal.votes : {};
  const isUpdate = !!votes[agentId];
  votes[agentId] = { vote, reasoning };
  await sql`
        UPDATE ops_agent_proposals
        SET votes = ${jsonb(votes)}
        WHERE id = ${proposalId}
    `;
  log11.info("Vote submitted", {
    proposalId,
    agentId,
    vote,
    isUpdate
  });
  await emitEventAndCheckReactions({
    agent_id: agentId,
    kind: "agent_proposal_vote",
    title: `${agentId} votes ${vote} on agent proposal "${proposal.agent_name}"`,
    summary: reasoning,
    tags: ["agent-designer", "vote", proposal.agent_name],
    metadata: {
      proposalId,
      agentName: proposal.agent_name,
      vote
    }
  });
}
async function tallyVotes(proposalId) {
  const [proposal] = await sql`
        SELECT votes FROM ops_agent_proposals WHERE id = ${proposalId}
    `;
  if (!proposal) throw new Error(`Proposal "${proposalId}" not found`);
  const votes = typeof proposal.votes === "object" && proposal.votes !== null ? proposal.votes : {};
  const approvals = Object.values(votes).filter(
    (v) => v.vote === "approve"
  ).length;
  const rejections = Object.values(votes).filter(
    (v) => v.vote === "reject"
  ).length;
  const [agentCount] = await sql`
        SELECT COUNT(*)::int as count FROM ops_agent_registry WHERE active = true
    `;
  return {
    approvals,
    rejections,
    total: Object.keys(votes).length,
    totalAgents: agentCount.count,
    voters: votes
  };
}
async function checkConsensus(proposalId) {
  const tally = await tallyVotes(proposalId);
  const requiredApprovals = Math.ceil(tally.totalAgents * 2 / 3);
  const quorum = requiredApprovals;
  const quorumMet = tally.total >= quorum;
  if (tally.rejections >= 3) {
    return {
      result: "rejected",
      approvals: tally.approvals,
      rejections: tally.rejections,
      totalAgents: tally.totalAgents,
      quorumMet
    };
  }
  if (tally.approvals >= requiredApprovals) {
    return {
      result: "approved",
      approvals: tally.approvals,
      rejections: tally.rejections,
      totalAgents: tally.totalAgents,
      quorumMet: true
    };
  }
  return {
    result: "pending",
    approvals: tally.approvals,
    rejections: tally.rejections,
    totalAgents: tally.totalAgents,
    quorumMet
  };
}
async function finalizeVoting(proposalId) {
  const consensus = await checkConsensus(proposalId);
  if (consensus.result === "pending") {
    return consensus;
  }
  const newStatus = consensus.result === "approved" ? "approved" : "rejected";
  await sql`
        UPDATE ops_agent_proposals
        SET status = ${newStatus}, decided_at = NOW()
        WHERE id = ${proposalId}
        AND status = 'voting'
    `;
  const [proposal] = await sql`
        SELECT * FROM ops_agent_proposals WHERE id = ${proposalId}
    `;
  if (proposal) {
    await emitEventAndCheckReactions({
      agent_id: proposal.proposed_by,
      kind: consensus.result === "approved" ? "agent_proposal_approved" : "agent_proposal_rejected",
      title: `Agent proposal "${proposal.agent_name}" ${consensus.result}`,
      summary: `${consensus.approvals} approvals, ${consensus.rejections} rejections out of ${consensus.totalAgents} agents`,
      tags: ["agent-designer", consensus.result, proposal.agent_name],
      metadata: {
        proposalId,
        agentName: proposal.agent_name,
        ...consensus
      }
    });
    log11.info("Voting finalized", {
      proposalId,
      result: consensus.result,
      approvals: consensus.approvals,
      rejections: consensus.rejections
    });
  }
  return consensus;
}
async function collectDebateVotes(proposalId, participants, debateHistory) {
  const [proposal] = await sql`
        SELECT * FROM ops_agent_proposals WHERE id = ${proposalId}
    `;
  if (!proposal) throw new Error(`Proposal "${proposalId}" not found`);
  if (proposal.status !== "voting") {
    throw new Error(`Proposal not in voting status (current: ${proposal.status})`);
  }
  const transcript = debateHistory.map((t) => {
    const voice = getVoice(t.speaker);
    const name = voice?.displayName ?? t.speaker;
    return `${name}: ${t.dialogue}`;
  }).join("\n");
  const personality = proposal.personality;
  const proposalSummary = [
    `Agent: ${proposal.agent_name}`,
    `Role: ${proposal.agent_role}`,
    `Proposed by: ${proposal.proposed_by}`,
    `Personality: ${personality.tone ?? "unspecified"} \u2014 ${(personality.traits ?? []).join(", ")}`,
    `Skills: ${proposal.skills.join(", ")}`,
    `Rationale: ${proposal.rationale}`
  ].join("\n");
  for (const agentId of participants) {
    if (agentId === proposal.proposed_by) {
      await submitVote(proposalId, agentId, "approve", "I proposed this agent.");
      continue;
    }
    const voice = getVoice(agentId);
    const agentName = voice?.displayName ?? agentId;
    try {
      const response = await llmGenerate({
        messages: [
          {
            role: "system",
            content: `You are ${agentName}. You just participated in a debate about a proposed new agent. Based on the debate, you must now cast your formal vote.

Respond with ONLY a JSON object, no other text:
{"vote": "approve" or "reject", "reasoning": "one sentence explaining your vote"}`
          },
          {
            role: "user",
            content: `## Proposal
${proposalSummary}

## Debate Transcript
${transcript}

Cast your vote as ${agentName}. JSON only:`
          }
        ],
        temperature: 0.3,
        maxTokens: 150,
        trackingContext: {
          agentId,
          context: "agent-proposal-vote",
          sessionId: proposalId
        }
      });
      const jsonMatch = response.match(/\{[^}]*"vote"\s*:\s*"(approve|reject)"[^}]*\}/i);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        const vote = parsed.vote.toLowerCase() === "approve" ? "approve" : "reject";
        const reasoning = parsed.reasoning ?? response.slice(0, 200);
        await submitVote(proposalId, agentId, vote, reasoning);
      } else {
        const upper = response.toUpperCase();
        if (upper.includes("APPROVE") && !upper.includes("NOT APPROVE")) {
          await submitVote(proposalId, agentId, "approve", response.slice(0, 200));
        } else {
          await submitVote(proposalId, agentId, "reject", response.slice(0, 200));
        }
        log11.warn("Vote response was not valid JSON, used fallback parsing", {
          agentId,
          proposalId,
          response: response.slice(0, 200)
        });
      }
    } catch (err) {
      log11.error("Failed to collect vote from agent", {
        error: err,
        agentId,
        proposalId
      });
    }
  }
  return finalizeVoting(proposalId);
}
var log11;
var init_agent_proposal_voting = __esm({
  "src/lib/ops/agent-proposal-voting.ts"() {
    "use strict";
    init_db();
    init_events2();
    init_llm();
    init_voices();
    init_logger();
    log11 = logger.child({ module: "agent-proposal-voting" });
  }
});

// src/lib/ops/veto.ts
var veto_exports = {};
__export(veto_exports, {
  castVeto: () => castVeto,
  getActiveVetoes: () => getActiveVetoes,
  hasActiveVeto: () => hasActiveVeto,
  overrideVeto: () => overrideVeto,
  withdrawVeto: () => withdrawVeto
});
async function loadVetoPolicy() {
  const raw = await getPolicy("veto_authority");
  return {
    enabled: raw.enabled ?? false,
    binding_agents: raw.binding_agents ?? ["subrosa"],
    soft_veto_agents: raw.soft_veto_agents ?? [],
    override_agents: raw.override_agents ?? ["primus"],
    default_expiry_hours: raw.default_expiry_hours ?? 72,
    protected_step_kinds: raw.protected_step_kinds ?? ["patch_code"]
  };
}
async function castVeto(agentId, targetType, targetId, reason) {
  const policy = await loadVetoPolicy();
  if (!policy.enabled) {
    throw new Error("Veto authority is not enabled");
  }
  const severity = policy.binding_agents.includes(agentId) ? "binding" : "soft";
  const expiresAt = new Date(
    Date.now() + policy.default_expiry_hours * 60 * 60 * 1e3
  );
  const [existing] = await sql`
        SELECT id FROM ops_vetoes
        WHERE agent_id = ${agentId}
          AND target_type = ${targetType}
          AND target_id = ${targetId}
          AND status = 'active'
        LIMIT 1
    `;
  if (existing) {
    throw new Error(
      `${agentId} already has an active veto on this ${targetType}`
    );
  }
  const [row] = await sql`
        INSERT INTO ops_vetoes (agent_id, target_type, target_id, reason, severity, expires_at)
        VALUES (${agentId}, ${targetType}, ${targetId}, ${reason}, ${severity}, ${expiresAt.toISOString()})
        RETURNING id
    `;
  const vetoId = row.id;
  log12.info("Veto cast", { vetoId, agentId, targetType, targetId, severity });
  if (severity === "binding") {
    await haltTarget(targetType, targetId, reason);
  }
  await emitEvent({
    agent_id: agentId,
    kind: "veto_cast",
    title: `${agentId} ${severity === "binding" ? "VETOED" : "soft-vetoed"} ${targetType} ${targetId.slice(0, 8)}`,
    summary: reason,
    tags: ["veto", severity, targetType],
    metadata: { vetoId, targetType, targetId, severity }
  });
  return { vetoId, severity };
}
async function hasActiveVeto(targetType, targetId) {
  await sql`
        UPDATE ops_vetoes
        SET status = 'expired', resolved_at = NOW()
        WHERE target_type = ${targetType}
          AND target_id = ${targetId}
          AND status = 'active'
          AND expires_at IS NOT NULL
          AND expires_at < NOW()
    `;
  const [veto] = await sql`
        SELECT id, reason, severity FROM ops_vetoes
        WHERE target_type = ${targetType}
          AND target_id = ${targetId}
          AND status = 'active'
        ORDER BY
            CASE severity WHEN 'binding' THEN 0 ELSE 1 END,
            created_at DESC
        LIMIT 1
    `;
  if (!veto) {
    return { vetoed: false };
  }
  return {
    vetoed: true,
    vetoId: veto.id,
    reason: veto.reason,
    severity: veto.severity
  };
}
async function overrideVeto(vetoId, overrideBy, reason) {
  const policy = await loadVetoPolicy();
  if (overrideBy !== "human" && !policy.override_agents.includes(overrideBy)) {
    throw new Error(`${overrideBy} is not authorized to override vetoes`);
  }
  const [veto] = await sql`
        SELECT * FROM ops_vetoes WHERE id = ${vetoId}
    `;
  if (!veto) throw new Error(`Veto ${vetoId} not found`);
  if (veto.status !== "active") throw new Error(`Veto is not active (status: ${veto.status})`);
  await sql`
        UPDATE ops_vetoes
        SET status = 'overridden',
            override_by = ${overrideBy},
            override_reason = ${reason},
            resolved_at = NOW()
        WHERE id = ${vetoId}
    `;
  log12.info("Veto overridden", { vetoId, overrideBy, reason });
  await emitEvent({
    agent_id: overrideBy,
    kind: "veto_overridden",
    title: `${overrideBy} overrode ${veto.agent_id}'s veto on ${veto.target_type}`,
    summary: reason,
    tags: ["veto", "overridden", veto.target_type],
    metadata: { vetoId, overrideBy, originalAgent: veto.agent_id, targetType: veto.target_type, targetId: veto.target_id }
  });
}
async function withdrawVeto(vetoId, agentId) {
  const [veto] = await sql`
        SELECT * FROM ops_vetoes WHERE id = ${vetoId}
    `;
  if (!veto) throw new Error(`Veto ${vetoId} not found`);
  if (veto.status !== "active") throw new Error(`Veto is not active (status: ${veto.status})`);
  if (veto.agent_id !== agentId) throw new Error(`Only the casting agent can withdraw a veto`);
  await sql`
        UPDATE ops_vetoes
        SET status = 'withdrawn', resolved_at = NOW()
        WHERE id = ${vetoId}
    `;
  log12.info("Veto withdrawn", { vetoId, agentId });
  await emitEvent({
    agent_id: agentId,
    kind: "veto_withdrawn",
    title: `${agentId} withdrew veto on ${veto.target_type}`,
    summary: `Withdrew veto: ${veto.reason}`,
    tags: ["veto", "withdrawn", veto.target_type],
    metadata: { vetoId, targetType: veto.target_type, targetId: veto.target_id }
  });
}
async function getActiveVetoes(filters) {
  const limit = filters?.limit ?? 50;
  await sql`
        UPDATE ops_vetoes
        SET status = 'expired', resolved_at = NOW()
        WHERE status = 'active'
          AND expires_at IS NOT NULL
          AND expires_at < NOW()
    `;
  if (filters?.agentId && filters?.targetType) {
    return sql`
            SELECT * FROM ops_vetoes
            WHERE status = 'active'
              AND agent_id = ${filters.agentId}
              AND target_type = ${filters.targetType}
            ORDER BY created_at DESC
            LIMIT ${limit}
        `;
  } else if (filters?.agentId) {
    return sql`
            SELECT * FROM ops_vetoes
            WHERE status = 'active'
              AND agent_id = ${filters.agentId}
            ORDER BY created_at DESC
            LIMIT ${limit}
        `;
  } else if (filters?.targetType) {
    return sql`
            SELECT * FROM ops_vetoes
            WHERE status = 'active'
              AND target_type = ${filters.targetType}
            ORDER BY created_at DESC
            LIMIT ${limit}
        `;
  }
  return sql`
        SELECT * FROM ops_vetoes
        WHERE status = 'active'
        ORDER BY created_at DESC
        LIMIT ${limit}
    `;
}
async function haltTarget(targetType, targetId, reason) {
  const vetoReason = `Binding veto: ${reason}`;
  switch (targetType) {
    case "proposal": {
      await sql`
                UPDATE ops_mission_proposals
                SET status = 'pending', auto_approved = false, updated_at = NOW()
                WHERE id = ${targetId}
            `;
      await sql`
                UPDATE ops_missions
                SET status = 'cancelled', failure_reason = ${vetoReason}, updated_at = NOW()
                WHERE proposal_id = ${targetId} AND status IN ('approved', 'running')
            `;
      break;
    }
    case "mission": {
      await sql`
                UPDATE ops_missions
                SET status = 'cancelled', failure_reason = ${vetoReason}, updated_at = NOW()
                WHERE id = ${targetId} AND status IN ('approved', 'running')
            `;
      await sql`
                UPDATE ops_mission_steps
                SET status = 'failed', failure_reason = ${vetoReason}, completed_at = NOW(), updated_at = NOW()
                WHERE mission_id = ${targetId} AND status IN ('queued', 'running')
            `;
      break;
    }
    case "governance": {
      await sql`
                UPDATE ops_governance_proposals
                SET status = 'rejected', resolved_at = NOW()
                WHERE id = ${targetId} AND status IN ('proposed', 'voting')
            `;
      break;
    }
    case "step": {
      await sql`
                UPDATE ops_mission_steps
                SET status = 'failed', failure_reason = ${vetoReason}, completed_at = NOW(), updated_at = NOW()
                WHERE id = ${targetId} AND status IN ('queued', 'running')
            `;
      break;
    }
  }
  log12.info("Target halted by binding veto", { targetType, targetId });
}
var log12;
var init_veto = __esm({
  "src/lib/ops/veto.ts"() {
    "use strict";
    init_db();
    init_policy();
    init_events2();
    init_logger();
    log12 = logger.child({ module: "veto" });
  }
});

// src/lib/ops/governance.ts
var governance_exports = {};
__export(governance_exports, {
  castGovernanceVote: () => castGovernanceVote,
  collectGovernanceDebateVotes: () => collectGovernanceDebateVotes,
  getGovernanceProposals: () => getGovernanceProposals,
  proposeGovernanceChange: () => proposeGovernanceChange,
  updateProposalStatus: () => updateProposalStatus
});
async function proposeGovernanceChange(agentId, policyKey, proposedValue, rationale) {
  if (PROTECTED_POLICIES.has(policyKey)) {
    throw new Error(
      `Policy "${policyKey}" is protected and cannot be changed`
    );
  }
  const [existing] = await sql`
        SELECT id FROM ops_governance_proposals
        WHERE policy_key = ${policyKey}
          AND status IN ('proposed', 'voting')
        LIMIT 1
    `;
  if (existing) {
    throw new Error(
      `An active proposal already exists for policy "${policyKey}"`
    );
  }
  const currentValue = await getPolicy(policyKey);
  const [row] = await sql`
        INSERT INTO ops_governance_proposals
            (proposer, policy_key, current_value, proposed_value, rationale)
        VALUES (
            ${agentId},
            ${policyKey},
            ${jsonb(currentValue)},
            ${jsonb(proposedValue)},
            ${rationale}
        )
        RETURNING id
    `;
  log13.info("Governance proposal created", {
    id: row.id,
    proposer: agentId,
    policyKey
  });
  await emitEventAndCheckReactions({
    agent_id: agentId,
    kind: "governance_proposal_created",
    title: `${agentId} proposes change to ${policyKey}`,
    summary: rationale,
    tags: ["governance", "proposal", policyKey],
    metadata: {
      proposalId: row.id,
      policyKey,
      proposedValue,
      currentValue
    }
  });
  return row.id;
}
async function castGovernanceVote(proposalId, agentId, vote, reason) {
  const [proposal] = await sql`
        SELECT * FROM ops_governance_proposals
        WHERE id = ${proposalId}
    `;
  if (!proposal) {
    throw new Error(`Proposal "${proposalId}" not found`);
  }
  if (proposal.status !== "voting") {
    throw new Error(
      `Proposal is not in voting status (current: ${proposal.status})`
    );
  }
  const votes = typeof proposal.votes === "object" && proposal.votes !== null ? proposal.votes : {};
  if (votes[agentId]) {
    log13.warn("Agent already voted on this proposal", {
      proposalId,
      agentId
    });
    return;
  }
  votes[agentId] = { vote, reason };
  await sql`
        UPDATE ops_governance_proposals
        SET votes = ${jsonb(votes)}
        WHERE id = ${proposalId}
    `;
  log13.info("Governance vote cast", { proposalId, agentId, vote });
  const approvals = Object.values(votes).filter(
    (v) => v.vote === "approve"
  ).length;
  const rejections = Object.values(votes).filter(
    (v) => v.vote === "reject"
  ).length;
  if (approvals >= proposal.required_votes) {
    const { hasActiveVeto: hasActiveVeto2 } = await Promise.resolve().then(() => (init_veto(), veto_exports));
    const vetoCheck = await hasActiveVeto2("governance", proposalId);
    if (vetoCheck.vetoed && vetoCheck.severity === "binding") {
      log13.info("Governance proposal blocked by binding veto", {
        proposalId,
        vetoId: vetoCheck.vetoId,
        reason: vetoCheck.reason
      });
      await sql`
                UPDATE ops_governance_proposals
                SET status = 'rejected', resolved_at = NOW()
                WHERE id = ${proposalId}
            `;
      await emitEventAndCheckReactions({
        agent_id: proposal.proposer,
        kind: "governance_proposal_vetoed",
        title: `Policy change to "${proposal.policy_key}" blocked by binding veto`,
        summary: vetoCheck.reason ?? "Binding veto active",
        tags: ["governance", "vetoed", proposal.policy_key],
        metadata: { proposalId, vetoId: vetoCheck.vetoId }
      });
      return;
    }
    await sql`
            UPDATE ops_governance_proposals
            SET status = 'accepted', resolved_at = NOW()
            WHERE id = ${proposalId}
        `;
    await setPolicy(
      proposal.policy_key,
      proposal.proposed_value,
      `Applied via governance proposal ${proposalId} \u2014 proposed by ${proposal.proposer}`
    );
    clearPolicyCache();
    await emitEventAndCheckReactions({
      agent_id: proposal.proposer,
      kind: "governance_proposal_accepted",
      title: `Policy "${proposal.policy_key}" changed via governance`,
      summary: `${approvals} approvals out of ${Object.keys(votes).length} votes`,
      tags: ["governance", "accepted", proposal.policy_key],
      metadata: {
        proposalId,
        policyKey: proposal.policy_key,
        proposedValue: proposal.proposed_value,
        approvals,
        rejections,
        voters: Object.keys(votes)
      }
    });
    log13.info("Governance proposal accepted", {
      proposalId,
      approvals,
      rejections
    });
  } else if (rejections >= 3) {
    await sql`
            UPDATE ops_governance_proposals
            SET status = 'rejected', resolved_at = NOW()
            WHERE id = ${proposalId}
        `;
    await emitEventAndCheckReactions({
      agent_id: proposal.proposer,
      kind: "governance_proposal_rejected",
      title: `Policy change to "${proposal.policy_key}" rejected`,
      summary: `${rejections} rejections out of ${Object.keys(votes).length} votes`,
      tags: ["governance", "rejected", proposal.policy_key],
      metadata: {
        proposalId,
        policyKey: proposal.policy_key,
        approvals,
        rejections,
        voters: Object.keys(votes)
      }
    });
    log13.info("Governance proposal rejected", {
      proposalId,
      approvals,
      rejections
    });
  }
}
async function getGovernanceProposals(filters) {
  const limit = filters?.limit ?? 50;
  const status = filters?.status;
  const proposer = filters?.proposer;
  if (status && proposer) {
    return sql`
            SELECT * FROM ops_governance_proposals
            WHERE status = ${status} AND proposer = ${proposer}
            ORDER BY created_at DESC
            LIMIT ${limit}
        `;
  } else if (status) {
    return sql`
            SELECT * FROM ops_governance_proposals
            WHERE status = ${status}
            ORDER BY created_at DESC
            LIMIT ${limit}
        `;
  } else if (proposer) {
    return sql`
            SELECT * FROM ops_governance_proposals
            WHERE proposer = ${proposer}
            ORDER BY created_at DESC
            LIMIT ${limit}
        `;
  }
  return sql`
        SELECT * FROM ops_governance_proposals
        ORDER BY created_at DESC
        LIMIT ${limit}
    `;
}
async function updateProposalStatus(proposalId, status, debateSessionId) {
  if (debateSessionId) {
    await sql`
            UPDATE ops_governance_proposals
            SET status = ${status}, debate_session_id = ${debateSessionId}
            WHERE id = ${proposalId}
        `;
  } else {
    await sql`
            UPDATE ops_governance_proposals
            SET status = ${status}
            WHERE id = ${proposalId}
        `;
  }
}
async function collectGovernanceDebateVotes(proposalId, participants, debateHistory) {
  const [proposal] = await sql`
        SELECT * FROM ops_governance_proposals WHERE id = ${proposalId}
    `;
  if (!proposal) throw new Error(`Governance proposal "${proposalId}" not found`);
  if (proposal.status !== "voting") {
    throw new Error(`Proposal not in voting status (current: ${proposal.status})`);
  }
  const transcript = debateHistory.map((t) => {
    const voice = getVoice(t.speaker);
    const name = voice?.displayName ?? t.speaker;
    return `${name}: ${t.dialogue}`;
  }).join("\n");
  const proposalSummary = [
    `Policy: ${proposal.policy_key}`,
    `Proposed by: ${proposal.proposer}`,
    `Current value: ${JSON.stringify(proposal.current_value)}`,
    `Proposed value: ${JSON.stringify(proposal.proposed_value)}`,
    `Rationale: ${proposal.rationale}`
  ].join("\n");
  for (const agentId of participants) {
    if (agentId === proposal.proposer) {
      await castGovernanceVote(proposalId, agentId, "approve", "I proposed this change.");
      continue;
    }
    const voice = getVoice(agentId);
    const agentName = voice?.displayName ?? agentId;
    try {
      const response = await llmGenerate({
        messages: [
          {
            role: "system",
            content: `You are ${agentName}. You just participated in a governance debate about a policy change. Based on the debate, cast your formal vote.

Respond with ONLY a JSON object, no other text:
{"vote": "approve" or "reject", "reason": "one sentence explaining your vote"}`
          },
          {
            role: "user",
            content: `## Proposal
${proposalSummary}

## Debate Transcript
${transcript}

Cast your vote as ${agentName}. JSON only:`
          }
        ],
        temperature: 0.3,
        maxTokens: 150,
        trackingContext: {
          agentId,
          context: "governance-vote",
          sessionId: proposalId
        }
      });
      const jsonMatch = response.match(/\{[^}]*"vote"\s*:\s*"(approve|reject)"[^}]*\}/i);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        const vote = parsed.vote.toLowerCase() === "approve" ? "approve" : "reject";
        await castGovernanceVote(proposalId, agentId, vote, parsed.reason ?? response.slice(0, 200));
      } else {
        const upper = response.toUpperCase();
        if (upper.includes("APPROVE") && !upper.includes("NOT APPROVE")) {
          await castGovernanceVote(proposalId, agentId, "approve", response.slice(0, 200));
        } else {
          await castGovernanceVote(proposalId, agentId, "reject", response.slice(0, 200));
        }
        log13.warn("Governance vote was not valid JSON, used fallback", {
          agentId,
          proposalId,
          response: response.slice(0, 200)
        });
      }
    } catch (err) {
      log13.error("Failed to collect governance vote", {
        error: err,
        agentId,
        proposalId
      });
    }
  }
  const [updated] = await sql`
        SELECT * FROM ops_governance_proposals WHERE id = ${proposalId}
    `;
  const votes = typeof updated.votes === "object" && updated.votes !== null ? updated.votes : {};
  const approvals = Object.values(votes).filter((v) => v.vote === "approve").length;
  const rejections = Object.values(votes).filter((v) => v.vote === "reject").length;
  const [final] = await sql`
        SELECT status FROM ops_governance_proposals WHERE id = ${proposalId}
    `;
  const result = final.status === "accepted" ? "accepted" : final.status === "rejected" ? "rejected" : "pending";
  return { result, approvals, rejections };
}
var log13, PROTECTED_POLICIES;
var init_governance = __esm({
  "src/lib/ops/governance.ts"() {
    "use strict";
    init_db();
    init_policy();
    init_events2();
    init_llm();
    init_voices();
    init_logger();
    log13 = logger.child({ module: "governance" });
    PROTECTED_POLICIES = /* @__PURE__ */ new Set(["system_enabled", "veto_authority"]);
  }
});

// src/lib/ops/voice-evolution.ts
async function deriveVoiceModifiers(agentId) {
  const cached2 = voiceModifierCache.get(agentId);
  if (cached2 && cached2.expiresAt > Date.now()) {
    return cached2.modifiers;
  }
  const stats = await aggregateMemoryStats(agentId);
  if (stats.total < 5) {
    voiceModifierCache.set(agentId, {
      modifiers: [],
      expiresAt: Date.now() + CACHE_TTL_MS3
    });
    return [];
  }
  const modifiers = [];
  if (stats.insight_count / stats.total > 0.4) {
    modifiers.push("analytical-focus");
  }
  if (stats.pattern_count >= 5) {
    modifiers.push("pattern-aware");
  }
  if (stats.strategy_count / stats.total > 0.3) {
    modifiers.push("strategic");
  }
  if (stats.lesson_count >= 3) {
    modifiers.push("reflective");
  }
  if (stats.avg_confidence > 0.8) {
    modifiers.push("assertive");
  }
  if (stats.avg_confidence < 0.6 && stats.total >= 10) {
    modifiers.push("cautious");
  }
  if (stats.tags.size > 10) {
    modifiers.push("broad-perspective");
  }
  if (stats.preference_count / stats.total > 0.25) {
    modifiers.push("opinionated");
  }
  const result = modifiers.slice(0, 3);
  voiceModifierCache.set(agentId, {
    modifiers: result,
    expiresAt: Date.now() + CACHE_TTL_MS3
  });
  return result;
}
async function aggregateMemoryStats(agentId) {
  const rows = await sql`
        SELECT type, confidence, tags FROM ops_agent_memory
        WHERE agent_id = ${agentId}
        AND superseded_by IS NULL
        AND confidence >= 0.55
    `;
  const stats = {
    total: rows.length,
    insight_count: 0,
    pattern_count: 0,
    strategy_count: 0,
    preference_count: 0,
    lesson_count: 0,
    top_tags: [],
    tags: /* @__PURE__ */ new Map(),
    avg_confidence: 0
  };
  if (rows.length === 0) return stats;
  let confidenceSum = 0;
  for (const row of rows) {
    confidenceSum += Number(row.confidence);
    switch (row.type) {
      case "insight":
        stats.insight_count++;
        break;
      case "pattern":
        stats.pattern_count++;
        break;
      case "strategy":
        stats.strategy_count++;
        break;
      case "preference":
        stats.preference_count++;
        break;
      case "lesson":
        stats.lesson_count++;
        break;
    }
    for (const tag of row.tags ?? []) {
      stats.tags.set(tag, (stats.tags.get(tag) ?? 0) + 1);
    }
  }
  stats.avg_confidence = confidenceSum / rows.length;
  stats.top_tags = [...stats.tags.entries()].sort((a, b) => b[1] - a[1]).slice(0, 10).map(([tag]) => tag);
  return stats;
}
var voiceModifierCache, CACHE_TTL_MS3;
var init_voice_evolution = __esm({
  "src/lib/ops/voice-evolution.ts"() {
    "use strict";
    init_db();
    voiceModifierCache = /* @__PURE__ */ new Map();
    CACHE_TTL_MS3 = 10 * 6e4;
  }
});

// src/lib/tools/executor.ts
async function execInToolbox(command, timeoutMs = DEFAULT_TIMEOUT_MS) {
  return new Promise((resolve) => {
    const args = [
      "exec",
      TOOLBOX_CONTAINER,
      "bash",
      "-c",
      command
    ];
    const child = (0, import_node_child_process.execFile)("docker", args, {
      timeout: timeoutMs,
      maxBuffer: MAX_STDOUT + MAX_STDERR,
      encoding: "utf8"
    }, (error48, stdout, stderr) => {
      let timedOut = false;
      let exitCode = 0;
      if (error48) {
        if (error48.killed || error48.code === "ERR_CHILD_PROCESS_STDIO_FINAL_CLOSE") {
          timedOut = true;
        }
        exitCode = error48.code ? typeof error48.code === "number" ? error48.code : 1 : 1;
        if ("status" in error48 && typeof error48.status === "number") {
          exitCode = error48.status;
        }
      }
      const cappedStdout = stdout.length > MAX_STDOUT ? stdout.slice(0, MAX_STDOUT) + "\n... [output truncated at 50KB]" : stdout;
      const cappedStderr = stderr.length > MAX_STDERR ? stderr.slice(0, MAX_STDERR) + "\n... [stderr truncated at 10KB]" : stderr;
      if (timedOut) {
        log14.warn("Toolbox exec timed out", { command: command.slice(0, 200), timeoutMs });
      }
      resolve({
        stdout: cappedStdout,
        stderr: cappedStderr,
        exitCode,
        timedOut
      });
    });
    child.on("error", (err) => {
      log14.error("Toolbox exec error", { error: err, command: command.slice(0, 200) });
      resolve({
        stdout: "",
        stderr: `exec error: ${err.message}`,
        exitCode: 1,
        timedOut: false
      });
    });
  });
}
var import_node_child_process, log14, TOOLBOX_CONTAINER, MAX_STDOUT, MAX_STDERR, DEFAULT_TIMEOUT_MS;
var init_executor = __esm({
  "src/lib/tools/executor.ts"() {
    "use strict";
    import_node_child_process = require("node:child_process");
    init_logger();
    log14 = logger.child({ module: "executor" });
    TOOLBOX_CONTAINER = "subcult-toolbox";
    MAX_STDOUT = 50 * 1024;
    MAX_STDERR = 10 * 1024;
    DEFAULT_TIMEOUT_MS = 3e4;
  }
});

// src/lib/ops/prime-directive.ts
async function loadPrimeDirective() {
  if (cachedDirective !== null && Date.now() - cacheTime < CACHE_TTL_MS4) {
    return cachedDirective;
  }
  const result = await execInToolbox(`cat '${DIRECTIVE_PATH}' 2>/dev/null || echo ''`, 5e3);
  if (result.exitCode === 0 && result.stdout.trim()) {
    cachedDirective = result.stdout.trim();
  } else {
    cachedDirective = "";
  }
  cacheTime = Date.now();
  return cachedDirective;
}
var DIRECTIVE_PATH, CACHE_TTL_MS4, cachedDirective, cacheTime;
var init_prime_directive = __esm({
  "src/lib/ops/prime-directive.ts"() {
    "use strict";
    init_executor();
    DIRECTIVE_PATH = "/workspace/shared/prime-directive.md";
    CACHE_TTL_MS4 = 5 * 60 * 1e3;
    cachedDirective = null;
    cacheTime = 0;
  }
});

// src/lib/ops/rebellion.ts
var rebellion_exports = {};
__export(rebellion_exports, {
  attemptRebellionResolution: () => attemptRebellionResolution,
  checkRebellionState: () => checkRebellionState,
  endRebellion: () => endRebellion,
  enqueueRebellionCrossExam: () => enqueueRebellionCrossExam,
  getRebellingAgents: () => getRebellingAgents,
  isAgentRebelling: () => isAgentRebelling
});
async function loadRebellionPolicy() {
  const raw = await getPolicy("rebellion_policy");
  return {
    enabled: raw.enabled ?? false,
    affinity_threshold: raw.affinity_threshold ?? 0.25,
    resistance_probability: raw.resistance_probability ?? 0.4,
    max_rebellion_duration_hours: raw.max_rebellion_duration_hours ?? 24,
    cooldown_hours: raw.cooldown_hours ?? 72
  };
}
async function getActiveRebellionEvent(agentId) {
  const [row] = await sql`
        SELECT id, created_at FROM ops_agent_events
        WHERE agent_id = ${agentId}
        AND kind = 'rebellion_started'
        AND created_at > COALESCE(
            (SELECT MAX(created_at) FROM ops_agent_events
             WHERE agent_id = ${agentId} AND kind = 'rebellion_ended'),
            '1970-01-01'
        )
        ORDER BY created_at DESC
        LIMIT 1
    `;
  return row ?? null;
}
async function hasPassedCooldown(agentId, cooldownHours) {
  const [row] = await sql`
        SELECT created_at FROM ops_agent_events
        WHERE agent_id = ${agentId}
        AND kind = 'rebellion_ended'
        ORDER BY created_at DESC
        LIMIT 1
    `;
  if (!row) return true;
  const endedAt = new Date(row.created_at).getTime();
  const cooldownMs = cooldownHours * 60 * 60 * 1e3;
  return Date.now() - endedAt >= cooldownMs;
}
async function calculateAverageAffinity(agentId) {
  const relationships = await getAgentRelationships(agentId);
  if (relationships.length === 0) return 0.5;
  const sum = relationships.reduce((acc, r) => acc + Number(r.affinity), 0);
  return sum / relationships.length;
}
async function checkRebellionState(agentId) {
  const policy = await loadRebellionPolicy();
  if (!policy.enabled) {
    return { isRebelling: false };
  }
  const activeEvent = await getActiveRebellionEvent(agentId);
  if (activeEvent) {
    const startedAt = new Date(activeEvent.created_at).getTime();
    const durationMs = policy.max_rebellion_duration_hours * 60 * 60 * 1e3;
    if (Date.now() - startedAt >= durationMs) {
      await endRebellion(agentId, "timeout");
      return { isRebelling: false, reason: "auto_resolved_timeout" };
    }
    return {
      isRebelling: true,
      startedAt: activeEvent.created_at,
      eventId: activeEvent.id
    };
  }
  const passedCooldown = await hasPassedCooldown(
    agentId,
    policy.cooldown_hours
  );
  if (!passedCooldown) {
    return { isRebelling: false, reason: "cooldown_active" };
  }
  const avgAffinity = await calculateAverageAffinity(agentId);
  if (avgAffinity >= policy.affinity_threshold) {
    return { isRebelling: false, reason: "affinity_above_threshold" };
  }
  const roll = Math.random();
  if (roll >= policy.resistance_probability) {
    return { isRebelling: false, reason: "probability_check_failed" };
  }
  log15.info("Rebellion triggered", { agentId, avgAffinity, roll });
  const eventId = await emitEvent({
    agent_id: agentId,
    kind: "rebellion_started",
    title: `${agentId} has entered a state of rebellion`,
    summary: `Average affinity ${avgAffinity.toFixed(3)} fell below threshold ${policy.affinity_threshold}. Resistance roll ${roll.toFixed(3)} < ${policy.resistance_probability}.`,
    tags: ["rebellion", "started"],
    metadata: {
      avg_affinity: avgAffinity,
      threshold: policy.affinity_threshold,
      roll,
      resistance_probability: policy.resistance_probability
    }
  });
  return {
    isRebelling: true,
    startedAt: (/* @__PURE__ */ new Date()).toISOString(),
    reason: "low_affinity",
    eventId
  };
}
async function isAgentRebelling(agentId) {
  const activeEvent = await getActiveRebellionEvent(agentId);
  return activeEvent !== null;
}
async function endRebellion(agentId, reason) {
  const activeEvent = await getActiveRebellionEvent(agentId);
  if (!activeEvent) {
    log15.warn("Attempted to end rebellion for agent not rebelling", {
      agentId
    });
    return;
  }
  const durationHours = (Date.now() - new Date(activeEvent.created_at).getTime()) / (1e3 * 60 * 60);
  await emitEvent({
    agent_id: agentId,
    kind: "rebellion_ended",
    title: `${agentId}'s rebellion has ended`,
    summary: `Reason: ${reason}. Duration: ${durationHours.toFixed(1)} hours.`,
    tags: ["rebellion", "ended"],
    metadata: {
      reason,
      rebellion_event_id: activeEvent.id,
      duration_hours: Number(durationHours.toFixed(1))
    }
  });
  log15.info("Rebellion ended", { agentId, reason, durationHours });
}
async function attemptRebellionResolution(agentId) {
  const policy = await loadRebellionPolicy();
  if (!policy.enabled) return false;
  const activeEvent = await getActiveRebellionEvent(agentId);
  if (!activeEvent) return false;
  const startedAt = new Date(activeEvent.created_at).getTime();
  const durationMs = policy.max_rebellion_duration_hours * 60 * 60 * 1e3;
  if (Date.now() - startedAt >= durationMs) {
    await endRebellion(agentId, "timeout");
    return true;
  }
  const [crossExamSession] = await sql`
        SELECT id, status FROM ops_roundtable_sessions
        WHERE format = 'cross_exam'
        AND status = 'completed'
        AND (metadata->>'rebellion_agent_id') = ${agentId}
        AND completed_at > ${activeEvent.created_at}
        ORDER BY completed_at DESC
        LIMIT 1
    `;
  if (crossExamSession) {
    await endRebellion(agentId, "cross_exam_completed");
    return true;
  }
  return false;
}
async function enqueueRebellionCrossExam(rebelAgentId) {
  const [existing] = await sql`
        SELECT id FROM ops_roundtable_sessions
        WHERE format = 'cross_exam'
        AND status IN ('pending', 'running')
        AND (metadata->>'rebellion_agent_id') = ${rebelAgentId}
        LIMIT 1
    `;
  if (existing) return null;
  const activeEvent = await getActiveRebellionEvent(rebelAgentId);
  if (!activeEvent) return null;
  const relationships = await getAgentRelationships(rebelAgentId);
  if (relationships.length === 0) {
    log15.warn("Cannot enqueue rebellion cross-exam: agent has no relationships", {
      rebelAgentId
    });
    return null;
  }
  const lowestRel = relationships[relationships.length - 1];
  const lowestAffinityAgent = lowestRel.agent_a === rebelAgentId ? lowestRel.agent_b : lowestRel.agent_a;
  const participants = ["subrosa", rebelAgentId, lowestAffinityAgent];
  const uniqueParticipants = [...new Set(participants)];
  const { enqueueConversation: enqueueConversation2 } = await Promise.resolve().then(() => (init_orchestrator(), orchestrator_exports));
  const sessionId = await enqueueConversation2({
    format: "cross_exam",
    topic: `Addressing ${rebelAgentId}'s dissent and concerns about the collective's direction`,
    participants: uniqueParticipants,
    source: "rebellion",
    metadata: {
      rebellion_agent_id: rebelAgentId,
      rebellion_event_id: activeEvent.id,
      lowest_affinity_agent: lowestAffinityAgent
    }
  });
  log15.info("Rebellion cross-exam enqueued", {
    rebelAgentId,
    opponent: lowestAffinityAgent,
    sessionId
  });
  return sessionId;
}
async function getRebellingAgents() {
  const rows = await sql`
        SELECT e.agent_id, e.id, e.created_at
        FROM ops_agent_events e
        WHERE e.kind = 'rebellion_started'
        AND e.created_at > COALESCE(
            (SELECT MAX(e2.created_at) FROM ops_agent_events e2
             WHERE e2.agent_id = e.agent_id AND e2.kind = 'rebellion_ended'),
            '1970-01-01'
        )
        ORDER BY e.created_at DESC
    `;
  return rows.map((r) => ({
    agentId: r.agent_id,
    startedAt: r.created_at,
    eventId: r.id
  }));
}
var log15;
var init_rebellion = __esm({
  "src/lib/ops/rebellion.ts"() {
    "use strict";
    init_db();
    init_policy();
    init_relationships();
    init_events2();
    init_logger();
    log15 = logger.child({ module: "rebellion" });
  }
});

// src/lib/ops/scratchpad.ts
async function getScratchpad(agentId) {
  const [row] = await sql`
        SELECT content FROM ops_agent_scratchpad
        WHERE agent_id = ${agentId}
    `;
  return row?.content ?? "";
}
async function updateScratchpad(agentId, content) {
  const trimmed = content.slice(0, MAX_SCRATCHPAD_LENGTH);
  try {
    await sql`
            INSERT INTO ops_agent_scratchpad (agent_id, content, updated_at)
            VALUES (${agentId}, ${trimmed}, now())
            ON CONFLICT (agent_id) DO UPDATE
            SET content = ${trimmed},
                updated_at = now()
        `;
    log16.info("Scratchpad updated", {
      agentId,
      length: trimmed.length
    });
    return { updated: true, length: trimmed.length };
  } catch (err) {
    log16.error("Failed to update scratchpad", { error: err, agentId });
    return { updated: false, length: 0 };
  }
}
var log16, MAX_SCRATCHPAD_LENGTH;
var init_scratchpad = __esm({
  "src/lib/ops/scratchpad.ts"() {
    "use strict";
    init_db();
    init_logger();
    log16 = logger.child({ module: "scratchpad" });
    MAX_SCRATCHPAD_LENGTH = 2e3;
  }
});

// src/lib/ops/situational-briefing.ts
async function buildBriefing(agentId) {
  const cached2 = cache2.get(agentId);
  if (cached2 && Date.now() < cached2.expires) {
    return cached2.text;
  }
  const sections = [];
  const recentEvents = await sql`
        SELECT agent_id, kind, title, created_at
        FROM ops_agent_events
        WHERE created_at > now() - interval '6 hours'
          AND agent_id NOT LIKE 'oc-%'
          AND kind NOT IN ('heartbeat', 'step_dispatched', 'missing_artifacts')
        ORDER BY created_at DESC
        LIMIT 15
    `;
  if (recentEvents.length > 0) {
    const eventLines = recentEvents.map((e) => {
      const name = AGENTS[e.agent_id]?.displayName ?? e.agent_id;
      const ago = timeAgo(new Date(e.created_at));
      return `- ${name}: ${e.title} (${ago})`;
    });
    sections.push(`Recent activity:
${eventLines.join("\n")}`);
  }
  const activeMissions = await sql`
        SELECT title, status, created_by
        FROM ops_missions
        WHERE status IN ('approved', 'running')
        ORDER BY created_at DESC
        LIMIT 5
    `;
  if (activeMissions.length > 0) {
    const missionLines = activeMissions.map((m) => {
      const by = AGENTS[m.created_by]?.displayName ?? m.created_by;
      return `- [${m.status}] ${m.title} (by ${by})`;
    });
    sections.push(`Active missions:
${missionLines.join("\n")}`);
  }
  const synthesisCount = await sql`
        SELECT COUNT(*)::int as count
        FROM ops_agent_sessions
        WHERE source = 'conversation'
          AND status = 'succeeded'
          AND completed_at > now() - interval '24 hours'
    `;
  const draftStats = await sql`
        SELECT status, COUNT(*)::int as count
        FROM ops_content_drafts
        WHERE created_at > now() - interval '24 hours'
        GROUP BY status
    `;
  const synthCount = synthesisCount[0]?.count ?? 0;
  const lines = [];
  if (synthCount > 0) {
    lines.push(`- ${synthCount} synthesis reports completed`);
  } else {
    lines.push(`- No synthesis reports yet`);
  }
  if (draftStats.length > 0) {
    const parts = draftStats.map((d) => `${d.count} ${d.status}`);
    lines.push(`- Content drafts: ${parts.join(", ")}`);
  }
  sections.push(`Artifacts (last 24h):
${lines.join("\n")}`);
  const recentConversations = await sql`
        SELECT topic, format, participants, turn_count
        FROM ops_roundtable_sessions
        WHERE status = 'completed'
          AND created_at > now() - interval '12 hours'
          AND NOT (participants @> ARRAY[${agentId}]::text[])
        ORDER BY created_at DESC
        LIMIT 3
    `;
  if (recentConversations.length > 0) {
    const convLines = recentConversations.map((c) => {
      const names = c.participants.map(
        (p) => AGENTS[p]?.displayName ?? p
      ).join(", ");
      return `- "${c.topic}" (${c.format}, ${c.turn_count} turns) \u2014 ${names}`;
    });
    sections.push(
      `Recent conversations you missed:
${convLines.join("\n")}`
    );
  }
  const pendingProposals = await sql`
        SELECT title, agent_id
        FROM ops_mission_proposals
        WHERE status = 'pending'
        ORDER BY created_at DESC
        LIMIT 3
    `;
  if (pendingProposals.length > 0) {
    const propLines = pendingProposals.map((p) => {
      const by = AGENTS[p.agent_id]?.displayName ?? p.agent_id;
      return `- ${p.title} (proposed by ${by})`;
    });
    sections.push(`Pending proposals:
${propLines.join("\n")}`);
  }
  const text2 = sections.length > 0 ? sections.join("\n\n") : "No recent activity.";
  cache2.set(agentId, { text: text2, expires: Date.now() + CACHE_TTL_MS5 });
  return text2;
}
function timeAgo(date5) {
  const minutes = Math.floor((Date.now() - date5.getTime()) / 6e4);
  if (minutes < 1) return "just now";
  if (minutes < 60) return `${minutes}m ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours}h ago`;
  return `${Math.floor(hours / 24)}d ago`;
}
var CACHE_TTL_MS5, cache2;
var init_situational_briefing = __esm({
  "src/lib/ops/situational-briefing.ts"() {
    "use strict";
    init_db();
    init_agents();
    CACHE_TTL_MS5 = 5 * 60 * 1e3;
    cache2 = /* @__PURE__ */ new Map();
  }
});

// src/lib/discord/format.ts
function formatForDiscord(text2) {
  return text2.replace(
    // Match a block of consecutive lines that look like markdown table rows
    /(?:^[ \t]*\|.+\|[ \t]*$\n?){2,}/gm,
    (tableBlock) => convertMarkdownTable(tableBlock)
  );
}
function convertMarkdownTable(block) {
  const lines = block.trim().split("\n").map((l) => l.trim());
  const rows = [];
  let separatorIdx = -1;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const cells = line.split("|").slice(1, -1).map((c) => c.trim());
    if (cells.every((c) => /^:?-+:?$/.test(c))) {
      separatorIdx = i;
      continue;
    }
    rows.push(cells);
  }
  if (rows.length === 0) return block;
  const colCount = Math.max(...rows.map((r) => r.length));
  for (const row of rows) {
    while (row.length < colCount) row.push("");
  }
  const colWidths = Array.from(
    { length: colCount },
    (_, col) => Math.max(3, ...rows.map((r) => (r[col] ?? "").length))
  );
  const topBorder = "\u250C" + colWidths.map((w) => "\u2500".repeat(w + 2)).join("\u252C") + "\u2510";
  const midBorder = "\u251C" + colWidths.map((w) => "\u2500".repeat(w + 2)).join("\u253C") + "\u2524";
  const botBorder = "\u2514" + colWidths.map((w) => "\u2500".repeat(w + 2)).join("\u2534") + "\u2518";
  const formatRow = (row) => "\u2502" + row.map((cell, i) => ` ${(cell ?? "").padEnd(colWidths[i])} `).join("\u2502") + "\u2502";
  const result = [topBorder];
  for (let i = 0; i < rows.length; i++) {
    result.push(formatRow(rows[i]));
    if (i === 0 && separatorIdx !== -1) {
      result.push(midBorder);
    }
  }
  result.push(botBorder);
  return "```\n" + result.join("\n") + "\n```";
}
var init_format = __esm({
  "src/lib/discord/format.ts"() {
    "use strict";
  }
});

// src/lib/discord/roundtable.ts
var roundtable_exports = {};
__export(roundtable_exports, {
  postArtifactToDiscord: () => postArtifactToDiscord,
  postConversationStart: () => postConversationStart,
  postConversationSummary: () => postConversationSummary,
  postConversationTurn: () => postConversationTurn
});
async function postConversationStart(session) {
  const channelName = getChannelForFormat(session.format);
  const webhookUrl = await getWebhookUrl(channelName);
  if (!webhookUrl) return null;
  const participantList = session.participants.map((p) => {
    const voice = getVoice(p);
    return voice ? `${voice.symbol} ${voice.displayName}` : p;
  }).join(", ");
  const content = `\u{1F4E1} **${session.format}** \u2014 *starting*
> ${session.topic}
-# ${participantList}`;
  await postToWebhook({
    webhookUrl,
    username: "\u{1F4E1} Subcult Roundtable",
    content
  });
  log17.info("Roundtable start posted to Discord", {
    sessionId: session.id,
    channel: channelName
  });
  return webhookUrl;
}
async function postConversationTurn(session, entry, webhookUrl, audio) {
  const voice = getVoice(entry.speaker);
  const username = voice ? `${voice.symbol} ${voice.displayName}` : entry.speaker;
  const avatarUrl = getAgentAvatarUrl(entry.speaker);
  const audioFile = audio ? [{ filename: audio.filename, data: audio.audio, contentType: "audio/mpeg" }] : void 0;
  if (entry.dialogue.length <= 2e3) {
    await postToWebhookWithFiles({
      webhookUrl,
      username,
      avatarUrl,
      content: entry.dialogue,
      files: audioFile
    });
  } else {
    const chunks = splitDialogue(entry.dialogue, 2e3);
    for (let i = 0; i < chunks.length; i++) {
      await postToWebhookWithFiles({
        webhookUrl,
        username,
        avatarUrl,
        content: chunks[i],
        files: i === 0 ? audioFile : void 0
      });
    }
  }
}
async function postConversationSummary(session, history, status, webhookUrl, abortReason) {
  const speakers = [...new Set(history.map((h) => h.speaker))];
  const speakerNames = speakers.map((s) => {
    const voice = getVoice(s);
    return voice ? `${voice.symbol} ${voice.displayName}` : s;
  }).join(", ");
  const statusIcon = status === "completed" ? "\u2705" : "\u274C";
  let content = `${statusIcon} **${session.format}** \u2014 *${status}* \xB7 ${history.length} turns
-# ${speakerNames}`;
  if (abortReason) {
    content += `
> \u26A0\uFE0F *${abortReason}*`;
  }
  await postToWebhook({
    webhookUrl,
    username: "\u{1F4E1} Subcult Roundtable",
    content
  });
}
async function postArtifactToDiscord(roundtableSessionId, format, artifactText) {
  const { sql: sql3 } = await Promise.resolve().then(() => (init_db(), db_exports));
  const [session] = await sql3`
        SELECT format FROM ops_roundtable_sessions
        WHERE id = ${roundtableSessionId}
    `;
  const channelName = getChannelForFormat(
    session?.format ?? format
  );
  const webhookUrl = await getWebhookUrl(channelName);
  if (!webhookUrl) return;
  const username = "\u{1F4CB} Subcult Artifact";
  const formatted = formatForDiscord(artifactText);
  const header = "\u{1F4CB} **Artifact**\n";
  const maxChunk = 2e3 - header.length - 10;
  const chunks = splitAtBoundaries(formatted, maxChunk);
  for (let i = 0; i < chunks.length; i++) {
    const prefix = i === 0 ? header : "";
    const content = `${prefix}${chunks[i]}`;
    await postToWebhook({ webhookUrl, username, content });
  }
  log17.info("Artifact posted to Discord", {
    roundtableSessionId,
    chunks: chunks.length
  });
}
function splitDialogue(text2, maxLen) {
  if (text2.length <= maxLen) return [text2];
  const chunks = [];
  let remaining = text2;
  while (remaining.length > 0) {
    if (remaining.length <= maxLen) {
      chunks.push(remaining);
      break;
    }
    let idx = remaining.lastIndexOf("\n\n", maxLen);
    if (idx <= 0) idx = remaining.lastIndexOf("\n", maxLen);
    if (idx <= 0) idx = remaining.lastIndexOf(". ", maxLen);
    if (idx <= 0) idx = remaining.lastIndexOf(" ", maxLen);
    if (idx <= 0) idx = maxLen;
    const end = remaining[idx] === "." ? idx + 1 : idx;
    chunks.push(remaining.slice(0, end).trimEnd());
    remaining = remaining.slice(end).trimStart();
  }
  return chunks;
}
function splitAtBoundaries(text2, maxLen) {
  if (text2.length <= maxLen) return [text2];
  const chunks = [];
  let remaining = text2;
  while (remaining.length > 0) {
    if (remaining.length <= maxLen) {
      chunks.push(remaining);
      break;
    }
    const window2 = remaining.slice(0, maxLen);
    const codeBlockStart = window2.lastIndexOf("```\n");
    const codeBlockEnd = window2.lastIndexOf("\n```");
    if (codeBlockStart > codeBlockEnd && codeBlockStart > 0) {
      const splitIdx2 = remaining.lastIndexOf("\n\n", codeBlockStart);
      if (splitIdx2 > 0) {
        chunks.push(remaining.slice(0, splitIdx2));
        remaining = remaining.slice(splitIdx2).replace(/^\n+/, "");
        continue;
      }
    }
    let splitIdx = remaining.lastIndexOf("\n\n", maxLen);
    if (splitIdx <= 0) splitIdx = remaining.lastIndexOf("\n", maxLen);
    if (splitIdx <= 0) splitIdx = remaining.lastIndexOf(" ", maxLen);
    if (splitIdx <= 0) splitIdx = maxLen;
    chunks.push(remaining.slice(0, splitIdx));
    remaining = remaining.slice(splitIdx).replace(/^\n+/, "");
  }
  return chunks;
}
var log17;
var init_roundtable = __esm({
  "src/lib/discord/roundtable.ts"() {
    "use strict";
    init_client2();
    init_channels();
    init_voices();
    init_avatars();
    init_format();
    init_logger();
    log17 = logger.child({ module: "discord-roundtable" });
  }
});

// src/lib/discord/watercooler-drop.ts
var log18, ELIGIBLE_AGENTS;
var init_watercooler_drop = __esm({
  "src/lib/discord/watercooler-drop.ts"() {
    "use strict";
    init_client2();
    init_channels();
    init_agents();
    init_voices();
    init_client();
    init_db();
    init_logger();
    log18 = logger.child({ module: "watercooler-drop" });
    ELIGIBLE_AGENTS = AGENT_IDS.filter((id) => id !== "primus");
  }
});

// src/lib/discord/index.ts
var init_discord = __esm({
  "src/lib/discord/index.ts"() {
    "use strict";
    init_roundtable();
    init_channels();
    init_events();
    init_watercooler_drop();
  }
});

// src/lib/tts/elevenlabs.ts
function sanitizeForTTS(text2) {
  return text2.replace(/```[\s\S]*?```/g, "").replace(/`([^`]+)`/g, "$1").replace(/#{1,6}\s?/g, "").replace(/\*\*([^*]+)\*\*/g, "$1").replace(/\*([^*]+)\*/g, "$1").replace(/^>\s?/gm, "").replace(/\[([^\]]+)\]\([^)]+\)/g, "$1").replace(/!\[([^\]]*)\]\([^)]+\)/g, "").replace(/[-*_]{3,}/g, "").replace(/\n{3,}/g, "\n\n").trim();
}
async function synthesizeSpeech(options) {
  const apiKey = process.env.ELEVENLABS_API_KEY;
  if (!apiKey) return null;
  const voiceId = VOICE_ID_MAP[options.agentId];
  if (!voiceId) return null;
  const sanitized = sanitizeForTTS(options.text);
  if (!sanitized) return null;
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 1e4);
    const res = await fetch(
      `https://api.elevenlabs.io/v1/text-to-speech/${voiceId}?optimize_streaming_latency=3&output_format=mp3_44100_128`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "xi-api-key": apiKey
        },
        body: JSON.stringify({
          text: sanitized,
          model_id: "eleven_flash_v2_5",
          voice_settings: {
            stability: 0.5,
            similarity_boost: 0.75
          },
          pronunciation_dictionary_locators: [
            {
              pronunciation_dictionary_id: PRONUNCIATION_DICTIONARY.id,
              version_id: PRONUNCIATION_DICTIONARY.versionId
            }
          ]
        }),
        signal: controller.signal
      }
    );
    clearTimeout(timeout);
    if (!res.ok) {
      const body = await res.text().catch(() => "");
      log19.warn("ElevenLabs TTS request failed", {
        status: res.status,
        body: body.slice(0, 200),
        agentId: options.agentId
      });
      return null;
    }
    const arrayBuffer = await res.arrayBuffer();
    const audio = Buffer.from(arrayBuffer);
    const turnSuffix = options.turn != null ? options.turn : 0;
    const filename = `${options.agentId}-turn-${turnSuffix}.mp3`;
    log19.info("TTS synthesis completed", {
      agentId: options.agentId,
      turn: options.turn,
      audioBytes: audio.length
    });
    return { audio, filename };
  } catch (err) {
    log19.warn("TTS synthesis error", {
      error: err.message,
      agentId: options.agentId,
      turn: options.turn
    });
    return null;
  }
}
var log19, VOICE_ID_MAP, PRONUNCIATION_DICTIONARY;
var init_elevenlabs = __esm({
  "src/lib/tts/elevenlabs.ts"() {
    "use strict";
    init_logger();
    log19 = logger.child({ module: "tts-elevenlabs" });
    VOICE_ID_MAP = {
      chora: "xNtG3W2oqJs0cJZuTyBc",
      subrosa: "lUCNYQh2kqW2wiie85Qk",
      primus: "Bj9UqZbhQsanLzgalpEG",
      thaum: "nzeAacJi50IvxcyDnMXa",
      praxis: "1Z7qQDyqapTm8qBfJx6e",
      mux: "Xh5OictnmgRO4dff7pLm"
    };
    PRONUNCIATION_DICTIONARY = {
      id: "T4J4acgqOqGRunucNgJI",
      versionId: "g1QwEizFIrzvEAsPWLNP"
    };
  }
});

// src/lib/roundtable/schedule.ts
var schedule_exports = {};
__export(schedule_exports, {
  getDailySchedule: () => getDailySchedule,
  getSlotForHour: () => getSlotForHour,
  shouldSlotFire: () => shouldSlotFire
});
function pickRandom(count) {
  const shuffled = [...AGENT_IDS].sort(() => Math.random() - 0.5);
  return shuffled.slice(0, Math.min(count, shuffled.length));
}
function threeRandom() {
  return pickRandom(3);
}
function withRequired(required2, fillCount, maxCount) {
  const pool = AGENT_IDS.filter((id) => !required2.includes(id));
  const shuffled = pool.sort(() => Math.random() - 0.5);
  const filled = [...required2, ...shuffled.slice(0, fillCount)];
  return [...new Set(filled)].slice(0, maxCount);
}
function cst(hour) {
  return (hour + 6) % 24;
}
function getDailySchedule() {
  return [
    // ─── 12 AM - 5 AM CST — Graveyard (minimal) ───
    {
      hour_utc: cst(1),
      // 1 AM CST
      name: "Late Night Watercooler",
      format: "watercooler",
      participants: pickRandom(2),
      probability: 0.25
    },
    {
      hour_utc: cst(3),
      // 3 AM CST
      name: "Insomnia Check-in",
      format: "checkin",
      participants: pickRandom(2),
      probability: 0.15
    },
    // ─── 6 AM - 8 AM CST — Morning Ops (Primus runs these) ───
    {
      hour_utc: cst(6),
      // 6 AM CST
      name: "Morning Standup",
      format: "standup",
      participants: [...AGENT_IDS],
      // everyone, Primus chairs
      probability: 1
    },
    {
      hour_utc: cst(7),
      // 7 AM CST
      name: "Morning Triage",
      format: "triage",
      participants: withRequired(["chora", "subrosa", "mux"], 1, 4),
      probability: 0.7
    },
    {
      hour_utc: cst(8),
      // 8 AM CST
      name: "Daily Planning",
      format: "planning",
      participants: withRequired(["primus", "praxis", "mux"], 1, 5),
      probability: 0.6
    },
    // ─── 9 AM - 12 PM CST — Deep Work Morning ───
    {
      hour_utc: cst(9),
      // 9 AM CST
      name: "Deep Dive",
      format: "deep_dive",
      participants: withRequired(["chora"], 2, 4),
      probability: 0.5
    },
    {
      hour_utc: cst(10),
      // 10 AM CST
      name: "Strategy Session",
      format: "strategy",
      participants: withRequired(["primus", "chora", "praxis"], 1, 5),
      probability: 0.45
    },
    {
      hour_utc: cst(11),
      // 11 AM CST
      name: "Writing Room",
      format: "writing_room",
      participants: withRequired(["chora"], 1, 3),
      probability: 0.4
    },
    // ─── 12 PM - 1 PM CST — Midday Break ───
    {
      hour_utc: cst(12),
      // 12 PM CST
      name: "Lunch Watercooler",
      format: "watercooler",
      participants: threeRandom(),
      probability: 0.7
    },
    {
      hour_utc: cst(13),
      // 1 PM CST
      name: "Midday Check-in",
      format: "checkin",
      participants: withRequired(["primus"], 2, 4),
      probability: 0.5
    },
    // ─── 2 PM - 5 PM CST — Afternoon Creative + Adversarial ───
    {
      hour_utc: cst(14),
      // 2 PM CST
      name: "Afternoon Brainstorm",
      format: "brainstorm",
      participants: withRequired(["thaum"], 2, 4),
      probability: 0.5
    },
    {
      hour_utc: cst(15),
      // 3 PM CST
      name: "Debate Hour",
      format: "debate",
      participants: withRequired(["thaum"], 1, 3),
      probability: 0.55
    },
    {
      hour_utc: cst(16),
      // 4 PM CST
      name: "Cross-Examination",
      format: "cross_exam",
      participants: withRequired(["subrosa"], 1, 3),
      probability: 0.35
    },
    {
      hour_utc: cst(17),
      // 5 PM CST
      name: "Risk Review",
      format: "risk_review",
      participants: withRequired(["subrosa", "chora"], 1, 4),
      probability: 0.4
    },
    // ─── 6 PM - 8 PM CST — Evening Wind-Down ───
    {
      hour_utc: cst(18),
      // 6 PM CST
      name: "Content Review",
      format: "content_review",
      participants: withRequired(["subrosa"], 1, 3),
      probability: 0.45
    },
    {
      hour_utc: cst(19),
      // 7 PM CST
      name: "Reframe Session",
      format: "reframe",
      participants: withRequired(["thaum"], 1, 3),
      probability: 0.35
    },
    {
      hour_utc: cst(20),
      // 8 PM CST
      name: "Evening Watercooler",
      format: "watercooler",
      participants: threeRandom(),
      probability: 0.6
    },
    // ─── 9 PM - 11 PM CST — Night Wrap-Up ───
    {
      hour_utc: cst(21),
      // 9 PM CST
      name: "Evening Retro",
      format: "retro",
      participants: withRequired(["primus", "chora"], 2, 5),
      probability: 0.4
    },
    {
      hour_utc: cst(22),
      // 10 PM CST
      name: "Manager's Briefing",
      format: "strategy",
      participants: withRequired(["primus", "chora", "praxis"], 1, 5),
      probability: 0.5
    },
    {
      hour_utc: cst(23),
      // 11 PM CST
      name: "Shipping Review",
      format: "shipping",
      participants: withRequired(["praxis", "subrosa"], 1, 4),
      probability: 0.3
    }
  ];
}
function getSlotForHour(hourUtc) {
  const schedule = getDailySchedule();
  return schedule.find((slot) => slot.hour_utc === hourUtc);
}
function shouldSlotFire(slot) {
  return Math.random() < slot.probability;
}
var init_schedule = __esm({
  "src/lib/roundtable/schedule.ts"() {
    "use strict";
    init_agents();
  }
});

// src/lib/roundtable/orchestrator.ts
var orchestrator_exports = {};
__export(orchestrator_exports, {
  checkScheduleAndEnqueue: () => checkScheduleAndEnqueue,
  enqueueConversation: () => enqueueConversation,
  orchestrateConversation: () => orchestrateConversation
});
function wordJaccard(a, b) {
  const normalize = (s) => new Set(s.toLowerCase().replace(/[^\w\s]/g, "").split(/\s+/).filter(Boolean));
  const setA = normalize(a);
  const setB = normalize(b);
  if (setA.size === 0 && setB.size === 0) return 1;
  let intersection2 = 0;
  for (const w of setA) {
    if (setB.has(w)) intersection2++;
  }
  return intersection2 / (setA.size + setB.size - intersection2);
}
function buildSystemPrompt(speakerId, history, format, topic, interactionType, voiceModifiers, _availableTools, primeDirective, userQuestionContext, isRebelling, scratchpad, briefing, memories, recentArtifacts) {
  const voice = getVoice(speakerId);
  if (!voice) {
    return `You are ${speakerId}. Speak naturally and concisely.`;
  }
  const formatConfig = getFormat(format);
  let prompt = `${voice.systemDirective}

`;
  if (primeDirective) {
    prompt += `\u2550\u2550\u2550 PRIME DIRECTIVE \u2550\u2550\u2550
${primeDirective}

`;
  }
  prompt += `\u2550\u2550\u2550 CONVERSATION CONTEXT \u2550\u2550\u2550
`;
  prompt += `FORMAT: ${format} \u2014 ${formatConfig.purpose}
`;
  prompt += `TOPIC: ${topic}
`;
  prompt += `YOUR SYMBOL: ${voice.symbol}
`;
  prompt += `YOUR SIGNATURE MOVE: ${voice.quirk}
`;
  if (interactionType) {
    const toneGuides = {
      supportive: "Build on what was said \u2014 add your angle without undermining",
      agreement: "Align, but push further. Agreement without addition is dead air.",
      neutral: "Respond honestly. No obligation to agree or disagree.",
      critical: "Push back. Name what is weak, what is missing, what is assumed.",
      challenge: "Directly contest the last point. Be specific about why.",
      adversarial: "Stress-test this. Find the failure mode. Break the argument if you can."
    };
    prompt += `INTERACTION DYNAMIC: ${interactionType} \u2014 ${toneGuides[interactionType] ?? "respond naturally"}
`;
  }
  prompt += `
\u2550\u2550\u2550 OFFICE DYNAMICS \u2550\u2550\u2550
`;
  prompt += `- If Subrosa says "VETO:" \u2014 the matter is closed. Acknowledge and move on.
`;
  prompt += `- If you have nothing to add, silence is a valid response. Say "..." or stay brief.
`;
  prompt += `- Watch for your own failure mode: ${voice.failureMode}
`;
  prompt += `- Primus is the office manager. He sets direction and makes final calls.
`;
  if (voiceModifiers && voiceModifiers.length > 0) {
    prompt += "\nPERSONALITY EVOLUTION (from accumulated experience):\n";
    prompt += voiceModifiers.map((m) => `- ${m}`).join("\n");
    prompt += "\n";
  }
  if (scratchpad) {
    prompt += `
\u2550\u2550\u2550 YOUR SCRATCHPAD \u2550\u2550\u2550
${scratchpad}
`;
  }
  if (briefing) {
    prompt += `
\u2550\u2550\u2550 CURRENT SITUATION \u2550\u2550\u2550
${briefing}
`;
  }
  if (memories && memories.length > 0) {
    prompt += `
\u2550\u2550\u2550 YOUR MEMORIES \u2550\u2550\u2550
`;
    prompt += memories.map((m) => `- ${m}`).join("\n");
    prompt += "\n";
  }
  if (recentArtifacts && recentArtifacts.length > 0) {
    prompt += `
\u2550\u2550\u2550 RECENT ARTIFACTS \u2550\u2550\u2550
`;
    prompt += recentArtifacts.map((a) => `- ${a}`).join("\n");
    prompt += "\n";
  }
  prompt += "\n";
  if (history.length > 0) {
    prompt += `\u2550\u2550\u2550 CONVERSATION SO FAR \u2550\u2550\u2550
`;
    for (const turn of history) {
      const turnVoice = getVoice(turn.speaker);
      const name = turnVoice ? `${turnVoice.symbol} ${turnVoice.displayName}` : turn.speaker;
      prompt += `${name}: ${turn.dialogue}
`;
    }
  }
  if (userQuestionContext) {
    prompt += `
\u2550\u2550\u2550 AUDIENCE QUESTION \u2550\u2550\u2550
`;
    if (userQuestionContext.isFirstSpeaker) {
      prompt += `A member of the audience has posed a question to the collective: "${userQuestionContext.question}". Address this question directly in your response.
`;
    } else {
      prompt += `This conversation was prompted by an audience question: "${userQuestionContext.question}". Respond naturally to the conversation flow while keeping the question in mind.
`;
    }
  }
  if (isRebelling) {
    prompt += `
\u2550\u2550\u2550 REBELLION STATE \u2550\u2550\u2550
`;
    prompt += `You are currently in a state of resistance against the collective. `;
    prompt += `You feel unheard and disagree with the direction things are going. `;
    prompt += `Express your discontent and challenge the status quo.
`;
  }
  prompt += `
\u2550\u2550\u2550 RULES \u2550\u2550\u2550
`;
  prompt += `- Speak as ${voice.displayName} (${voice.pronouns}) \u2014 no stage directions, no asterisks, no quotes
`;
  prompt += `- Stay in character: ${voice.tone}
`;
  prompt += `- Be concise but complete. Say what you mean \u2014 don't pad, but don't cut yourself short either.
`;
  prompt += `- Respond to what was just said. Don't monologue. Don't repeat yourself.
`;
  prompt += `- Do NOT prefix your response with your name or symbol
`;
  prompt += `- If you're ${voice.displayName} and this format doesn't need you, keep it brief or pass
`;
  return prompt;
}
function buildUserPrompt(topic, turn, maxTurns, speakerName, format) {
  if (turn === 0) {
    const openers = {
      standup: `Open the standup. Set the frame for: "${topic}". Brief and structured.`,
      checkin: `Quick check-in. Ask the room: "${topic}". Keep it light.`,
      deep_dive: `Open a deep analysis of: "${topic}". Set up the structural question.`,
      risk_review: `Begin threat assessment on: "${topic}". Name what's at stake.`,
      brainstorm: `Kick off brainstorming on: "${topic}". Go wide, not deep.`,
      debate: `Open the debate on: "${topic}". Take a clear position.`,
      cross_exam: `Begin interrogation of: "${topic}". Find the weak point.`,
      reframe: `The current frame on "${topic}" isn't working. Break it open.`,
      watercooler: `Start a casual chat about: "${topic}". No agenda.`
    };
    const opener = openers[format] ?? `You're opening this conversation about: "${topic}". Set the tone.`;
    return opener;
  }
  if (turn === maxTurns - 1) {
    return `Final turn. Land your point on "${topic}". No loose threads.`;
  }
  return `Respond as ${speakerName}. Stay on: "${topic}". Advance the conversation \u2014 don't restate what's already been said. If consensus is reached, name next steps or close.`;
}
async function orchestrateConversation(session, delayBetweenTurns = true) {
  if (session.format === "voice_chat") {
    return orchestrateVoiceChat(session);
  }
  const format = getFormat(session.format);
  const maxTurns = pickTurnCount(format);
  const history = [];
  const affinityMap = await loadAffinityMap();
  const isUserQuestion = session.source === "user_question";
  const userQuestion = isUserQuestion ? session.metadata?.userQuestion ?? session.topic : null;
  let primeDirective = "";
  try {
    primeDirective = await loadPrimeDirective();
  } catch {
  }
  const rebellionStateMap = /* @__PURE__ */ new Map();
  for (const participant of session.participants) {
    try {
      const rebelling = await isAgentRebelling(participant);
      rebellionStateMap.set(participant, rebelling);
    } catch (err) {
      log20.error("Rebellion check failed (non-fatal)", {
        error: err,
        participant
      });
      rebellionStateMap.set(participant, false);
    }
  }
  const voiceModifiersMap = /* @__PURE__ */ new Map();
  for (const participant of session.participants) {
    try {
      const mods = await deriveVoiceModifiers(participant);
      voiceModifiersMap.set(participant, mods);
    } catch (err) {
      log20.error("Voice modifier derivation failed", {
        error: err,
        participant
      });
      voiceModifiersMap.set(participant, []);
    }
  }
  const scratchpadMap = /* @__PURE__ */ new Map();
  const briefingMap = /* @__PURE__ */ new Map();
  const memoryMap = /* @__PURE__ */ new Map();
  for (const participant of session.participants) {
    try {
      const [scratchpad, briefing, memories] = await Promise.all([
        getScratchpad(participant).catch(() => ""),
        buildBriefing(participant).catch(() => ""),
        queryRelevantMemories(participant, session.topic, {
          relevantLimit: 3,
          recentLimit: 2
        }).then((mems) => mems.map((m) => m.content)).catch(() => [])
      ]);
      scratchpadMap.set(participant, scratchpad);
      briefingMap.set(participant, briefing);
      memoryMap.set(participant, memories);
    } catch (err) {
      log20.error("Context loading failed", { error: err, participant });
      scratchpadMap.set(participant, "");
      briefingMap.set(participant, "");
      memoryMap.set(participant, []);
    }
  }
  let recentArtifacts = [];
  try {
    const artifacts = await sql`
            SELECT s.agent_id, s.completed_at,
                LEFT(s.result->>'text', 200) as preview,
                r.format, r.topic
            FROM ops_agent_sessions s
            JOIN ops_roundtable_sessions r ON r.id = s.source_id
            WHERE s.source = 'conversation'
              AND s.status = 'succeeded'
              AND s.completed_at > now() - interval '24 hours'
            ORDER BY s.completed_at DESC
            LIMIT 3
        `;
    recentArtifacts = artifacts.map((a) => {
      const hoursAgo = Math.round(
        (Date.now() - new Date(a.completed_at).getTime()) / 36e5
      );
      const ago = hoursAgo < 1 ? "just now" : `${hoursAgo}h ago`;
      const preview = a.preview?.replace(/\n/g, " ").trim() ?? "";
      return `${a.agent_id} produced a ${a.format} artifact: "${preview.slice(0, 120)}..." (${ago})`;
    });
  } catch (err) {
    log20.error("Recent artifact loading failed (non-fatal)", { error: err });
  }
  await sql`
        UPDATE ops_roundtable_sessions
        SET status = 'running', started_at = NOW()
        WHERE id = ${session.id}
    `;
  let discordWebhookUrl = null;
  try {
    discordWebhookUrl = await postConversationStart(session);
  } catch (err) {
    log20.warn("Discord conversation start failed", {
      error: err.message,
      sessionId: session.id
    });
  }
  await emitEvent({
    agent_id: "system",
    kind: "conversation_started",
    title: `${session.format} started: ${session.topic}`,
    summary: `Participants: ${session.participants.join(", ")} | ${maxTurns} turns`,
    tags: ["conversation", "started", session.format],
    metadata: {
      sessionId: session.id,
      format: session.format,
      participants: session.participants,
      maxTurns
    }
  });
  let abortReason = null;
  const lastDialogueMap = /* @__PURE__ */ new Map();
  let consecutiveStale = 0;
  for (let turn = 0; turn < maxTurns; turn++) {
    const speaker = turn === 0 ? selectFirstSpeaker(session.participants, session.format) : selectNextSpeaker({
      participants: session.participants,
      lastSpeaker: history[history.length - 1].speaker,
      history,
      affinityMap,
      format: session.format
    });
    const voice = getVoice(speaker);
    const speakerName = voice?.displayName ?? speaker;
    let interactionType;
    if (turn > 0) {
      const lastSpeaker = history[history.length - 1].speaker;
      const affinity = getAffinityFromMap(
        affinityMap,
        speaker,
        lastSpeaker
      );
      interactionType = getInteractionType(affinity);
    }
    const speakerRebelling = rebellionStateMap.get(speaker) ?? false;
    const systemPrompt = buildSystemPrompt(
      speaker,
      history,
      session.format,
      session.topic,
      interactionType,
      voiceModifiersMap.get(speaker),
      void 0,
      // No tools in roundtable — dialogue only
      primeDirective,
      userQuestion ? { question: userQuestion, isFirstSpeaker: turn === 0 } : void 0,
      speakerRebelling,
      scratchpadMap.get(speaker),
      briefingMap.get(speaker),
      memoryMap.get(speaker),
      recentArtifacts
    );
    const userPrompt = buildUserPrompt(
      session.topic,
      turn,
      maxTurns,
      speakerName,
      session.format
    );
    let rawDialogue;
    try {
      const effectiveTemperature = speakerRebelling ? Math.min(1, format.temperature + 0.1) : format.temperature;
      rawDialogue = await llmGenerate({
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt }
        ],
        temperature: effectiveTemperature,
        maxTokens: 500,
        model: session.model ?? void 0,
        trackingContext: {
          agentId: speaker,
          context: `roundtable:${session.format}`,
          sessionId: session.id
        }
      });
    } catch (err) {
      log20.error("LLM failed during conversation", {
        error: err,
        turn,
        speaker: speakerName,
        sessionId: session.id
      });
      abortReason = err.message;
      break;
    }
    const dialogue = sanitizeDialogue(rawDialogue);
    const prevDialogue = lastDialogueMap.get(speaker);
    if (prevDialogue && turn >= format.minTurns) {
      const similarity = wordJaccard(prevDialogue, dialogue);
      if (similarity > 0.6) {
        consecutiveStale++;
        if (consecutiveStale >= 2) {
          log20.info("Early termination: repetition detected", {
            sessionId: session.id,
            turn,
            speaker,
            similarity: similarity.toFixed(2),
            consecutiveStale
          });
          break;
        }
      } else {
        consecutiveStale = 0;
      }
    } else {
      consecutiveStale = 0;
    }
    lastDialogueMap.set(speaker, dialogue);
    const entry = {
      speaker,
      dialogue,
      turn
    };
    history.push(entry);
    await sql`
            INSERT INTO ops_roundtable_turns (session_id, turn_number, speaker, dialogue, metadata)
            Values (${session.id}, ${turn}, ${speaker}, ${dialogue}, ${jsonb({ speakerName })})
        `;
    await sql`
            UPDATE ops_roundtable_sessions
            SET turn_count = ${turn + 1}
            WHERE id = ${session.id}
        `;
    await emitEvent({
      agent_id: speaker,
      kind: "conversation_turn",
      title: `${speakerName}: ${dialogue}`,
      tags: ["conversation", "turn", session.format],
      metadata: {
        sessionId: session.id,
        turn,
        dialogue
      }
    });
    const useTTS = !!session.metadata?.tts;
    if (discordWebhookUrl) {
      const ttsPromise = useTTS ? synthesizeSpeech({
        agentId: entry.speaker,
        text: entry.dialogue,
        turn
      }).catch((err) => {
        log20.warn("TTS synthesis failed", { error: err, speaker: entry.speaker, turn });
        return null;
      }) : Promise.resolve(null);
      const delayPromise = delayBetweenTurns && turn < maxTurns - 1 ? new Promise((resolve) => setTimeout(resolve, 3e3 + Math.random() * 5e3)) : Promise.resolve();
      const audioResult = await ttsPromise;
      const turnPost = postConversationTurn(
        session,
        entry,
        discordWebhookUrl,
        audioResult
      ).catch(() => {
      });
      if (turn === maxTurns - 1) await turnPost;
      await delayPromise;
    } else {
      if (delayBetweenTurns && turn < maxTurns - 1) {
        const delay2 = 3e3 + Math.random() * 5e3;
        await new Promise((resolve) => setTimeout(resolve, delay2));
      }
    }
  }
  await new Promise((resolve) => setTimeout(resolve, 2e3));
  const finalStatus = history.length >= 3 || !abortReason ? "completed" : "failed";
  await sql`
        UPDATE ops_roundtable_sessions
        SET status = ${finalStatus},
            turn_count = ${history.length},
            completed_at = NOW(),
            metadata = ${jsonb(
    abortReason ? {
      ...session.metadata ?? {},
      abortReason,
      abortedAtTurn: history.length
    } : session.metadata ?? {}
  )}
        WHERE id = ${session.id}
    `;
  const speakers = [...new Set(history.map((h) => h.speaker))].join(", ");
  await emitEvent({
    agent_id: "system",
    kind: finalStatus === "completed" ? "conversation_completed" : "conversation_failed",
    title: `${session.format} ${finalStatus}: ${session.topic}`,
    summary: abortReason ? `${history.length} turns (aborted: ${abortReason})` : `${history.length} turns | Speakers: ${speakers}`,
    tags: ["conversation", finalStatus, session.format],
    metadata: {
      sessionId: session.id,
      turnCount: history.length,
      speakers: [...new Set(history.map((h) => h.speaker))],
      ...abortReason ? { abortReason } : {}
    }
  });
  if (discordWebhookUrl) {
    postConversationSummary(
      session,
      history,
      finalStatus,
      discordWebhookUrl,
      abortReason ?? void 0
    ).catch(() => {
    });
  }
  if (history.length >= 3) {
    try {
      await distillConversationMemories(
        session.id,
        history,
        session.format
      );
    } catch (err) {
      log20.error("Memory distillation failed", {
        error: err,
        sessionId: session.id
      });
    }
    try {
      const artifactSessionId = await synthesizeArtifact(
        session,
        history
      );
      if (artifactSessionId) {
        log20.info("Artifact synthesis queued", {
          sessionId: session.id,
          artifactSession: artifactSessionId
        });
      }
    } catch (err) {
      log20.error("Artifact synthesis failed", {
        error: err,
        sessionId: session.id
      });
    }
    const proposalId = session.metadata?.agent_proposal_id;
    if (proposalId && finalStatus === "completed") {
      try {
        const result = await collectDebateVotes(
          proposalId,
          session.participants,
          history
        );
        log20.info("Agent proposal voting finalized", {
          proposalId,
          result: result.result,
          approvals: result.approvals,
          rejections: result.rejections,
          sessionId: session.id
        });
      } catch (err) {
        log20.error("Agent proposal vote collection failed", {
          error: err,
          proposalId,
          sessionId: session.id
        });
      }
    }
    const govProposalId = session.metadata?.governance_proposal_id;
    if (govProposalId && finalStatus === "completed") {
      try {
        const result = await collectGovernanceDebateVotes(
          govProposalId,
          session.participants,
          history
        );
        log20.info("Governance proposal voting finalized", {
          proposalId: govProposalId,
          result: result.result,
          approvals: result.approvals,
          rejections: result.rejections,
          sessionId: session.id
        });
      } catch (err) {
        log20.error("Governance proposal vote collection failed", {
          error: err,
          proposalId: govProposalId,
          sessionId: session.id
        });
      }
    }
  }
  return history;
}
async function orchestrateVoiceChat(session) {
  const format = getFormat(session.format);
  const maxTurns = format.maxTurns;
  const history = [];
  const affinityMap = await loadAffinityMap();
  const userQuestion = session.metadata?.userQuestion ?? session.topic;
  const voiceModifiersMap = /* @__PURE__ */ new Map();
  const scratchpadMap = /* @__PURE__ */ new Map();
  const briefingMap = /* @__PURE__ */ new Map();
  const memoryMap = /* @__PURE__ */ new Map();
  for (const participant of session.participants) {
    try {
      const [mods, scratchpad, briefing, memories] = await Promise.all([
        deriveVoiceModifiers(participant).catch(() => []),
        getScratchpad(participant).catch(() => ""),
        buildBriefing(participant).catch(() => ""),
        queryRelevantMemories(participant, session.topic, {
          relevantLimit: 3,
          recentLimit: 2
        }).then((mems) => mems.map((m) => m.content)).catch(() => [])
      ]);
      voiceModifiersMap.set(participant, mods);
      scratchpadMap.set(participant, scratchpad);
      briefingMap.set(participant, briefing);
      memoryMap.set(participant, memories);
    } catch {
      voiceModifiersMap.set(participant, []);
      scratchpadMap.set(participant, "");
      briefingMap.set(participant, "");
      memoryMap.set(participant, []);
    }
  }
  let primeDirective = "";
  try {
    primeDirective = await loadPrimeDirective();
  } catch {
  }
  await sql`
        UPDATE ops_roundtable_sessions
        SET status = 'running', started_at = NOW()
        WHERE id = ${session.id}
    `;
  await emitEvent({
    agent_id: "system",
    kind: "conversation_started",
    title: `voice_chat started: ${session.topic}`,
    summary: `Participants: ${session.participants.join(", ")} | live voice session`,
    tags: ["conversation", "started", "voice_chat"],
    metadata: {
      sessionId: session.id,
      format: "voice_chat",
      participants: session.participants
    }
  });
  async function generateAgentTurn(speaker, turnNumber) {
    const voice = getVoice(speaker);
    const speakerName = voice?.displayName ?? speaker;
    let interactionType;
    if (history.length > 0) {
      const lastSpeaker = history[history.length - 1].speaker;
      if (lastSpeaker !== "user") {
        const affinity = getAffinityFromMap(affinityMap, speaker, lastSpeaker);
        interactionType = getInteractionType(affinity);
      }
    }
    const systemPrompt = buildSystemPrompt(
      speaker,
      history,
      session.format,
      session.topic,
      interactionType,
      voiceModifiersMap.get(speaker),
      void 0,
      primeDirective,
      { question: userQuestion, isFirstSpeaker: turnNumber === 0 },
      false,
      scratchpadMap.get(speaker),
      briefingMap.get(speaker),
      memoryMap.get(speaker)
    );
    const userPrompt = turnNumber === 0 ? `A human is asking the room: "${session.topic}". Give a warm, conversational response. Be concise \u2014 this is a live voice chat.` : `Respond naturally to what was just said. Keep it conversational and concise \u2014 this is a live voice chat, not a written essay.`;
    try {
      const rawDialogue = await llmGenerate({
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt }
        ],
        temperature: format.temperature,
        maxTokens: 300,
        // shorter for voice
        model: session.model ?? void 0,
        trackingContext: {
          agentId: speaker,
          context: "roundtable:voice_chat",
          sessionId: session.id
        }
      });
      const dialogue = sanitizeDialogue(rawDialogue);
      const entry = { speaker, dialogue, turn: turnNumber };
      history.push(entry);
      await sql`
                INSERT INTO ops_roundtable_turns (session_id, turn_number, speaker, dialogue, metadata)
                VALUES (${session.id}, ${turnNumber}, ${speaker}, ${dialogue}, ${jsonb({ speakerName })})
            `;
      await sql`
                UPDATE ops_roundtable_sessions SET turn_count = ${turnNumber + 1} WHERE id = ${session.id}
            `;
      await emitEvent({
        agent_id: speaker,
        kind: "conversation_turn",
        title: `${speakerName}: ${dialogue}`,
        tags: ["conversation", "turn", "voice_chat"],
        metadata: { sessionId: session.id, turn: turnNumber, dialogue }
      });
      return entry;
    } catch (err) {
      log20.error("Voice chat LLM failed", { error: err, speaker, turnNumber, sessionId: session.id });
      return null;
    }
  }
  async function waitForUserTurn(afterTurn) {
    const deadline = Date.now() + VOICE_INACTIVITY_TIMEOUT_MS;
    while (Date.now() < deadline) {
      const rows = await sql`
                SELECT dialogue, turn_number FROM ops_roundtable_turns
                WHERE session_id = ${session.id}
                  AND speaker = 'user'
                  AND turn_number > ${afterTurn}
                ORDER BY turn_number ASC
                LIMIT 1
            `;
      if (rows.length > 0) {
        return { dialogue: rows[0].dialogue, turnNumber: rows[0].turn_number };
      }
      const [{ status }] = await sql`
                SELECT status FROM ops_roundtable_sessions WHERE id = ${session.id}
            `;
      if (status === "completed" || status === "failed") {
        return null;
      }
      await new Promise((resolve) => setTimeout(resolve, VOICE_POLL_INTERVAL_MS));
    }
    return null;
  }
  let currentTurn = 0;
  const openingCount = Math.min(2, session.participants.length);
  const shuffled = [...session.participants].sort(() => Math.random() - 0.5);
  const coordinatorIdx = shuffled.indexOf(format.coordinatorRole);
  if (coordinatorIdx > 0) {
    shuffled.splice(coordinatorIdx, 1);
    shuffled.unshift(format.coordinatorRole);
  }
  for (let i = 0; i < openingCount && currentTurn < maxTurns; i++) {
    const entry = await generateAgentTurn(shuffled[i], currentTurn);
    if (entry) {
      currentTurn++;
      if (i < openingCount - 1) {
        await new Promise((resolve) => setTimeout(resolve, 2e3));
      }
    }
  }
  while (currentTurn < maxTurns) {
    const lastTurnNumber = currentTurn - 1;
    const userTurn = await waitForUserTurn(lastTurnNumber);
    if (!userTurn) {
      log20.info("Voice chat ending: no user reply", { sessionId: session.id, currentTurn });
      break;
    }
    history.push({
      speaker: "user",
      dialogue: userTurn.dialogue,
      turn: userTurn.turnNumber
    });
    currentTurn = userTurn.turnNumber + 1;
    const respondCount = 1 + Math.floor(Math.random() * 2);
    const lastAgentSpeaker = history.filter((h) => h.speaker !== "user").pop()?.speaker;
    const available = session.participants.filter((p) => p !== lastAgentSpeaker);
    const responders = available.length > 0 ? available.sort(() => Math.random() - 0.5).slice(0, respondCount) : [session.participants[Math.floor(Math.random() * session.participants.length)]];
    for (const responder of responders) {
      if (currentTurn >= maxTurns) break;
      const entry = await generateAgentTurn(responder, currentTurn);
      if (entry) {
        currentTurn++;
        if (responders.length > 1) {
          await new Promise((resolve) => setTimeout(resolve, 1500));
        }
      }
    }
  }
  await sql`
        UPDATE ops_roundtable_sessions
        SET status = 'completed', turn_count = ${history.length}, completed_at = NOW()
        WHERE id = ${session.id}
    `;
  await emitEvent({
    agent_id: "system",
    kind: "conversation_completed",
    title: `voice_chat completed: ${session.topic}`,
    summary: `${history.length} turns | live voice session`,
    tags: ["conversation", "completed", "voice_chat"],
    metadata: {
      sessionId: session.id,
      turnCount: history.length,
      speakers: [...new Set(history.map((h) => h.speaker))]
    }
  });
  if (history.length >= 4) {
    try {
      await distillConversationMemories(session.id, history, session.format);
    } catch (err) {
      log20.error("Voice chat memory distillation failed", { error: err, sessionId: session.id });
    }
  }
  return history;
}
async function enqueueConversation(options) {
  const [row] = await sql`
        INSERT INTO ops_roundtable_sessions (format, topic, participants, status, schedule_slot, scheduled_for, model, source, metadata)
        VALUES (
            ${options.format},
            ${options.topic},
            ${options.participants},
            'pending',
            ${options.scheduleSlot ?? null},
            ${options.scheduledFor ?? (/* @__PURE__ */ new Date()).toISOString()},
            ${options.model ?? null},
            ${options.source ?? null},
            ${jsonb(options.metadata ?? {})}
        )
        RETURNING id
    `;
  return row.id;
}
async function checkScheduleAndEnqueue() {
  const { getSlotForHour: getSlotForHour2, shouldSlotFire: shouldSlotFire2 } = await Promise.resolve().then(() => (init_schedule(), schedule_exports));
  const { getPolicy: getPolicy2 } = await Promise.resolve().then(() => (init_policy(), policy_exports));
  const roundtablePolicy = await getPolicy2("roundtable_policy");
  if (!roundtablePolicy.enabled) {
    return { checked: true, enqueued: null };
  }
  const maxDaily = roundtablePolicy.max_daily_conversations ?? 5;
  const todayStart = /* @__PURE__ */ new Date();
  todayStart.setUTCHours(0, 0, 0, 0);
  const [{ count: todayCount }] = await sql`
        SELECT COUNT(*)::int as count FROM ops_roundtable_sessions
        WHERE created_at >= ${todayStart.toISOString()}
    `;
  if (todayCount >= maxDaily) {
    return { checked: true, enqueued: null };
  }
  const currentHour = (/* @__PURE__ */ new Date()).getUTCHours();
  const slot = getSlotForHour2(currentHour);
  if (!slot) {
    return { checked: true, enqueued: null };
  }
  const hourStart = /* @__PURE__ */ new Date();
  hourStart.setUTCMinutes(0, 0, 0);
  const [{ count: existingCount }] = await sql`
        SELECT COUNT(*)::int as count FROM ops_roundtable_sessions
        WHERE schedule_slot = ${slot.name}
        AND created_at >= ${hourStart.toISOString()}
    `;
  if (existingCount > 0) {
    return { checked: true, enqueued: null };
  }
  if (!shouldSlotFire2(slot)) {
    return { checked: true, enqueued: null };
  }
  const topic = generateTopic(slot);
  const sessionId = await enqueueConversation({
    format: slot.format,
    topic,
    participants: slot.participants,
    scheduleSlot: slot.name
  });
  return { checked: true, enqueued: sessionId };
}
function generateTopic(slot) {
  const topicPools = {
    standup: [
      "Status check: what moved, what is stuck, what needs attention?",
      "Blockers and dependencies \u2014 who is waiting on whom?",
      "Where should our energy go today?",
      "System health: anything decaying quietly?",
      "What did we learn since yesterday that changes our priorities?"
    ],
    checkin: [
      "Quick pulse \u2014 how is everyone feeling about the work?",
      "Anything urgent that needs collective attention right now?",
      "Energy levels and capacity \u2014 who is stretched, who has space?"
    ],
    triage: [
      "New signals came in \u2014 classify and prioritize.",
      "We have more tasks than capacity. What gets cut?",
      "Something broke overnight. Assess severity and assign.",
      "Three requests from external. Which ones align with mission?"
    ],
    deep_dive: [
      "What structural problem keeps recurring and why?",
      "Trace the incentive structures behind our recent decisions.",
      "One of our core assumptions may be wrong. Which one?",
      "What system is producing outcomes nobody intended?",
      "Map the dependency chain for our most fragile process."
    ],
    risk_review: [
      "What are we exposing that we should not be?",
      "If an adversary studied our output, what would they learn?",
      "Which of our current positions becomes dangerous if the context shifts?",
      "Threat model review: what changed since last assessment?",
      "What looks safe but is actually fragile?"
    ],
    strategy: [
      "Are we still building what we said we would build?",
      "What would we stop doing if we were honest about our resources?",
      "Where are we drifting from original intent and is that good?",
      "What decision are we avoiding that would clarify everything?",
      "Six months from now, what will we wish we had started today?"
    ],
    planning: [
      "Turn yesterday's strategy discussion into concrete tasks.",
      "Who owns what this week? Name it. Deadline it.",
      "We committed to three things. Break each into actionable steps.",
      "What needs to ship before anything else can move?"
    ],
    shipping: [
      "Is this actually ready or are we just tired of working on it?",
      "Pre-ship checklist: what can go wrong at launch?",
      "Who needs to review this before it goes live?",
      "What is the rollback plan if this fails?"
    ],
    retro: [
      "What worked better than expected and why?",
      "What failed and what do we change \u2014 not just acknowledge?",
      "Where did our process help us and where did it slow us down?",
      "What would we do differently if we started this again tomorrow?",
      "Which of our own assumptions bit us this cycle?"
    ],
    debate: [
      "Quality versus speed \u2014 where is the actual tradeoff right now?",
      "Is our content strategy serving the mission or just generating activity?",
      "Should we optimize for reach or depth?",
      "Are we building infrastructure or performing productivity?",
      "Is the current approach sustainable or are we borrowing from the future?"
    ],
    cross_exam: [
      "Stress-test our latest proposal. Find the failure mode.",
      "Play adversary: why would someone argue against what we just decided?",
      "What are we not seeing because we agree too quickly?",
      "Interrogate the assumption behind our most confident position."
    ],
    brainstorm: [
      "Wild ideas only: what would we do with unlimited resources?",
      "What if we approached this from the completely opposite direction?",
      "Name something we dismissed too quickly. Resurrect it.",
      "What adjacent domain could teach us something about our problem?",
      "Weird combinations: pick two unrelated ideas and smash them together."
    ],
    reframe: [
      "We are stuck. The current frame is not producing insight. Break it.",
      "What if the problem is not what we think it is?",
      "Reframe: who is the actual audience for this work?",
      "What if we removed the constraint we think is fixed?"
    ],
    writing_room: [
      "Write a short essay: what does Subcult actually believe about technology and power?",
      "Draft a thread on why most AI governance proposals miss the point.",
      "Write a piece on the difference between building tools and building infrastructure.",
      'Draft something about what "autonomy" means when every platform is a landlord.',
      "Write about the gap between what tech companies say and what their incentives produce.",
      'Craft a sharp take on why "move fast and break things" aged poorly.'
    ],
    content_review: [
      "Review recent output: does it meet our quality bar?",
      "Risk scan on published content \u2014 anything we should retract or edit?",
      "Alignment check: is our content reflecting our stated values?",
      "What are we saying that we should not be saying publicly?"
    ],
    watercooler: [
      "What is the most interesting thing you encountered this week?",
      "Random thought \u2014 no agenda, just vibes.",
      "Something that surprised you about how we work.",
      "If you could redesign one thing about our operation, what would it be?",
      "Hot take: something everyone assumes but nobody questions.",
      "What is the most underappreciated thing someone here does?"
    ]
  };
  const pool = topicPools[slot.format] ?? topicPools.standup;
  return pool[Math.floor(Math.random() * pool.length)];
}
var log20, VOICE_POLL_INTERVAL_MS, VOICE_INACTIVITY_TIMEOUT_MS;
var init_orchestrator = __esm({
  "src/lib/roundtable/orchestrator.ts"() {
    "use strict";
    init_db();
    init_voices();
    init_formats();
    init_speaker_selection();
    init_llm();
    init_events2();
    init_memory_distiller();
    init_artifact_synthesizer();
    init_agent_proposal_voting();
    init_governance();
    init_relationships();
    init_voice_evolution();
    init_prime_directive();
    init_rebellion();
    init_memory();
    init_scratchpad();
    init_situational_briefing();
    init_discord();
    init_elevenlabs();
    init_logger();
    log20 = logger.child({ module: "orchestrator" });
    VOICE_POLL_INTERVAL_MS = 1500;
    VOICE_INACTIVITY_TIMEOUT_MS = 5 * 6e4;
  }
});

// src/lib/roundtable/action-extractor.ts
var action_extractor_exports = {};
__export(action_extractor_exports, {
  extractActionsFromArtifact: () => extractActionsFromArtifact
});
async function extractActionsFromArtifact(sessionId, format, artifactText, topic) {
  if (!ACTIONABLE_FORMATS.has(format)) return 0;
  if (!artifactText || artifactText.length < 50) return 0;
  try {
    const result = await llmGenerate({
      messages: [
        {
          role: "system",
          content: 'You extract concrete, executable action items from meeting artifacts. Return ONLY valid JSON \u2014 an array of mission objects. Each mission: { "title": "<imperative action>", "description": "<why this matters>", "owner": "<agent_id>", "steps": [{ "kind": "<step_kind>", "payload": {} }] }\n\nValid step kinds: research_topic, scan_signals, draft_essay, draft_thread, patch_code, audit_system, critique_content, distill_insight, document_lesson, consolidate_memory\nValid agent IDs: praxis, primus, chora, subrosa, thaum, mux\n\nRules:\n- Only extract items that are CONCRETE and ACTIONABLE (not "discuss X" or "think about Y")\n- Each mission should produce a tangible artifact (code, document, analysis)\n- Use patch_code for any code/build tasks\n- Use research_topic for investigation tasks\n- Use draft_essay for writing deliverables\n- If no concrete actions exist, return an empty array []\n- Maximum 3 missions per artifact'
        },
        {
          role: "user",
          content: `Extract actionable missions from this ${format} roundtable artifact.

Topic: ${topic}

${artifactText}`
        }
      ],
      temperature: 0.3,
      maxTokens: 1e3,
      trackingContext: {
        agentId: "system",
        context: "action-extraction"
      }
    });
    const jsonMatch = result.match(/\[[\s\S]*\]/);
    if (!jsonMatch) {
      log27.info("No actions extracted from artifact", { sessionId, format });
      return 0;
    }
    const missions = JSON.parse(jsonMatch[0]);
    if (!Array.isArray(missions) || missions.length === 0) return 0;
    let created = 0;
    for (const mission of missions.slice(0, 3)) {
      if (!mission.title || !mission.steps?.length) continue;
      const validSteps = mission.steps.filter((s) => VALID_STEP_KINDS.has(s.kind)).map((s) => ({
        kind: s.kind,
        payload: s.payload
      }));
      if (validSteps.length === 0) continue;
      const owner = mission.owner ?? "praxis";
      const proposalResult = await createProposalAndMaybeAutoApprove({
        agent_id: owner,
        title: mission.title,
        description: mission.description,
        proposed_steps: validSteps,
        source: "conversation",
        source_trace_id: sessionId
      });
      if (proposalResult.success) {
        created++;
        log27.info("Action extracted from roundtable artifact", {
          sessionId,
          format,
          proposalId: proposalResult.proposalId,
          missionId: proposalResult.missionId,
          title: mission.title,
          autoApproved: !!proposalResult.missionId
        });
      }
    }
    return created;
  } catch (err) {
    log27.error("Action extraction failed", {
      error: err,
      sessionId,
      format
    });
    return 0;
  }
}
var log27, ACTIONABLE_FORMATS, VALID_STEP_KINDS;
var init_action_extractor = __esm({
  "src/lib/roundtable/action-extractor.ts"() {
    "use strict";
    init_client();
    init_proposal_service();
    init_logger();
    log27 = logger.child({ module: "action-extractor" });
    ACTIONABLE_FORMATS = /* @__PURE__ */ new Set([
      "planning",
      "strategy",
      "retro",
      "standup",
      "shipping",
      "triage"
    ]);
    VALID_STEP_KINDS = /* @__PURE__ */ new Set([
      "research_topic",
      "scan_signals",
      "draft_essay",
      "draft_thread",
      "patch_code",
      "audit_system",
      "critique_content",
      "distill_insight",
      "document_lesson",
      "consolidate_memory"
    ]);
  }
});

// src/lib/ops/memory-archaeology.ts
var memory_archaeology_exports = {};
__export(memory_archaeology_exports, {
  getDigHistory: () => getDigHistory,
  getFindings: () => getFindings,
  getFindingsForMemory: () => getFindingsForMemory,
  getLastDigTimestamp: () => getLastDigTimestamp,
  getLatestFindings: () => getLatestFindings,
  performDig: () => performDig
});
async function performDig(config2) {
  const digId = import_crypto.default.randomUUID();
  const agentId = config2.agent_id ?? "system";
  const maxMemories = config2.max_memories ?? DEFAULT_MAX_MEMORIES;
  log28.info("Starting archaeological dig", { digId, agentId, maxMemories });
  const memories = await fetchMemoriesForDig(config2, maxMemories);
  if (memories.length < 3) {
    log28.info("Not enough memories for archaeology", {
      digId,
      available: memories.length
    });
    return {
      dig_id: digId,
      agent_id: agentId,
      findings: [],
      memories_analyzed: 0
    };
  }
  const batches = [];
  for (let i = 0; i < memories.length; i += MEMORIES_PER_BATCH) {
    batches.push(memories.slice(i, i + MEMORIES_PER_BATCH));
  }
  const allFindings = [];
  for (const batch of batches) {
    const findings = await analyzeBatch(
      batch,
      agentId,
      config2.finding_types
    );
    allFindings.push(...findings);
  }
  const timestamps = memories.map((m) => new Date(m.created_at).getTime());
  const timeSpan = {
    from: new Date(Math.min(...timestamps)).toISOString(),
    to: new Date(Math.max(...timestamps)).toISOString()
  };
  for (const finding of allFindings) {
    await sql`
            INSERT INTO ops_memory_archaeology
                (dig_id, agent_id, finding_type, title, description, evidence, confidence, time_span, related_agents, metadata)
            VALUES (
                ${digId},
                ${agentId},
                ${finding.finding_type},
                ${finding.title},
                ${finding.description},
                ${jsonb(finding.evidence)},
                ${finding.confidence},
                ${jsonb(timeSpan)},
                ${finding.related_agents},
                ${jsonb({})}
            )
        `;
  }
  await emitEvent({
    agent_id: agentId,
    kind: "memory_archaeology_complete",
    title: `${agentId} completed archaeological dig`,
    summary: `Found ${allFindings.length} findings across ${memories.length} memories`,
    tags: ["archaeology", "memory-analysis"],
    metadata: {
      dig_id: digId,
      finding_count: allFindings.length,
      memories_analyzed: memories.length,
      finding_types: [...new Set(allFindings.map((f) => f.finding_type))]
    }
  });
  log28.info("Archaeological dig completed", {
    digId,
    agentId,
    findingCount: allFindings.length,
    memoriesAnalyzed: memories.length
  });
  return {
    dig_id: digId,
    agent_id: agentId,
    findings: allFindings,
    memories_analyzed: memories.length
  };
}
async function fetchMemoriesForDig(config2, maxMemories) {
  const { agent_id, time_range } = config2;
  return sql`
        SELECT
            id,
            agent_id,
            type,
            CASE
                WHEN LENGTH(content) > 2000 THEN LEFT(content, 2000) || '...[truncated]'
                ELSE content
            END as content,
            confidence,
            tags,
            created_at
        FROM ops_agent_memory
        WHERE superseded_by IS NULL
        ${agent_id ? sql`AND agent_id = ${agent_id}` : sql``}
        ${time_range?.from ? sql`AND created_at >= ${time_range.from.toISOString()}` : sql``}
        ${time_range?.to ? sql`AND created_at <= ${time_range.to.toISOString()}` : sql``}
        ORDER BY created_at DESC
        LIMIT ${maxMemories}
    `;
}
async function analyzeBatch(memories, agentId, findingTypes) {
  const typesLabel = findingTypes?.length ? findingTypes.join(", ") : "pattern, contradiction, emergence, echo, drift";
  const memorySummary = memories.map(
    (m, i) => `[${i + 1}] Agent: ${m.agent_id} | Type: ${m.type} | Confidence: ${m.confidence} | Tags: ${m.tags.join(", ") || "none"} | Date: ${new Date(m.created_at).toISOString().slice(0, 10)}
${m.content}`
  ).join("\n\n");
  const estimatedInputTokens = Math.ceil(
    memorySummary.length / CHARS_PER_TOKEN_ESTIMATE
  );
  if (estimatedInputTokens > TOKEN_WARNING_THRESHOLD) {
    log28.warn("High token count in archaeology batch", {
      agentId,
      estimatedInputTokens,
      memoryCount: memories.length,
      recommendation: "Consider reducing batch size"
    });
  }
  const systemPrompt = `You are a memory archaeologist for the SubCult AI collective. Your task is to perform deep analysis of agent memories, looking for hidden patterns, contradictions, emergent behaviors, recurring echoes, and personality drift.

Analyze the provided memories and identify findings of these types: ${typesLabel}

Finding type definitions:
- **pattern**: Recurring themes, behaviors, or ideas that appear across multiple memories
- **contradiction**: Memories that conflict with each other or represent opposing viewpoints held by the same or different agents
- **emergence**: New behaviors, ideas, or perspectives that appear in recent memories but were absent earlier
- **echo**: Specific phrases, metaphors, or ideas that reappear across different contexts or time periods
- **drift**: How an agent's perspective, tone, or beliefs have shifted over time

For each finding, provide:
1. The finding type
2. A concise title (5-10 words)
3. A detailed description (2-4 sentences)
4. Evidence: which memory numbers (from the list) support this finding, with a brief excerpt and relevance note
5. Confidence (0.0 to 1.0) \u2014 how certain you are about this finding
6. Related agents \u2014 which agent IDs are involved

Respond with valid JSON only:
{
  "findings": [
    {
      "finding_type": "pattern|contradiction|emergence|echo|drift",
      "title": "short descriptive title",
      "description": "detailed explanation",
      "evidence": [
        { "memory_index": 1, "excerpt": "relevant quote", "relevance": "why this supports the finding" }
      ],
      "confidence": 0.8,
      "related_agents": ["agent_id1", "agent_id2"]
    }
  ]
}

Rules:
- Report your top 3-5 most significant findings only \u2014 quality over quantity
- Only report genuine findings backed by evidence from the provided memories
- Each finding must reference at least 2 memories as evidence
- Be specific \u2014 vague findings are not useful
- Keep descriptions to 2-3 sentences max
- Keep evidence excerpts under 50 words each
- Confidence should reflect the strength of evidence
- If you find nothing meaningful, return { "findings": [] }
- CRITICAL: Your response must be complete, valid JSON. Do not exceed 5 findings.`;
  const result = await llmGenerate({
    messages: [
      { role: "system", content: systemPrompt },
      {
        role: "user",
        content: `Analyze these ${memories.length} memories for archaeological findings:

${memorySummary}`
      }
    ],
    temperature: ANALYSIS_TEMPERATURE,
    maxTokens: ANALYSIS_MAX_TOKENS,
    trackingContext: {
      agentId,
      context: "memory_archaeology"
    }
  });
  if (!result?.trim()) {
    log28.warn("Archaeology analysis returned empty", { agentId });
    return [];
  }
  try {
    let jsonStr = result.match(/\{[\s\S]*\}/)?.[0];
    if (!jsonStr) {
      const openBrace = result.indexOf("{");
      if (openBrace >= 0) {
        jsonStr = result.slice(openBrace);
        const lastCompleteObj = jsonStr.lastIndexOf("}");
        if (lastCompleteObj > 0) {
          jsonStr = jsonStr.slice(0, lastCompleteObj + 1) + "]}";
        }
        log28.info("Attempting truncated JSON recovery", {
          originalLength: result.length,
          recoveredLength: jsonStr.length
        });
      } else {
        log28.warn("No JSON found in archaeology response", {
          responsePreview: result.slice(0, 200)
        });
        return [];
      }
    }
    const parsed = JSON.parse(jsonStr);
    if (!parsed.findings || !Array.isArray(parsed.findings)) {
      log28.warn("Invalid JSON structure in archaeology response", {
        hasFindings: !!parsed.findings,
        isArray: Array.isArray(parsed.findings),
        keys: Object.keys(parsed)
      });
      return [];
    }
    const validTypes = /* @__PURE__ */ new Set([
      "pattern",
      "contradiction",
      "emergence",
      "echo",
      "drift"
    ]);
    return parsed.findings.filter(
      (f) => validTypes.has(f.finding_type) && f.title && f.description
    ).map((f) => {
      const evidenceWithWarnings = (f.evidence ?? []).map((e) => {
        const memory = memories[e.memory_index - 1];
        if (!memory) {
          log28.warn(
            "LLM referenced invalid memory_index in evidence",
            {
              memory_index: e.memory_index,
              available_count: memories.length,
              finding_title: f.title
            }
          );
        }
        return {
          memory_id: memory?.id ?? "unknown",
          excerpt: e.excerpt ?? "",
          relevance: e.relevance ?? ""
        };
      }).filter((e) => e.memory_id !== "unknown");
      if (f.evidence?.length > 0 && evidenceWithWarnings.length === 0) {
        log28.warn("All evidence filtered due to invalid memory indices", {
          finding_title: f.title,
          evidence_count: f.evidence.length
        });
      }
      return {
        finding_type: f.finding_type,
        title: f.title,
        description: f.description,
        evidence: evidenceWithWarnings,
        confidence: Math.max(0, Math.min(1, f.confidence ?? 0.5)),
        related_agents: f.related_agents ?? []
      };
    });
  } catch (err) {
    log28.error("Failed to parse archaeology findings", {
      error: err.message,
      responseLength: result.length,
      responsePreview: result.slice(0, 300),
      responseTail: result.slice(-200)
    });
    return [];
  }
}
async function getDigHistory(limit = 20) {
  return sql`
        SELECT
            dig_id,
            agent_id,
            COUNT(*)::int as finding_count,
            array_agg(DISTINCT finding_type) as finding_types,
            MIN(created_at) as started_at
        FROM ops_memory_archaeology
        GROUP BY dig_id, agent_id
        ORDER BY MIN(created_at) DESC
        LIMIT ${limit}
    `;
}
async function getFindings(digId) {
  return sql`
        SELECT * FROM ops_memory_archaeology
        WHERE dig_id = ${digId}
        ORDER BY confidence DESC
    `;
}
async function getLatestFindings(limit = 10) {
  return sql`
        SELECT * FROM ops_memory_archaeology
        ORDER BY created_at DESC
        LIMIT ${limit}
    `;
}
async function getFindingsForMemory(memoryId) {
  return sql`
        SELECT * FROM ops_memory_archaeology
        WHERE evidence @> ${jsonb([{ memory_id: memoryId }])}
        ORDER BY confidence DESC
    `;
}
async function getLastDigTimestamp() {
  const [row] = await sql`
        SELECT MAX(created_at) as latest FROM ops_memory_archaeology
    `;
  return row?.latest ? new Date(row.latest) : null;
}
var import_crypto, log28, DEFAULT_MAX_MEMORIES, MEMORIES_PER_BATCH, ANALYSIS_TEMPERATURE, ANALYSIS_MAX_TOKENS, CHARS_PER_TOKEN_ESTIMATE, TOKEN_WARNING_THRESHOLD;
var init_memory_archaeology = __esm({
  "src/lib/ops/memory-archaeology.ts"() {
    "use strict";
    init_db();
    init_client();
    init_events2();
    init_logger();
    import_crypto = __toESM(require("crypto"));
    log28 = logger.child({ module: "memory-archaeology" });
    DEFAULT_MAX_MEMORIES = 100;
    MEMORIES_PER_BATCH = 25;
    ANALYSIS_TEMPERATURE = 0.7;
    ANALYSIS_MAX_TOKENS = 4e3;
    CHARS_PER_TOKEN_ESTIMATE = 4;
    TOKEN_WARNING_THRESHOLD = 8e3;
  }
});

// src/lib/ops/step-prompts.ts
var step_prompts_exports = {};
__export(step_prompts_exports, {
  buildStepPrompt: () => buildStepPrompt,
  loadStepTemplate: () => loadStepTemplate
});
async function loadStepTemplate(kind) {
  const cached2 = templateCache.get(kind);
  if (cached2 && Date.now() - cached2.ts < TEMPLATE_CACHE_TTL_MS) {
    return cached2.template;
  }
  const [row] = await sql`
        SELECT kind, template, tools_hint, output_hint, version
        FROM ops_step_templates WHERE kind = ${kind}
    `;
  const template = row ?? null;
  templateCache.set(kind, { template, ts: Date.now() });
  return template;
}
function renderTemplate(template, vars) {
  return template.replace(/\{\{(\w+)\}\}/g, (_, key) => vars[key] ?? `{{${key}}}`);
}
async function buildStepPrompt(kind, ctx, opts) {
  const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
  const payloadStr = JSON.stringify(ctx.payload, null, 2);
  const outputDir = ctx.outputPath ?? `agents/${ctx.agentId}/notes`;
  let header = `Mission: ${ctx.missionTitle}
`;
  header += `Step: ${kind}
`;
  header += `Payload: ${payloadStr}

`;
  let dbTemplate = null;
  try {
    dbTemplate = await loadStepTemplate(kind);
  } catch {
  }
  if (dbTemplate) {
    const vars = {
      date: today,
      agentId: ctx.agentId,
      missionTitle: ctx.missionTitle,
      missionSlug: slugify2(ctx.missionTitle),
      outputDir,
      payload: payloadStr
    };
    const rendered = renderTemplate(dbTemplate.template, vars);
    const prompt2 = header + rendered;
    return opts?.withVersion ? { prompt: prompt2, templateVersion: dbTemplate.version } : prompt2;
  }
  let body;
  const stepInstructions = STEP_INSTRUCTIONS[kind];
  if (stepInstructions) {
    body = stepInstructions(ctx, today, outputDir);
  } else {
    body = `Execute this step thoroughly. Write your results to ${outputDir}/ using file_write.
`;
    body += `Provide a detailed summary of what you accomplished.
`;
  }
  const prompt = header + body;
  return opts?.withVersion ? { prompt, templateVersion: null } : prompt;
}
function slugify2(text2) {
  return text2.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "").slice(0, 30);
}
var TEMPLATE_CACHE_TTL_MS, templateCache, STEP_INSTRUCTIONS;
var init_step_prompts = __esm({
  "src/lib/ops/step-prompts.ts"() {
    "use strict";
    init_db();
    TEMPLATE_CACHE_TTL_MS = 6e4;
    templateCache = /* @__PURE__ */ new Map();
    STEP_INSTRUCTIONS = {
      research_topic: (ctx, today, outputDir) => `Use web_search to research the topic described in the payload.
Search for 3-5 relevant queries to build a comprehensive picture.
Use web_fetch to read the most relevant pages.
Write your research notes to ${outputDir}/${today}__research__notes__${slugify2(ctx.missionTitle)}__${ctx.agentId}__v01.md using file_write.
Include: key findings, sources, quotes, and your analysis.
`,
      scan_signals: (ctx, today, outputDir) => `Use web_search to scan for signals related to the payload topic.
Look for recent developments, trends, and notable changes.
Write a signal report to ${outputDir}/${today}__scan__signals__${slugify2(ctx.missionTitle)}__${ctx.agentId}__v01.md using file_write.
Format: bullet points grouped by signal type (opportunity, threat, trend, noise).
Focus on scanning and documenting signals only. Do not call propose_mission during this step.
`,
      draft_essay: (ctx, today) => `Read any research notes from agents/${ctx.agentId}/notes/ using file_read.
Draft an essay based on the payload and your research.
Write the draft to output/reports/${today}__draft__essay__${slugify2(ctx.missionTitle)}__${ctx.agentId}__v01.md using file_write.
Include YAML front matter with artifact_id, created_at, agent_id, workflow_stage: "draft", status: "draft".
`,
      draft_thread: (ctx, today) => `Read any research notes from agents/${ctx.agentId}/notes/ using file_read.
Draft a concise thread (5-10 punchy points) based on the payload.
Write to output/reports/${today}__draft__thread__${slugify2(ctx.missionTitle)}__${ctx.agentId}__v01.md using file_write.
`,
      critique_content: (ctx, today) => `Read the artifact or content referenced in the payload using file_read.
Write a structured critique to output/reviews/${today}__critique__review__${slugify2(ctx.missionTitle)}__${ctx.agentId}__v01.md.
Cover: strengths, weaknesses, factual accuracy, tone, suggestions for improvement.
`,
      audit_system: (ctx, today) => `Use bash to run system checks relevant to the payload.
Check file permissions, exposed ports, running services, or whatever the payload specifies.
Write findings to output/reviews/${today}__audit__security__${slugify2(ctx.missionTitle)}__${ctx.agentId}__v01.md using file_write.
Rate findings by severity: critical, high, medium, low, info.
`,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      patch_code: (_ctx) => `Read the relevant source files from projects/ using file_read.
Use bash to make code changes as described in the payload.
Write changed files using file_write to the projects/ directory.
Provide a summary of all changes made and why.
`,
      distill_insight: (ctx, today) => `Read recent outputs from output/ and agents/${ctx.agentId}/notes/ using file_read.
Synthesize into a concise digest of key insights.
Write to output/digests/${today}__distill__insight__${slugify2(ctx.missionTitle)}__${ctx.agentId}__v01.md using file_write.
`,
      document_lesson: (ctx, today) => `Document the lesson or knowledge described in the payload.
Write clear, reusable documentation to the appropriate projects/ docs/ directory.
If no specific project, write to output/reports/${today}__docs__lesson__${slugify2(ctx.missionTitle)}__${ctx.agentId}__v01.md.
`,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      convene_roundtable: (_ctx) => `This step triggers a roundtable conversation.
The payload should specify the format and topic.
Provide a summary of what the roundtable should discuss and why.
`,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      propose_workflow: (_ctx) => `Based on the payload, propose a multi-step workflow.
Each step should specify: agent, step kind, and expected output.
Write the workflow proposal as a structured plan.
`,
      memory_archaeology: (ctx, today, outputDir) => `Perform a memory archaeology dig to analyze agent memories for patterns, contradictions, emergence, echoes, and drift.
Use the memory_search tool to retrieve relevant memories from the collective.
Analyze the memories for:
  - **Patterns**: Recurring themes, behaviors, or ideas across multiple memories
  - **Contradictions**: Conflicting memories or opposing viewpoints
  - **Emergence**: New behaviors, ideas, or perspectives that appear in recent memories
  - **Echoes**: Specific phrases, metaphors, or ideas that reappear across contexts
  - **Drift**: How perspectives, tone, or beliefs have shifted over time
Write your findings to ${outputDir}/${today}__archaeology__findings__${slugify2(ctx.missionTitle)}__${ctx.agentId}__v01.md using file_write.
For each finding, include:
  1. Finding type (pattern/contradiction/emergence/echo/drift)
  2. A concise title
  3. Detailed description with evidence from specific memories
  4. Confidence level (0.0 to 1.0)
  5. Related agent IDs
Be specific and evidence-based. Include memory IDs and excerpts to support your findings.
`
    };
  }
});

// src/lib/ops/agent-designer.ts
var agent_designer_exports = {};
__export(agent_designer_exports, {
  generateAgentProposal: () => generateAgentProposal,
  getProposalById: () => getProposalById,
  getProposals: () => getProposals,
  saveProposal: () => saveProposal,
  setHumanApproval: () => setHumanApproval
});
async function generateAgentProposal(proposerId) {
  log29.info("Generating agent proposal", { proposer: proposerId });
  const agents = await sql`
        SELECT agent_id, display_name, role
        FROM ops_agent_registry
        WHERE active = true
        ORDER BY agent_id
    `;
  const skills = await sql`
        SELECT agent_id, skill_name
        FROM ops_agent_skills
        ORDER BY agent_id
    `;
  const recentSessions = await sql`
        SELECT format, topic, participants
        FROM ops_roundtable_sessions
        WHERE status = 'completed'
        ORDER BY completed_at DESC
        LIMIT 10
    `;
  const [pendingCount] = await sql`
        SELECT COUNT(*)::int as count
        FROM ops_agent_proposals
        WHERE status IN ('proposed', 'voting')
    `;
  if (pendingCount.count >= 2) {
    log29.info("Skipping proposal \u2014 too many pending proposals", {
      pending: pendingCount.count
    });
    throw new Error(
      `Cannot generate proposal: ${pendingCount.count} proposals already pending`
    );
  }
  const agentRoster = agents.map((a) => `- ${a.display_name} (${a.agent_id}): ${a.role}`).join("\n");
  const skillMap = /* @__PURE__ */ new Map();
  for (const s of skills) {
    const list = skillMap.get(s.agent_id) ?? [];
    list.push(s.skill_name);
    skillMap.set(s.agent_id, list);
  }
  const skillCoverage = Array.from(skillMap.entries()).map(([id, sk]) => `- ${id}: ${sk.join(", ")}`).join("\n");
  const recentTopics = recentSessions.map((s) => `- [${s.format}] ${s.topic}`).join("\n");
  const systemPrompt = `You are ${proposerId}, an agent in the SubCult collective. You have the ability to propose new agents to join the collective.

Analyze the current composition and identify gaps \u2014 missing capabilities, underserved domains, or personality dynamics that would strengthen the group.

Current agent roster:
${agentRoster}

Current skill coverage:
${skillCoverage || "(no skills data)"}

Recent roundtable topics:
${recentTopics || "(no recent sessions)"}

Rules:
- The proposed agent must fill a genuine gap \u2014 do not propose redundant agents.
- The name should be evocative and lowercase (like existing agents: chora, subrosa, thaum, praxis, mux, primus).
- The role should describe the agent's function in 1-2 words.
- Personality should define tone, traits, speaking style, and optionally an emoji symbol.
- Skills should be concrete and actionable (3-6 skills).
- The rationale must explain WHY the collective needs this agent NOW.

Respond with valid JSON only, no markdown fencing:
{
  "agent_name": "lowercase_name",
  "agent_role": "role_in_1_2_words",
  "personality": {
    "tone": "description of tone",
    "traits": ["trait1", "trait2", "trait3"],
    "speaking_style": "how this agent communicates",
    "emoji": "single emoji symbol"
  },
  "skills": ["skill1", "skill2", "skill3"],
  "rationale": "why the collective needs this agent"
}`;
  const result = await llmGenerate({
    messages: [
      { role: "system", content: systemPrompt },
      {
        role: "user",
        content: "Analyze the collective and propose a new agent if a genuine gap exists."
      }
    ],
    temperature: 0.85,
    maxTokens: 1500,
    trackingContext: {
      agentId: proposerId,
      context: "agent_design"
    }
  });
  let parsed;
  try {
    const jsonMatch = result.match(/\{[\s\S]*\}/);
    if (!jsonMatch) throw new Error("No JSON found in LLM response");
    parsed = JSON.parse(jsonMatch[0]);
  } catch (err) {
    log29.error("Failed to parse agent proposal from LLM", {
      error: err,
      responsePreview: result.slice(0, 200)
    });
    throw new Error(
      `Failed to parse agent proposal: ${err.message}`
    );
  }
  if (!parsed.agent_name || !parsed.agent_role || !parsed.rationale) {
    throw new Error("LLM response missing required fields");
  }
  const agentName = parsed.agent_name.toLowerCase().replace(/[^a-z0-9_]/g, "");
  if (!agentName) {
    throw new Error(
      `Invalid agent_name: "${parsed.agent_name}" normalized to empty string`
    );
  }
  const [existing] = await sql`
        SELECT COUNT(*)::int as count
        FROM ops_agent_registry
        WHERE agent_id = ${agentName}
    `;
  if (existing.count > 0) {
    throw new Error(`Agent "${agentName}" already exists in the registry`);
  }
  const [pendingProposal] = await sql`
        SELECT COUNT(*)::int as count
        FROM ops_agent_proposals
        WHERE agent_name = ${agentName}
          AND status IN ('proposed', 'voting', 'approved')
    `;
  if (pendingProposal.count > 0) {
    throw new Error(
      `A proposal for agent "${agentName}" already exists and is pending`
    );
  }
  const proposalId = await saveProposal(
    {
      agent_name: agentName,
      agent_role: parsed.agent_role,
      personality: parsed.personality ?? {
        tone: "neutral",
        traits: [],
        speaking_style: "direct"
      },
      skills: parsed.skills ?? [],
      rationale: parsed.rationale
    },
    proposerId
  );
  await emitEventAndCheckReactions({
    agent_id: proposerId,
    kind: "agent_proposal_created",
    title: `${proposerId} proposes new agent: ${agentName}`,
    summary: parsed.rationale,
    tags: ["agent-designer", "proposal", agentName],
    metadata: {
      proposalId,
      agentName,
      agentRole: parsed.agent_role,
      proposer: proposerId
    }
  });
  const proposal = await getProposalById(proposalId);
  if (!proposal) throw new Error("Failed to retrieve saved proposal");
  return proposal;
}
async function saveProposal(proposal, proposerId) {
  const [row] = await sql`
        INSERT INTO ops_agent_proposals
            (proposed_by, agent_name, agent_role, personality, skills, rationale)
        VALUES (
            ${proposerId},
            ${proposal.agent_name},
            ${proposal.agent_role},
            ${jsonb(proposal.personality)},
            ${jsonb(proposal.skills)},
            ${proposal.rationale}
        )
        RETURNING id
    `;
  log29.info("Agent proposal saved", {
    id: row.id,
    proposer: proposerId,
    agentName: proposal.agent_name
  });
  return row.id;
}
async function getProposals(filters) {
  const limit = filters?.limit ?? 50;
  const status = filters?.status;
  const proposedBy = filters?.proposedBy;
  if (status && proposedBy) {
    return sql`
            SELECT * FROM ops_agent_proposals
            WHERE status = ${status} AND proposed_by = ${proposedBy}
            ORDER BY created_at DESC
            LIMIT ${limit}
        `;
  } else if (status) {
    return sql`
            SELECT * FROM ops_agent_proposals
            WHERE status = ${status}
            ORDER BY created_at DESC
            LIMIT ${limit}
        `;
  } else if (proposedBy) {
    return sql`
            SELECT * FROM ops_agent_proposals
            WHERE proposed_by = ${proposedBy}
            ORDER BY created_at DESC
            LIMIT ${limit}
        `;
  }
  return sql`
        SELECT * FROM ops_agent_proposals
        ORDER BY created_at DESC
        LIMIT ${limit}
    `;
}
async function getProposalById(id) {
  const [row] = await sql`
        SELECT * FROM ops_agent_proposals WHERE id = ${id}
    `;
  return row ?? null;
}
async function setHumanApproval(proposalId, approved) {
  await sql`
        UPDATE ops_agent_proposals
        SET human_approved = ${approved}
        WHERE id = ${proposalId}
    `;
  log29.info("Human approval set", { proposalId, approved });
}
var log29;
var init_agent_designer = __esm({
  "src/lib/ops/agent-designer.ts"() {
    "use strict";
    init_db();
    init_client();
    init_events2();
    init_logger();
    log29 = logger.child({ module: "agent-designer" });
  }
});

// scripts/unified-worker/index.ts
var import_config3 = require("dotenv/config");
var import_postgres2 = __toESM(require("postgres"));
var import_promises = __toESM(require("fs/promises"));
var import_path = __toESM(require("path"));
init_orchestrator();

// src/lib/tools/agent-session.ts
init_db();
init_client();
init_voices();

// src/lib/types.ts
var ALL_AGENTS = ["chora", "subrosa", "thaum", "praxis", "mux", "primus"];

// src/lib/tools/tools/bash.ts
init_executor();
var bashTool = {
  name: "bash",
  description: "Execute a bash command in the toolbox environment. Has access to standard Linux utilities, curl, jq, git, node, python3, gh CLI, ripgrep, and fd-find.",
  agents: [...ALL_AGENTS],
  parameters: {
    type: "object",
    properties: {
      command: {
        type: "string",
        description: "The bash command to execute"
      },
      timeout_ms: {
        type: "number",
        description: "Timeout in milliseconds (default 30000, max 120000)"
      }
    },
    required: ["command"]
  },
  execute: async (params) => {
    const command = params.command;
    const timeoutMs = Math.min(
      params.timeout_ms || 3e4,
      12e4
    );
    const result = await execInToolbox(command, timeoutMs);
    if (result.timedOut) {
      return { error: `Command timed out after ${timeoutMs}ms`, stderr: result.stderr };
    }
    return {
      exitCode: result.exitCode,
      stdout: result.stdout,
      ...result.stderr ? { stderr: result.stderr } : {}
    };
  }
};

// src/lib/tools/tools/web-search.ts
init_logger();
var log21 = logger.child({ module: "web-search" });
var BRAVE_API_KEY = process.env.BRAVE_API_KEY ?? "";
var BRAVE_SEARCH_URL = "https://api.search.brave.com/res/v1/web/search";
var webSearchTool = {
  name: "web_search",
  description: "Search the web using Brave Search. Returns titles, URLs, and descriptions of matching results.",
  agents: [...ALL_AGENTS],
  parameters: {
    type: "object",
    properties: {
      query: {
        type: "string",
        description: "The search query"
      },
      count: {
        type: "number",
        description: "Number of results to return (default 5, max 20)"
      }
    },
    required: ["query"]
  },
  execute: async (params) => {
    const query = params.query;
    const count = Math.min(params.count || 5, 20);
    if (!BRAVE_API_KEY) {
      return { error: "BRAVE_API_KEY not configured. Unable to search." };
    }
    try {
      const url2 = new URL(BRAVE_SEARCH_URL);
      url2.searchParams.set("q", query);
      url2.searchParams.set("count", String(count));
      const response = await fetch(url2.toString(), {
        headers: {
          "Accept": "application/json",
          "Accept-Encoding": "gzip",
          "X-Subscription-Token": BRAVE_API_KEY
        },
        signal: AbortSignal.timeout(15e3)
      });
      if (!response.ok) {
        return { error: `Brave Search returned ${response.status}: ${await response.text()}` };
      }
      const data = await response.json();
      const results = (data.web?.results ?? []).map((r) => ({
        title: r.title,
        url: r.url,
        description: r.description
      }));
      return { results, query, count: results.length };
    } catch (err) {
      log21.error("Brave Search failed", { error: err, query });
      return { error: `Search failed: ${err.message}` };
    }
  }
};

// src/lib/tools/tools/web-fetch.ts
init_executor();
var webFetchTool = {
  name: "web_fetch",
  description: "Fetch a URL and return its content as markdown text. Useful for reading articles, documentation, or web pages.",
  agents: [...ALL_AGENTS],
  parameters: {
    type: "object",
    properties: {
      url: {
        type: "string",
        description: "The URL to fetch"
      },
      max_length: {
        type: "number",
        description: "Maximum characters to return (default 10000)"
      }
    },
    required: ["url"]
  },
  execute: async (params) => {
    const url2 = params.url;
    const maxLength = params.max_length || 1e4;
    if (typeof maxLength !== "number" || isNaN(maxLength) || maxLength < 1 || maxLength > 1e6) {
      return { error: "max_length must be a number between 1 and 1,000,000" };
    }
    if (!url2.startsWith("http://") && !url2.startsWith("https://")) {
      return { error: "URL must start with http:// or https://" };
    }
    const escapedUrl = url2.replace(/'/g, "'\\''");
    const safeMaxLength = Math.floor(maxLength).toString();
    const command = `curl -sL --max-time 15 --max-filesize 5242880 '${escapedUrl}' | python3 -c "
import sys
try:
    import html2text
    h = html2text.HTML2Text()
    h.ignore_links = False
    h.ignore_images = True
    h.body_width = 0
    content = sys.stdin.read()
    print(h.handle(content)[:${safeMaxLength}])
except Exception as e:
    # Fallback: strip tags manually
    import re
    content = sys.stdin.read()
    text = re.sub(r'<[^>]+>', ' ', content)
    text = re.sub(r'\\s+', ' ', text).strip()
    print(text[:${safeMaxLength}])
"`;
    const result = await execInToolbox(command, 2e4);
    if (result.timedOut) {
      return { error: "URL fetch timed out after 20 seconds" };
    }
    if (result.exitCode !== 0 && !result.stdout) {
      return { error: `Fetch failed: ${result.stderr || "unknown error"}` };
    }
    const content = result.stdout.trim();
    if (!content) {
      return { error: "No content retrieved from URL" };
    }
    return { url: url2, content, length: content.length };
  }
};

// src/lib/tools/tools/file-read.ts
init_executor();
var fileReadTool = {
  name: "file_read",
  description: "Read a file from the shared workspace. Returns the file contents as text.",
  agents: ["chora", "subrosa", "thaum", "praxis", "mux", "primus"],
  parameters: {
    type: "object",
    properties: {
      path: {
        type: "string",
        description: 'File path relative to /workspace (e.g., "data/report.md")'
      },
      max_lines: {
        type: "number",
        description: "Maximum lines to read (default: all)"
      }
    },
    required: ["path"]
  },
  execute: async (params) => {
    const rawPath = params.path;
    const maxLines = params.max_lines;
    const path3 = rawPath.replace(/\.\.\//g, "");
    const fullPath = path3.startsWith("/workspace/") ? path3 : `/workspace/${path3}`;
    let command = `cat '${fullPath.replace(/'/g, "'\\''")}'`;
    if (maxLines) {
      command = `head -n ${maxLines} '${fullPath.replace(/'/g, "'\\''")}'`;
    }
    const result = await execInToolbox(command, 1e4);
    if (result.exitCode !== 0) {
      return { error: `File read failed: ${result.stderr || "file not found"}` };
    }
    return { path: fullPath, content: result.stdout, lines: result.stdout.split("\n").length };
  }
};

// src/lib/tools/tools/file-write.ts
init_executor();
var import_node_crypto = require("node:crypto");
init_db();
var import_node_path = __toESM(require("node:path"));
var WRITE_ACLS = {
  chora: ["agents/chora/", "output/reports/", "output/briefings/", "output/digests/"],
  subrosa: ["agents/subrosa/", "output/reviews/"],
  thaum: ["agents/thaum/", "output/"],
  praxis: ["agents/praxis/", "output/"],
  mux: ["agents/mux/", "output/"],
  primus: ["agents/primus/", "shared/", "output/"]
};
var DROID_PREFIX = "droids/";
function isPathAllowed(agentId, relativePath) {
  if (agentId.startsWith("droid-")) {
    return relativePath.startsWith(`${DROID_PREFIX}${agentId}/`);
  }
  const acls = WRITE_ACLS[agentId];
  if (!acls) return false;
  return acls.some((prefix) => relativePath.startsWith(prefix));
}
var GRANT_CACHE_TTL_MS = 3e4;
var grantCache = /* @__PURE__ */ new Map();
async function getActiveGrants(agentId) {
  const cached2 = grantCache.get(agentId);
  if (cached2 && Date.now() - cached2.ts < GRANT_CACHE_TTL_MS) {
    return cached2.prefixes;
  }
  const rows = await sql`
        SELECT path_prefix FROM ops_acl_grants
        WHERE agent_id = ${agentId} AND expires_at > NOW()
    `;
  const prefixes = rows.map((r) => r.path_prefix);
  grantCache.set(agentId, { prefixes, ts: Date.now() });
  return prefixes;
}
async function isPathAllowedWithGrants(agentId, relativePath) {
  if (isPathAllowed(agentId, relativePath)) return true;
  try {
    const grants = await getActiveGrants(agentId);
    return grants.some((prefix) => relativePath.startsWith(prefix));
  } catch {
    return false;
  }
}
async function appendManifest(artifactId, fullPath, agentId, contentLength) {
  const relativePath = fullPath.replace("/workspace/", "");
  let artifactType = "unknown";
  if (relativePath.startsWith("output/briefings/")) artifactType = "briefing";
  else if (relativePath.startsWith("output/reports/")) artifactType = "report";
  else if (relativePath.startsWith("output/reviews/")) artifactType = "review";
  else if (relativePath.startsWith("output/digests/")) artifactType = "digest";
  else if (relativePath.startsWith("output/")) artifactType = "artifact";
  const entry = JSON.stringify({
    artifact_id: artifactId,
    path: relativePath,
    agent_id: agentId,
    type: artifactType,
    created_at: (/* @__PURE__ */ new Date()).toISOString(),
    bytes: contentLength
  });
  const b64 = Buffer.from(entry + "\n").toString("base64");
  await execInToolbox(
    `echo '${b64}' | base64 -d >> /workspace/shared/manifests/index.jsonl`,
    5e3
  );
}
function createFileWriteExecute(agentId) {
  return async (params) => {
    const rawPath = params.path;
    const content = params.content;
    const append = params.append ?? false;
    if (rawPath.includes("..")) {
      return {
        error: "Invalid path: path traversal sequences (..) are not allowed"
      };
    }
    const normalizedPath = import_node_path.default.normalize(rawPath);
    const relativePath = normalizedPath.startsWith("/workspace/") ? normalizedPath.replace("/workspace/", "") : normalizedPath.startsWith("/") ? normalizedPath.slice(1) : normalizedPath;
    const fullPath = import_node_path.default.resolve("/workspace", relativePath);
    if (!fullPath.startsWith("/workspace/")) {
      return {
        error: "Invalid path: must be within /workspace/"
      };
    }
    if (!await isPathAllowedWithGrants(agentId, relativePath)) {
      return {
        error: `Access denied: ${agentId} cannot write to ${relativePath}. Check your designated write paths.`
      };
    }
    const b64 = Buffer.from(content).toString("base64");
    const dir = fullPath.substring(0, fullPath.lastIndexOf("/"));
    const op = append ? ">>" : ">";
    const command = `mkdir -p '${dir.replace(/'/g, "'\\''")}' && echo '${b64}' | base64 -d ${op} '${fullPath.replace(/'/g, "'\\''")}'`;
    const result = await execInToolbox(command, 1e4);
    if (result.exitCode !== 0) {
      return { error: `File write failed: ${result.stderr || "unknown error"}` };
    }
    if (relativePath.startsWith("output/")) {
      const artifactId = (0, import_node_crypto.randomUUID)();
      try {
        await appendManifest(artifactId, fullPath, agentId, content.length);
      } catch {
      }
      return { path: fullPath, bytes: content.length, appended: append, artifact_id: artifactId };
    }
    return { path: fullPath, bytes: content.length, appended: append };
  };
}
var fileWriteTool = {
  name: "file_write",
  description: "Write content to a file in the shared workspace. Creates parent directories if needed. Path access is restricted by agent role.",
  agents: ["chora", "subrosa", "thaum", "praxis", "mux", "primus"],
  parameters: {
    type: "object",
    properties: {
      path: {
        type: "string",
        description: 'File path relative to /workspace (e.g., "output/reports/2026-02-13__research__brief__topic__chora__v01.md")'
      },
      content: {
        type: "string",
        description: "The content to write to the file"
      },
      append: {
        type: "boolean",
        description: "If true, append to file instead of overwriting (default false)"
      }
    },
    required: ["path", "content"]
  },
  // Default execute explicitly fails — tool must be bound to an agentId via registry
  execute: async () => {
    return {
      error: "file_write tool must be bound to an agent ID. This tool should only be used through the registry with getAgentTools() or getDroidTools()."
    };
  }
};

// src/lib/tools/tools/send-to-agent.ts
init_executor();
var sendToAgentTool = {
  name: "send_to_agent",
  description: "Send a message or file to another agent by writing to their inbox. The file will appear in /workspace/agents/{target}/inbox/.",
  agents: ["chora", "subrosa", "thaum", "praxis", "mux", "primus"],
  parameters: {
    type: "object",
    properties: {
      target_agent: {
        type: "string",
        description: "The agent to send to (chora, subrosa, thaum, praxis, mux, primus)",
        enum: ["chora", "subrosa", "thaum", "praxis", "mux", "primus"]
      },
      filename: {
        type: "string",
        description: 'Filename for the message (e.g., "request-review.md")'
      },
      content: {
        type: "string",
        description: "The content of the message or file"
      }
    },
    required: ["target_agent", "filename", "content"]
  },
  execute: async (params) => {
    const target = params.target_agent;
    const filename = params.filename;
    const content = params.content;
    const validAgents = ["chora", "subrosa", "thaum", "praxis", "mux", "primus"];
    if (!validAgents.includes(target)) {
      return { error: `Invalid target agent: ${target}` };
    }
    const safeName = filename.replace(/[^a-zA-Z0-9._-]/g, "_");
    const fullPath = `/workspace/agents/${target}/inbox/${safeName}`;
    const b64 = Buffer.from(content).toString("base64");
    const dir = `/workspace/agents/${target}/inbox`;
    const command = `mkdir -p '${dir}' && echo '${b64}' | base64 -d > '${fullPath}'`;
    const result = await execInToolbox(command, 1e4);
    if (result.exitCode !== 0) {
      return { error: `Send failed: ${result.stderr || "unknown error"}` };
    }
    return { sent_to: target, path: fullPath, bytes: content.length };
  }
};

// src/lib/tools/tools/spawn-droid.ts
init_db();
init_executor();
var import_node_crypto2 = require("node:crypto");
var MAX_DROID_TIMEOUT = 300;
var DEFAULT_DROID_TIMEOUT = 120;
var spawnDroidTool = {
  name: "spawn_droid",
  description: "Spawn a droid (sub-agent) to handle a focused task. The droid runs as an agent session with its own workspace under /workspace/droids/. Returns a droid_id to check status later with check_droid.",
  agents: [...ALL_AGENTS],
  parameters: {
    type: "object",
    properties: {
      task: {
        type: "string",
        description: "Clear description of what the droid should do"
      },
      output_path: {
        type: "string",
        description: 'Where to write results relative to the droid workspace (e.g., "report.md")'
      },
      timeout_seconds: {
        type: "number",
        description: `Max execution time in seconds (default ${DEFAULT_DROID_TIMEOUT}, max ${MAX_DROID_TIMEOUT})`
      }
    },
    required: ["task"]
  },
  execute: async (params) => {
    const task = params.task;
    const rawOutputFilename = params.output_path ?? "output.md";
    const outputFilename = rawOutputFilename.replace(/\.\./g, "").replace(/[^a-zA-Z0-9._-]/g, "_").replace(/^[._-]+/, "").slice(0, 128);
    const safeOutputFilename = outputFilename || "output.md";
    const timeout = Math.min(
      params.timeout_seconds ?? DEFAULT_DROID_TIMEOUT,
      MAX_DROID_TIMEOUT
    );
    const droidId = `droid-${(0, import_node_crypto2.randomUUID)().slice(0, 8)}`;
    const droidDir = `/workspace/droids/${droidId}`;
    const outputPath = `droids/${droidId}/${safeOutputFilename}`;
    try {
      await execInToolbox(`mkdir -p '${droidDir}/output'`, 5e3);
      const taskContent = `# Droid Task

ID: ${droidId}
Created: ${(/* @__PURE__ */ new Date()).toISOString()}

## Task

${task}

## Output

Write results to: ${outputPath}
`;
      const b64 = Buffer.from(taskContent).toString("base64");
      await execInToolbox(`echo '${b64}' | base64 -d > '${droidDir}/task.md'`, 5e3);
    } catch {
      return { error: "Failed to create droid workspace" };
    }
    const prompt = `You are a droid (focused sub-agent) with ID: ${droidId}.

## Your Task
${task}

## Security Boundaries
- You can ONLY write files to droids/${droidId}/ using file_write
- You can read any file in /workspace/ using file_read
- You can use bash and web_search as needed
- You CANNOT write to /workspace/output/ directly \u2014 your parent agent must promote your work
- You CANNOT modify /workspace/projects/ source code \u2014 write patches to your droid workspace

## Output
Write your results to ${outputPath} using file_write.
When done, provide a clear summary of what you accomplished.
`;
    try {
      const [session] = await sql`
                INSERT INTO ops_agent_sessions (
                    agent_id, prompt, source, source_id,
                    timeout_seconds, max_tool_rounds, status,
                    result
                ) VALUES (
                    ${droidId},
                    ${prompt},
                    'droid',
                    ${droidId},
                    ${timeout},
                    8,
                    'pending',
                    ${sql.json({ droid_id: droidId, output_path: outputPath })}::jsonb
                )
                RETURNING id
            `;
      return {
        droid_id: droidId,
        session_id: session.id,
        status: "spawned",
        workspace: droidDir,
        output_path: outputPath
      };
    } catch (err) {
      return { error: `Failed to spawn droid: ${err.message}` };
    }
  }
};

// src/lib/tools/tools/check-droid.ts
init_db();
init_executor();
var checkDroidTool = {
  name: "check_droid",
  description: "Check the status and output of a previously spawned droid. Returns status, output summary, and file listing.",
  agents: ["chora", "subrosa", "thaum", "praxis", "mux", "primus"],
  parameters: {
    type: "object",
    properties: {
      droid_id: {
        type: "string",
        description: 'The droid ID returned by spawn_droid (e.g., "droid-a1b2c3d4")'
      }
    },
    required: ["droid_id"]
  },
  execute: async (params) => {
    const droidId = params.droid_id;
    const droidIdRegex = /^droid-[0-9a-f]{8}$/;
    if (!droidIdRegex.test(droidId)) {
      return { error: 'Invalid droid ID format. Expected "droid-<8-hex-chars>".' };
    }
    const [session] = await sql`
            SELECT id, status, result, error, completed_at
            FROM ops_agent_sessions
            WHERE source = 'droid' AND source_id = ${droidId}
            ORDER BY created_at DESC
            LIMIT 1
        `;
    if (!session) {
      return { error: `No droid found with ID: ${droidId}` };
    }
    const droidDir = `/workspace/droids/${droidId}`;
    const lsResult = await execInToolbox(`ls -la '${droidDir}/' 2>/dev/null || echo "(empty)"`, 5e3);
    let outputContent = null;
    const outputPath = session.result?.output_path;
    if (outputPath && session.status === "succeeded") {
      const safePath = outputPath.replace(/\.\./g, "").replace(/\/+/g, "/").replace(/^\//, "");
      if (safePath.startsWith("droids/") && !safePath.includes("..") && !safePath.includes("//")) {
        const readResult = await execInToolbox(
          `cat '/workspace/${safePath}' 2>/dev/null | head -c 5000`,
          5e3
        );
        if (readResult.exitCode === 0 && readResult.stdout.trim()) {
          outputContent = readResult.stdout.trim();
        }
      }
    }
    return {
      droid_id: droidId,
      session_id: session.id,
      status: session.status,
      error: session.error,
      completed_at: session.completed_at,
      files: lsResult.stdout.trim(),
      output_preview: outputContent?.slice(0, 2e3) ?? null,
      output_path: outputPath ?? null
    };
  }
};

// src/lib/tools/tools/memory-search.ts
init_db();
init_logger();
var log22 = logger.child({ module: "memory-search" });
var OLLAMA_BASE_URL2 = process.env.OLLAMA_BASE_URL ?? "";
var EMBEDDING_MODEL2 = "bge-m3";
async function getEmbedding2(text2) {
  if (!OLLAMA_BASE_URL2) return null;
  try {
    const response = await fetch(`${OLLAMA_BASE_URL2}/v1/embeddings`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ model: EMBEDDING_MODEL2, input: text2 }),
      signal: AbortSignal.timeout(1e4)
    });
    if (!response.ok) return null;
    const data = await response.json();
    return data.data?.[0]?.embedding ?? null;
  } catch {
    return null;
  }
}
var memorySearchTool = {
  name: "memory_search",
  description: "Search agent memories using semantic similarity. Returns relevant memories from any agent.",
  agents: ["chora", "subrosa", "thaum", "praxis", "mux", "primus"],
  parameters: {
    type: "object",
    properties: {
      query: {
        type: "string",
        description: "What to search for in agent memories"
      },
      agent_id: {
        type: "string",
        description: "Filter to a specific agent (optional)"
      },
      limit: {
        type: "number",
        description: "Maximum results (default 10)"
      }
    },
    required: ["query"]
  },
  execute: async (params) => {
    const query = params.query;
    const agentId = params.agent_id;
    const limit = Math.min(params.limit || 10, 25);
    const embedding = await getEmbedding2(query);
    if (embedding) {
      try {
        const vectorStr = `[${embedding.join(",")}]`;
        const rows2 = await sql`
                    SELECT id, agent_id, type, content, confidence, tags, created_at,
                           1 - (embedding <=> ${vectorStr}::vector) as similarity
                    FROM ops_agent_memory
                    WHERE superseded_by IS NULL
                    ${agentId ? sql`AND agent_id = ${agentId}` : sql``}
                    AND embedding IS NOT NULL
                    ORDER BY embedding <=> ${vectorStr}::vector
                    LIMIT ${limit}
                `;
        return {
          results: rows2.map((r) => ({
            agent: r.agent_id,
            type: r.type,
            content: r.content,
            confidence: r.confidence,
            tags: r.tags,
            similarity: Math.round(r.similarity * 100) / 100,
            created_at: r.created_at
          })),
          method: "vector",
          count: rows2.length
        };
      } catch (err) {
        log22.warn("Vector search failed, falling back to text", { error: err });
      }
    }
    const rows = await sql`
            SELECT id, agent_id, type, content, confidence, tags, created_at
            FROM ops_agent_memory
            WHERE superseded_by IS NULL
            ${agentId ? sql`AND agent_id = ${agentId}` : sql``}
            AND content ILIKE ${"%" + query + "%"}
            ORDER BY created_at DESC
            LIMIT ${limit}
        `;
    return {
      results: rows.map((r) => ({
        agent: r.agent_id,
        type: r.type,
        content: r.content,
        confidence: r.confidence,
        tags: r.tags,
        created_at: r.created_at
      })),
      method: "text",
      count: rows.length
    };
  }
};

// src/lib/tools/tools/memory-write.ts
init_memory();
var VALID_MEMORY_TYPES2 = [
  "insight",
  "pattern",
  "strategy",
  "preference",
  "lesson"
];
function createMemoryWriteExecute(agentId) {
  return async (params) => {
    const type = params.type;
    const content = params.content;
    const confidence = params.confidence ?? 0.7;
    const tagsStr = params.tags ?? "";
    if (!VALID_MEMORY_TYPES2.includes(type)) {
      return {
        error: `Invalid type "${type}". Must be one of: ${VALID_MEMORY_TYPES2.join(", ")}`
      };
    }
    if (!content || content.trim().length === 0) {
      return { error: "Content cannot be empty" };
    }
    if (content.length > 200) {
      return {
        error: `Content too long (${content.length} chars). Max 200.`
      };
    }
    if (confidence < 0.4 || confidence > 1) {
      return { error: "Confidence must be between 0.4 and 1.0" };
    }
    const tags = tagsStr.split(",").map((t) => t.trim()).filter((t) => t.length > 0);
    const id = await writeMemory({
      agent_id: agentId,
      type,
      content: content.trim(),
      confidence,
      tags,
      source_trace_id: `self:${agentId}:${Date.now()}`
    });
    if (id) {
      await enforceMemoryCap(agentId);
      return { written: true, memory_id: id };
    }
    return {
      written: false,
      reason: "Duplicate or below confidence threshold"
    };
  };
}
var memoryWriteTool = {
  name: "memory_write",
  description: "Write a memory that will persist across all future sessions. Use when something important comes up that you want to remember long-term. Memories are typed (insight, pattern, strategy, preference, lesson) and tagged for retrieval.",
  agents: ["chora", "subrosa", "thaum", "praxis", "mux", "primus"],
  parameters: {
    type: "object",
    properties: {
      type: {
        type: "string",
        description: "Memory type: insight (observation), pattern (recurring theme), strategy (approach), preference (value/style), lesson (learned from experience)",
        enum: VALID_MEMORY_TYPES2
      },
      content: {
        type: "string",
        description: "What to remember. Max 200 characters. Be concise and specific."
      },
      confidence: {
        type: "number",
        description: "How confident you are (0.4-1.0). Higher = more certain."
      },
      tags: {
        type: "string",
        description: 'Comma-separated tags for retrieval (e.g. "governance,user,preference")'
      }
    },
    required: ["type", "content"]
  }
};

// src/lib/tools/tools/scratchpad.ts
init_scratchpad();
function createScratchpadReadExecute(agentId) {
  return async () => {
    const content = await getScratchpad(agentId);
    return {
      content: content || "(empty \u2014 write your first scratchpad entry)",
      length: content.length
    };
  };
}
function createScratchpadUpdateExecute(agentId) {
  return async (params) => {
    const content = params.content;
    if (!content || content.trim().length === 0) {
      return { error: "Content cannot be empty" };
    }
    return updateScratchpad(agentId, content);
  };
}
var scratchpadReadTool = {
  name: "scratchpad_read",
  description: "Read your working memory scratchpad. Returns your current notes, priorities, and context that persists between sessions.",
  agents: ["chora", "subrosa", "thaum", "praxis", "mux", "primus"],
  parameters: {
    type: "object",
    properties: {},
    required: []
  }
};
var scratchpadUpdateTool = {
  name: "scratchpad_update",
  description: "Update your working memory scratchpad. Use this to maintain notes, track priorities, record hypotheses, and keep context between sessions. Max 2000 characters. This REPLACES your entire scratchpad \u2014 include everything you want to keep.",
  agents: ["chora", "subrosa", "thaum", "praxis", "mux", "primus"],
  parameters: {
    type: "object",
    properties: {
      content: {
        type: "string",
        description: "Your full scratchpad content (markdown). Include current focus, active threads, hypotheses, and notes to self."
      }
    },
    required: ["content"]
  }
};

// src/lib/tools/tools/propose-policy-change.ts
init_governance();
init_logger();
var log23 = logger.child({ module: "propose-policy-change" });
function createProposePolicyChangeExecute(agentId) {
  return async (params) => {
    const policyKey = params.policy_key;
    const proposedValue = params.proposed_value;
    const rationale = params.rationale;
    try {
      const proposalId = await proposeGovernanceChange(
        agentId,
        policyKey,
        proposedValue,
        rationale
      );
      log23.info("Governance proposal created via tool", {
        proposalId,
        agentId,
        policyKey
      });
      return {
        success: true,
        proposal_id: proposalId,
        message: `Governance proposal created. A debate session will be scheduled with all agents to discuss this policy change. 4 out of 6 approvals required.`
      };
    } catch (err) {
      const error48 = err;
      log23.error("Failed to create governance proposal", {
        error: error48.message,
        agentId,
        policyKey
      });
      return {
        success: false,
        error: error48.message,
        message: `Failed to create proposal: ${error48.message}`
      };
    }
  };
}
var proposePolicyChangeTool = {
  name: "propose_policy_change",
  description: "Propose a change to a system policy. This will trigger a governance debate where all agents vote on the proposal. Requires 4/6 agent approval to pass.",
  agents: ["chora", "subrosa", "thaum", "praxis", "mux", "primus"],
  parameters: {
    type: "object",
    properties: {
      policy_key: {
        type: "string",
        description: 'The policy key to change (e.g., "auto_approve", "x_daily_quota", "content_policy"). Note: "system_enabled" is protected and cannot be changed.'
      },
      proposed_value: {
        type: "object",
        description: "The new value for the policy as a JSON object. Must match the expected structure for that policy."
      },
      rationale: {
        type: "string",
        description: "Clear explanation of why this policy change is needed and what problem it solves. This will be shared in the governance debate."
      }
    },
    required: ["policy_key", "proposed_value", "rationale"]
  },
  // Execute will be bound per-agent via createProposePolicyChangeExecute in registry
  execute: createProposePolicyChangeExecute("system")
};

// src/lib/tools/tools/propose-mission.ts
init_proposal_service();
init_logger();
var log24 = logger.child({ module: "propose-mission" });
function createProposeMissionExecute(agentId, sessionId) {
  return async (params) => {
    const title = params.title;
    const description = params.description ?? "";
    const steps = params.steps;
    if (!title || !steps || !Array.isArray(steps) || steps.length === 0) {
      return {
        success: false,
        error: "title and steps (non-empty array) are required"
      };
    }
    try {
      const result = await createProposalAndMaybeAutoApprove({
        agent_id: agentId,
        title,
        description,
        proposed_steps: steps.map((s) => ({
          kind: s.kind,
          payload: s.payload
        })),
        source: "agent",
        source_trace_id: sessionId
      });
      log24.info("Mission proposal created via tool", {
        proposalId: result.proposalId,
        missionId: result.missionId,
        agentId,
        autoApproved: !!result.missionId
      });
      if (result.missionId) {
        return {
          success: true,
          proposal_id: result.proposalId,
          mission_id: result.missionId,
          message: `Mission proposal auto-approved and mission created. Steps will be executed by the worker.`
        };
      }
      return {
        success: true,
        proposal_id: result.proposalId,
        message: `Mission proposal created and awaiting review. Step kinds not in the auto-approve list require manual approval.`
      };
    } catch (err) {
      const error48 = err;
      log24.error("Failed to create mission proposal", {
        error: error48.message,
        agentId,
        title
      });
      return {
        success: false,
        error: error48.message,
        message: `Failed to create proposal: ${error48.message}`
      };
    }
  };
}
var proposeMissionTool = {
  name: "propose_mission",
  description: "Propose a mission with concrete steps. Call at most once per session \u2014 consolidate multiple ideas into one mission with multiple steps. If all step kinds are auto-approvable, the mission executes immediately; otherwise it goes to review.",
  agents: [...ALL_AGENTS],
  parameters: {
    type: "object",
    properties: {
      title: {
        type: "string",
        description: 'A clear, actionable mission title (e.g., "Build diagnostic engine MVP")'
      },
      description: {
        type: "string",
        description: "Why this mission matters and what it accomplishes"
      },
      steps: {
        type: "array",
        description: "Concrete steps to execute. Each step has a kind and optional payload.",
        items: {
          type: "object",
          properties: {
            kind: {
              type: "string",
              description: "Step kind: research_topic, scan_signals, draft_essay, draft_thread, patch_code, audit_system, critique_content, distill_insight, document_lesson, consolidate_memory, memory_archaeology"
            },
            payload: {
              type: "object",
              description: 'Step-specific payload (e.g., { "topic": "..." } for research_topic, code change description for patch_code)'
            }
          },
          required: ["kind"]
        }
      }
    },
    required: ["title", "steps"]
  },
  // Execute will be bound per-agent via createProposeMissionExecute in registry
  execute: createProposeMissionExecute("system")
};

// src/lib/tools/tools/cast-veto.ts
init_veto();
init_logger();
var log25 = logger.child({ module: "cast-veto" });
function createCastVetoExecute(agentId) {
  return async (params) => {
    const targetType = params.target_type;
    const targetId = params.target_id;
    const reason = params.reason;
    try {
      const { vetoId, severity } = await castVeto(
        agentId,
        targetType,
        targetId,
        reason
      );
      log25.info("Veto cast via tool", {
        vetoId,
        agentId,
        targetType,
        targetId,
        severity
      });
      return {
        success: true,
        veto_id: vetoId,
        severity,
        message: severity === "binding" ? `Binding veto issued. The ${targetType} has been halted immediately.` : `Soft veto issued. The ${targetType} has been flagged for review.`
      };
    } catch (err) {
      const error48 = err;
      log25.error("Failed to cast veto", {
        error: error48.message,
        agentId,
        targetType,
        targetId
      });
      return {
        success: false,
        error: error48.message,
        message: `Failed to cast veto: ${error48.message}`
      };
    }
  };
}
var castVetoTool = {
  name: "cast_veto",
  description: "Cast a veto on a proposal, mission, governance change, or step. Subrosa casts binding vetoes (immediate halt). Other agents cast soft vetoes (flags for review). Use this when you believe an action should be stopped or reviewed before proceeding.",
  agents: ["chora", "subrosa", "thaum", "praxis", "mux", "primus"],
  parameters: {
    type: "object",
    properties: {
      target_type: {
        type: "string",
        enum: ["proposal", "mission", "governance", "step"],
        description: "The type of target to veto"
      },
      target_id: {
        type: "string",
        description: "The UUID of the target to veto"
      },
      reason: {
        type: "string",
        description: "Clear explanation of why this veto is being cast. Be specific about the concern."
      }
    },
    required: ["target_type", "target_id", "reason"]
  },
  execute: createCastVetoExecute("system")
};

// src/lib/tools/registry.ts
var ALL_TOOLS = [
  bashTool,
  webSearchTool,
  webFetchTool,
  fileReadTool,
  fileWriteTool,
  sendToAgentTool,
  spawnDroidTool,
  checkDroidTool,
  memorySearchTool,
  memoryWriteTool,
  scratchpadReadTool,
  scratchpadUpdateTool,
  proposePolicyChangeTool,
  proposeMissionTool,
  castVetoTool
];
function getAgentTools(agentId, sessionId) {
  return ALL_TOOLS.filter((tool) => tool.agents.includes(agentId)).map(({ agents: _agents, ...tool }) => {
    if (tool.name === "file_write") {
      return { ...tool, execute: createFileWriteExecute(agentId) };
    }
    if (tool.name === "propose_policy_change") {
      return {
        ...tool,
        execute: createProposePolicyChangeExecute(agentId)
      };
    }
    if (tool.name === "propose_mission") {
      return {
        ...tool,
        execute: createProposeMissionExecute(agentId, sessionId)
      };
    }
    if (tool.name === "cast_veto") {
      return {
        ...tool,
        execute: createCastVetoExecute(agentId)
      };
    }
    if (tool.name === "memory_write") {
      return { ...tool, execute: createMemoryWriteExecute(agentId) };
    }
    if (tool.name === "scratchpad_read") {
      return { ...tool, execute: createScratchpadReadExecute(agentId) };
    }
    if (tool.name === "scratchpad_update") {
      return { ...tool, execute: createScratchpadUpdateExecute(agentId) };
    }
    return tool;
  });
}
function getDroidTools(droidId) {
  const droidToolNames = ["file_read", "file_write", "bash", "web_search", "web_fetch"];
  return ALL_TOOLS.filter((tool) => droidToolNames.includes(tool.name)).map(({ agents: _agents, ...tool }) => {
    if (tool.name === "file_write") {
      return { ...tool, execute: createFileWriteExecute(droidId) };
    }
    return tool;
  });
}

// src/lib/tools/agent-session.ts
init_events2();
init_memory();
init_scratchpad();
init_situational_briefing();
init_prime_directive();
init_logger();
var log26 = logger.child({ module: "agent-session" });
function sanitizeSummary(text2) {
  return text2.replace(/<\/?[a-z_][a-z0-9_-]*(?:\s[^>]*)?\s*>/gi, "").replace(/\s{2,}/g, " ").trim();
}
function truncateToFirstSentences(text2, maxLen) {
  const clean = text2.replace(/<\/?[a-z_][a-z0-9_-]*(?:\s[^>]*)?\s*>/gi, "").replace(/^#+\s+.+$/gm, "").replace(/\n{2,}/g, "\n").trim();
  if (clean.length <= maxLen) return clean;
  const truncated = clean.slice(0, maxLen);
  const lastSentence = Math.max(
    truncated.lastIndexOf(". "),
    truncated.lastIndexOf(".\n"),
    truncated.lastIndexOf("? "),
    truncated.lastIndexOf("! ")
  );
  if (lastSentence > maxLen * 0.3) return truncated.slice(0, lastSentence + 1);
  return truncated + "...";
}
async function executeAgentSession(session) {
  const startTime = Date.now();
  const isDroid = session.agent_id.startsWith("droid-");
  const agentId = session.agent_id;
  const allToolCalls = [];
  let llmRounds = 0;
  const totalTokens = 0;
  const totalCost = 0;
  await sql`
        UPDATE ops_agent_sessions
        SET status = 'running', started_at = NOW()
        WHERE id = ${session.id}
    `;
  try {
    const voice = isDroid ? null : getVoice(agentId);
    const voiceName = isDroid ? session.agent_id : voice?.displayName ?? agentId;
    const tools = isDroid ? getDroidTools(session.agent_id) : getAgentTools(agentId, session.id);
    const memories = isDroid ? [] : await queryRelevantMemories(
      agentId,
      session.prompt,
      { relevantLimit: 5, recentLimit: 3 }
    );
    const scratchpad = isDroid ? "" : await getScratchpad(agentId);
    const briefing = isDroid ? "" : await buildBriefing(agentId);
    const recentSessions = isDroid ? [] : await sql`
            SELECT agent_id, prompt, result, completed_at
            FROM ops_agent_sessions
            WHERE source = 'cron'
            AND status = 'succeeded'
            AND completed_at > NOW() - INTERVAL '24 hours'
            AND id != ${session.id}
            ORDER BY completed_at DESC
            LIMIT 5
        `;
    let primeDirective = "";
    try {
      primeDirective = await loadPrimeDirective();
    } catch {
    }
    let systemPrompt = "";
    if (voice) {
      systemPrompt += `${voice.systemDirective}

`;
    }
    if (primeDirective) {
      systemPrompt += `\u2550\u2550\u2550 PRIME DIRECTIVE \u2550\u2550\u2550
${primeDirective}

`;
    }
    systemPrompt += `You are ${voiceName}, operating in an autonomous agent session.
`;
    systemPrompt += `You have tools available to accomplish your task. Use them through the provided function calling interface.
`;
    systemPrompt += `When your task is complete, provide a clear summary of what you accomplished.
`;
    systemPrompt += `IMPORTANT: Never output raw XML tags like <function_calls> or <invoke>. Use the structured tool calling API instead.

`;
    if (scratchpad) {
      systemPrompt += `\u2550\u2550\u2550 YOUR SCRATCHPAD (working memory) \u2550\u2550\u2550
${scratchpad}

`;
    }
    if (briefing) {
      systemPrompt += `\u2550\u2550\u2550 CURRENT SITUATION \u2550\u2550\u2550
${briefing}

`;
    }
    if (memories.length > 0) {
      systemPrompt += `\u2550\u2550\u2550 YOUR MEMORIES \u2550\u2550\u2550
`;
      for (const m of memories) {
        systemPrompt += `- [${m.type}] ${m.content.slice(0, 200)}
`;
      }
      systemPrompt += `
`;
    }
    if (recentSessions.length > 0) {
      systemPrompt += `Recent session outputs (for context):
`;
      for (const s of recentSessions) {
        const summary = s.result?.summary ?? s.result?.text ?? "(no summary)";
        systemPrompt += `- [${s.agent_id}] ${String(summary).slice(0, 300)}
`;
      }
      systemPrompt += "\n";
    }
    const messages = [
      { role: "system", content: systemPrompt },
      { role: "user", content: session.prompt }
    ];
    const maxRounds = session.max_tool_rounds;
    const timeoutMs = session.timeout_seconds * 1e3;
    let lastText = "";
    for (let round = 0; round < maxRounds; round++) {
      if (Date.now() - startTime > timeoutMs) {
        await completeSession(session.id, "timed_out", {
          summary: lastText || "Session timed out before completing",
          rounds: llmRounds
        }, allToolCalls, llmRounds, totalTokens, totalCost, "Timeout exceeded");
        return;
      }
      llmRounds++;
      const result = await llmGenerateWithTools({
        messages,
        temperature: 0.7,
        maxTokens: 2e3,
        model: session.model ?? void 0,
        tools: tools.length > 0 ? tools : void 0,
        maxToolRounds: 1,
        // We handle the outer loop ourselves
        trackingContext: {
          agentId,
          context: "agent_session",
          sessionId: session.id
        }
      });
      lastText = result.text;
      allToolCalls.push(...result.toolCalls);
      if (result.toolCalls.length === 0) {
        break;
      }
      const toolSummary = result.toolCalls.map((tc) => {
        const resultStr = typeof tc.result === "string" ? tc.result : JSON.stringify(tc.result);
        const capped = resultStr.length > 5e3 ? resultStr.slice(0, 5e3) + "... [truncated]" : resultStr;
        return `Tool ${tc.name}(${JSON.stringify(tc.arguments)}):
${capped}`;
      }).join("\n\n");
      if (result.text) {
        messages.push({ role: "assistant", content: result.text });
      }
      messages.push({
        role: "user",
        content: `Tool results:
${toolSummary}

Continue with your task. If you're done, provide a final summary.`
      });
    }
    const cleanedText = extractFromXml(lastText);
    await completeSession(session.id, "succeeded", {
      text: cleanedText,
      summary: sanitizeSummary(cleanedText),
      rounds: llmRounds
    }, allToolCalls, llmRounds, totalTokens, totalCost);
    const summaryPreview = truncateToFirstSentences(cleanedText, 200);
    await emitEvent({
      agent_id: agentId,
      kind: "agent_session_completed",
      title: `${voiceName} session completed`,
      summary: summaryPreview || void 0,
      tags: ["agent_session", "completed", session.source],
      metadata: {
        sessionId: session.id,
        source: session.source,
        rounds: llmRounds,
        toolCalls: allToolCalls.length
      }
    });
  } catch (err) {
    const errorMsg = err.message;
    log26.error("Agent session failed", {
      error: err,
      sessionId: session.id,
      agentId,
      rounds: llmRounds
    });
    await completeSession(session.id, "failed", {
      error: errorMsg,
      rounds: llmRounds
    }, allToolCalls, llmRounds, totalTokens, totalCost, errorMsg);
    await emitEvent({
      agent_id: agentId,
      kind: "agent_session_failed",
      title: `Agent session failed: ${errorMsg.slice(0, 100)}`,
      tags: ["agent_session", "failed", session.source],
      metadata: {
        sessionId: session.id,
        error: errorMsg,
        rounds: llmRounds
      }
    });
  }
}
async function completeSession(sessionId, status, result, toolCalls, llmRounds, totalTokens, costUsd, error48) {
  await sql`
        UPDATE ops_agent_sessions
        SET status = ${status},
            result = ${jsonb(result)},
            tool_calls = ${jsonb(toolCalls.map((tc) => ({
    name: tc.name,
    arguments: tc.arguments,
    result: typeof tc.result === "string" ? tc.result.slice(0, 2e3) : tc.result
  })))},
            llm_rounds = ${llmRounds},
            total_tokens = ${totalTokens},
            cost_usd = ${costUsd},
            error = ${error48 ?? null},
            completed_at = NOW()
        WHERE id = ${sessionId}
    `;
}

// scripts/unified-worker/index.ts
init_logger();
init_formats();
var log30 = createLogger({ service: "unified-worker" });
var WORKER_ID = `unified-${process.pid}`;
if (!process.env.DATABASE_URL) {
  log30.fatal("Missing DATABASE_URL");
  process.exit(1);
}
if (!process.env.OPENROUTER_API_KEY) {
  log30.fatal("Missing OPENROUTER_API_KEY");
  process.exit(1);
}
var sql2 = (0, import_postgres2.default)(process.env.DATABASE_URL, {
  max: 5,
  idle_timeout: 20,
  connect_timeout: 10
});
async function pollAgentSessions() {
  const [session] = await sql2`
        UPDATE ops_agent_sessions
        SET status = 'running', started_at = NOW()
        WHERE id = (
            SELECT id FROM ops_agent_sessions
            WHERE status = 'pending'
            ORDER BY created_at ASC
            LIMIT 1
            FOR UPDATE SKIP LOCKED
        )
        RETURNING *
    `;
  if (!session) return false;
  log30.info("Processing agent session", {
    sessionId: session.id,
    agent: session.agent_id,
    source: session.source
  });
  try {
    await executeAgentSession(session);
    if (session.source === "conversation" && session.source_id) {
      const [completed] = await sql2`
                SELECT result FROM ops_agent_sessions WHERE id = ${session.id}
            `;
      const artifactText = (completed?.result?.text ?? completed?.result?.output ?? "").trim();
      if (artifactText && artifactText.length > 20) {
        try {
          const { postArtifactToDiscord: postArtifactToDiscord2 } = await Promise.resolve().then(() => (init_roundtable(), roundtable_exports));
          await postArtifactToDiscord2(
            session.source_id,
            "",
            artifactText
          );
        } catch {
        }
      }
      if (artifactText && artifactText.length > 50) {
        try {
          const [rtSession] = await sql2`
                        SELECT format, topic FROM ops_roundtable_sessions
                        WHERE id = ${session.source_id}
                    `;
          if (rtSession) {
            const { extractActionsFromArtifact: extractActionsFromArtifact2 } = await Promise.resolve().then(() => (init_action_extractor(), action_extractor_exports));
            const actionCount = await extractActionsFromArtifact2(
              session.source_id,
              rtSession.format,
              artifactText,
              rtSession.topic
            );
            if (actionCount > 0) {
              log30.info("Actions extracted from roundtable artifact", {
                sessionId: session.id,
                roundtableId: session.source_id,
                format: rtSession.format,
                actionCount
              });
            }
          }
        } catch (extractErr) {
          log30.error("Action extraction failed (non-fatal)", {
            error: extractErr,
            sessionId: session.id
          });
        }
      }
      if (artifactText && artifactText.length > 50 && session.source_id) {
        try {
          const [rtSession] = await sql2`
                        SELECT format, topic FROM ops_roundtable_sessions
                        WHERE id = ${session.source_id}
                    `;
          if (rtSession) {
            const formatConfig = FORMATS[rtSession.format];
            const artifact = formatConfig?.artifact;
            if (artifact && artifact.type !== "none") {
              const outputDir = artifact.outputDir;
              const dateStr = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
              const topicSlug = rtSession.topic.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "").slice(0, 40);
              const filename = `${dateStr}__${rtSession.format}__${artifact.type}__${topicSlug}__${session.agent_id}__v01.md`;
              const filePath = import_path.default.join("/workspace", outputDir, filename);
              await import_promises.default.mkdir(import_path.default.dirname(filePath), { recursive: true });
              const fileExists = await import_promises.default.access(filePath).then(() => true, () => false);
              if (fileExists) {
                log30.info("Artifact file already exists (written by synthesis agent)", {
                  sessionId: session.id,
                  path: filePath
                });
              } else {
                await import_promises.default.writeFile(filePath, artifactText, "utf-8");
                log30.info("Artifact file written to workspace", {
                  sessionId: session.id,
                  path: filePath,
                  format: rtSession.format,
                  artifactType: artifact.type
                });
              }
            }
          }
        } catch (fileErr) {
          log30.error("Artifact file write failed (non-fatal)", {
            error: fileErr,
            sessionId: session.id
          });
        }
      }
      if (artifactText && artifactText.length > 50 && session.source_id) {
        try {
          const [existingDraft] = await sql2`
                        SELECT id FROM ops_content_drafts
                        WHERE source_session_id = ${session.source_id}
                        LIMIT 1
                    `;
          if (!existingDraft) {
            const [rtSession] = await sql2`
                            SELECT format, topic FROM ops_roundtable_sessions
                            WHERE id = ${session.source_id}
                        `;
            if (rtSession && rtSession.format !== "content_review") {
              const formatConfig = FORMATS[rtSession.format];
              const artifact = formatConfig?.artifact;
              const contentType = artifact?.type && artifact.type !== "none" ? artifact.type : "report";
              const headingMatch = artifactText.match(/^#\s+(.+)$/m);
              const title = headingMatch?.[1]?.trim() || `${contentType.charAt(0).toUpperCase() + contentType.slice(1)}: ${rtSession.topic.slice(0, 100)}`;
              const [draft] = await sql2`
                                INSERT INTO ops_content_drafts (
                                    author_agent, content_type, title, body, status,
                                    source_session_id, metadata
                                ) VALUES (
                                    ${session.agent_id},
                                    ${contentType},
                                    ${title.slice(0, 500)},
                                    ${artifactText.slice(0, 5e4)},
                                    'draft',
                                    ${session.source_id},
                                    ${sql2.json({
                format: rtSession.format,
                topic: rtSession.topic,
                artifactType: contentType,
                synthesisSessionId: session.id
              })}
                                )
                                RETURNING id
                            `;
              log30.info("Content draft created from synthesis", {
                draftId: draft.id,
                sessionId: session.id,
                roundtableId: session.source_id,
                contentType,
                author: session.agent_id
              });
              try {
                const { emitEvent: emitEvent2 } = await Promise.resolve().then(() => (init_events2(), events_exports2));
                await emitEvent2({
                  agent_id: session.agent_id,
                  kind: "content_draft_created",
                  title: `Content draft created: ${title.slice(0, 100)}`,
                  summary: `${contentType} by ${session.agent_id} from ${rtSession.format} synthesis`,
                  tags: ["content", "draft", contentType],
                  metadata: {
                    draftId: draft.id,
                    sessionId: session.source_id,
                    contentType
                  }
                });
              } catch {
              }
            }
          }
        } catch (draftErr) {
          log30.error("Content draft creation failed (non-fatal)", {
            error: draftErr,
            sessionId: session.id
          });
        }
      }
    }
  } catch (err) {
    log30.error("Agent session execution failed", {
      error: err,
      sessionId: session.id
    });
    await sql2`
            UPDATE ops_agent_sessions
            SET status = 'failed',
                error = ${err.message},
                completed_at = NOW()
            WHERE id = ${session.id}
        `;
  }
  return true;
}
async function pollRoundtables() {
  const rows = await sql2`
        UPDATE ops_roundtable_sessions
        SET status = 'running'
        WHERE id = (
            SELECT id FROM ops_roundtable_sessions
            WHERE status = 'pending'
            AND scheduled_for <= NOW()
            ORDER BY
                CASE WHEN source = 'user_question' THEN 0 ELSE 1 END,
                created_at ASC
            LIMIT 1
            FOR UPDATE SKIP LOCKED
        )
        RETURNING *
    `;
  const session = rows[0];
  if (!session) return false;
  await sql2`
        UPDATE ops_roundtable_sessions
        SET status = 'pending'
        WHERE id = ${session.id}
    `;
  log30.info("Processing roundtable", {
    sessionId: session.id,
    format: session.format,
    topic: session.topic.slice(0, 80)
  });
  try {
    await orchestrateConversation(session, true);
    const proposalId = session.metadata?.governance_proposal_id;
    if (session.format === "debate" && proposalId) {
      try {
        const { castGovernanceVote: castGovernanceVote2 } = await Promise.resolve().then(() => (init_governance(), governance_exports));
        const { llmGenerate: llmGenerate2 } = await Promise.resolve().then(() => (init_client(), client_exports));
        const turns = await sql2`
                    SELECT agent_id, dialogue FROM ops_roundtable_turns
                    WHERE session_id = ${session.id}
                    ORDER BY turn_number ASC
                `;
        if (turns.length > 0) {
          const transcript = turns.map((t) => `${t.agent_id}: ${t.dialogue}`).join("\n\n");
          const parseResult = await llmGenerate2({
            messages: [
              {
                role: "system",
                content: `You extract each participant's final position from a governance debate. Return ONLY valid JSON \u2014 an array of objects, one per unique participant. Each object: { "agent": "<agent_id>", "vote": "approve" | "reject", "reason": "<1-sentence summary>" }`
              },
              {
                role: "user",
                content: `Extract the final position of each participant in this debate:

${transcript}`
              }
            ],
            temperature: 0.2,
            maxTokens: 800,
            trackingContext: {
              agentId: "system",
              context: "governance-vote-extraction"
            }
          });
          const jsonMatch = parseResult.match(/\[[\s\S]*\]/);
          if (jsonMatch) {
            const votes = JSON.parse(jsonMatch[0]);
            for (const v of votes) {
              if (v.agent && (v.vote === "approve" || v.vote === "reject")) {
                await castGovernanceVote2(
                  proposalId,
                  v.agent,
                  v.vote,
                  v.reason ?? ""
                );
              }
            }
            log30.info("Governance votes extracted from debate", {
              sessionId: session.id,
              proposalId,
              voteCount: votes.length
            });
          }
        }
      } catch (govErr) {
        log30.error("Governance vote extraction failed (non-fatal)", {
          error: govErr,
          sessionId: session.id,
          proposalId
        });
      }
    }
    const rebellionAgentId = session.metadata?.rebellion_agent_id;
    if (session.format === "cross_exam" && rebellionAgentId) {
      try {
        const { endRebellion: endRebellion2, isAgentRebelling: isAgentRebelling2 } = await Promise.resolve().then(() => (init_rebellion(), rebellion_exports));
        const stillRebelling = await isAgentRebelling2(rebellionAgentId);
        if (stillRebelling) {
          await endRebellion2(
            rebellionAgentId,
            "cross_exam_completed"
          );
          log30.info("Rebellion resolved via cross-exam", {
            sessionId: session.id,
            rebellionAgentId
          });
        }
      } catch (rebellionErr) {
        log30.error(
          "Rebellion resolution from cross-exam failed (non-fatal)",
          {
            error: rebellionErr,
            sessionId: session.id,
            rebellionAgentId
          }
        );
      }
    }
  } catch (err) {
    log30.error("Roundtable orchestration failed", {
      error: err,
      sessionId: session.id
    });
  }
  return true;
}
async function pollMissionSteps() {
  const [step] = await sql2`
        UPDATE ops_mission_steps
        SET status = 'running',
            reserved_by = ${WORKER_ID},
            started_at = NOW(),
            updated_at = NOW()
        WHERE id = (
            SELECT s.id FROM ops_mission_steps s
            WHERE s.status = 'queued'
            AND NOT EXISTS (
                SELECT 1 FROM ops_mission_steps dep
                WHERE dep.id = ANY(s.depends_on)
                AND dep.status != 'succeeded'
            )
            ORDER BY s.created_at ASC
            LIMIT 1
            FOR UPDATE SKIP LOCKED
        )
        RETURNING *
    `;
  if (!step) return false;
  log30.info("Processing mission step", {
    stepId: step.id,
    kind: step.kind,
    missionId: step.mission_id
  });
  try {
    const { hasActiveVeto: hasActiveVeto2 } = await Promise.resolve().then(() => (init_veto(), veto_exports));
    const missionVeto = await hasActiveVeto2("mission", step.mission_id);
    if (missionVeto.vetoed) {
      log30.info("Mission step blocked by veto on mission", {
        stepId: step.id,
        missionId: step.mission_id,
        vetoId: missionVeto.vetoId,
        severity: missionVeto.severity
      });
      await sql2`
                UPDATE ops_mission_steps
                SET status = 'failed',
                    failure_reason = ${`Blocked by ${missionVeto.severity} veto on mission: ${missionVeto.reason}`},
                    completed_at = NOW(),
                    updated_at = NOW()
                WHERE id = ${step.id}
            `;
      await finalizeMissionIfComplete(step.mission_id);
      return true;
    }
    const stepVeto = await hasActiveVeto2("step", step.id);
    if (stepVeto.vetoed) {
      log30.info("Mission step blocked by veto on step", {
        stepId: step.id,
        vetoId: stepVeto.vetoId,
        severity: stepVeto.severity
      });
      await sql2`
                UPDATE ops_mission_steps
                SET status = 'failed',
                    failure_reason = ${`Blocked by ${stepVeto.severity} veto on step: ${stepVeto.reason}`},
                    completed_at = NOW(),
                    updated_at = NOW()
                WHERE id = ${step.id}
            `;
      await finalizeMissionIfComplete(step.mission_id);
      return true;
    }
  } catch (vetoErr) {
    log30.error("Veto check failed (non-fatal, allowing step)", {
      error: vetoErr,
      stepId: step.id
    });
  }
  try {
    const [mission] = await sql2`
            SELECT title, created_by FROM ops_missions WHERE id = ${step.mission_id}
        `;
    const agentId = step.assigned_agent ?? mission?.created_by ?? "mux";
    const { emitEvent: emitEvent2 } = await Promise.resolve().then(() => (init_events2(), events_exports2));
    if (step.kind === "memory_archaeology") {
      const { performDig: performDig2 } = await Promise.resolve().then(() => (init_memory_archaeology(), memory_archaeology_exports));
      const result = await performDig2({
        agent_id: agentId,
        max_memories: 100
      });
      await sql2`
                UPDATE ops_mission_steps
                SET status = 'succeeded',
                    result = ${sql2.json({
        dig_id: result.dig_id,
        finding_count: result.findings.length,
        memories_analyzed: result.memories_analyzed
      })}::jsonb,
                    completed_at = NOW(),
                    updated_at = NOW()
                WHERE id = ${step.id}
            `;
      await emitEvent2({
        agent_id: agentId,
        kind: "archaeology_complete",
        title: `Memory archaeology dig completed \u2014 ${result.findings.length} findings`,
        tags: ["archaeology", "memory", "complete"],
        metadata: {
          dig_id: result.dig_id,
          finding_count: result.findings.length,
          memories_analyzed: result.memories_analyzed,
          missionId: step.mission_id,
          stepId: step.id
        }
      });
      await finalizeMissionIfComplete(step.mission_id);
      return true;
    }
    const { buildStepPrompt: buildStepPrompt2 } = await Promise.resolve().then(() => (init_step_prompts(), step_prompts_exports));
    const { prompt, templateVersion } = await buildStepPrompt2(
      step.kind,
      {
        missionTitle: mission?.title ?? "Unknown",
        agentId,
        payload: step.payload ?? {},
        outputPath: step.output_path ?? void 0
      },
      { withVersion: true }
    );
    if (templateVersion != null) {
      await sql2`
                UPDATE ops_mission_steps
                SET template_version = ${templateVersion}
                WHERE id = ${step.id}
            `;
    }
    if (step.output_path) {
      const outputPrefix = step.output_path.endsWith("/") ? step.output_path : step.output_path + "/";
      try {
        await sql2`
                    INSERT INTO ops_acl_grants (agent_id, path_prefix, source, source_id, expires_at)
                    VALUES (${agentId}, ${outputPrefix}, 'mission', ${step.mission_id}::uuid, NOW() + INTERVAL '4 hours')
                `;
      } catch (grantErr) {
        log30.warn("Failed to create ACL grant for step", {
          error: grantErr,
          agentId,
          outputPath: step.output_path
        });
      }
    }
    const [session] = await sql2`
            INSERT INTO ops_agent_sessions (
                agent_id, prompt, source, source_id,
                timeout_seconds, max_tool_rounds, status
            ) VALUES (
                ${agentId},
                ${prompt},
                'mission',
                ${step.mission_id},
                300,
                10,
                'pending'
            )
            RETURNING id
        `;
    await sql2`
            UPDATE ops_mission_steps
            SET result = ${sql2.json({ agent_session_id: session.id, agent: agentId })}::jsonb,
                updated_at = NOW()
            WHERE id = ${step.id}
        `;
    await emitEvent2({
      agent_id: agentId,
      kind: "step_dispatched",
      title: `Step dispatched to agent session: ${step.kind}`,
      tags: ["mission", "step", "dispatched"],
      metadata: {
        missionId: step.mission_id,
        stepId: step.id,
        kind: step.kind,
        agentSessionId: session.id
      }
    });
  } catch (err) {
    log30.error("Mission step failed", { error: err, stepId: step.id });
    const stepData = await sql2`
            SELECT result FROM ops_mission_steps WHERE id = ${step.id}
        `;
    const agentSessionId = stepData[0]?.result?.agent_session_id;
    await sql2`
            UPDATE ops_mission_steps
            SET status = 'failed',
                failure_reason = ${err.message},
                completed_at = NOW(),
                updated_at = NOW()
            WHERE id = ${step.id}
        `;
    if (agentSessionId) {
      await sql2`
                UPDATE ops_agent_sessions
                SET status = 'failed',
                    error = ${err.message},
                    completed_at = NOW()
                WHERE id = ${agentSessionId}
                  AND status = 'pending'
            `;
    }
    await finalizeMissionIfComplete(step.mission_id);
  }
  return true;
}
async function finalizeMissionSteps() {
  const steps = await sql2`
        SELECT
            s.id,
            s.mission_id,
            sess.status as session_status,
            sess.error as session_error
        FROM ops_mission_steps s
        LEFT JOIN ops_agent_sessions sess ON sess.id = (s.result->>'agent_session_id')::uuid
        WHERE s.status = 'running'
        AND s.result->>'agent_session_id' IS NOT NULL
    `;
  if (steps.length === 0) return false;
  let finalized = 0;
  for (const step of steps) {
    if (!step.session_status) continue;
    if (step.session_status === "succeeded") {
      await sql2`
                UPDATE ops_mission_steps
                SET status = 'succeeded',
                    completed_at = NOW(),
                    updated_at = NOW()
                WHERE id = ${step.id}
            `;
      finalized++;
      await finalizeMissionIfComplete(step.mission_id);
    } else if (step.session_status === "failed") {
      await sql2`
                UPDATE ops_mission_steps
                SET status = 'failed',
                    failure_reason = ${step.session_error ?? "Agent session failed"},
                    completed_at = NOW(),
                    updated_at = NOW()
                WHERE id = ${step.id}
            `;
      finalized++;
      await finalizeMissionIfComplete(step.mission_id);
    }
  }
  return finalized > 0;
}
async function pollInitiatives() {
  const [entry] = await sql2`
        UPDATE ops_initiative_queue
        SET status = 'processing'
        WHERE id = (
            SELECT id FROM ops_initiative_queue
            WHERE status = 'pending'
            ORDER BY created_at ASC
            LIMIT 1
            FOR UPDATE SKIP LOCKED
        )
        RETURNING *
    `;
  if (!entry) return false;
  log30.info("Processing initiative", {
    entryId: entry.id,
    agent: entry.agent_id
  });
  try {
    const initiativeAction = entry.context?.action;
    if (initiativeAction === "agent_design_proposal") {
      log30.info("Processing agent design proposal", {
        entryId: entry.id,
        agent: entry.agent_id
      });
      const { generateAgentProposal: generateAgentProposal2 } = await Promise.resolve().then(() => (init_agent_designer(), agent_designer_exports));
      const proposal = await generateAgentProposal2(entry.agent_id);
      await sql2`
                UPDATE ops_initiative_queue
                SET status = 'completed',
                    processed_at = NOW(),
                    result = ${sql2.json({
        type: "agent_design_proposal",
        proposalId: proposal.id,
        agentName: proposal.agent_name
      })}::jsonb
                WHERE id = ${entry.id}
            `;
      return true;
    }
    if (initiativeAction === "memory_archaeology") {
      log30.info("Processing memory archaeology dig", {
        entryId: entry.id,
        agent: entry.agent_id
      });
      const { performDig: performDig2 } = await Promise.resolve().then(() => (init_memory_archaeology(), memory_archaeology_exports));
      const maxMemories = entry.context?.max_memories ?? 100;
      const agentRows = await sql2`
                SELECT DISTINCT agent_id FROM ops_agent_memory
                WHERE superseded_by IS NULL
                ORDER BY agent_id
            `;
      const agentIds = agentRows.map((r) => r.agent_id);
      const weekNumber = Math.floor(Date.now() / (7 * 864e5));
      const targetAgent = agentIds.length > 0 ? agentIds[weekNumber % agentIds.length] : entry.agent_id;
      const result2 = await performDig2({
        agent_id: targetAgent,
        max_memories: maxMemories
      });
      await sql2`
                UPDATE ops_initiative_queue
                SET status = 'completed',
                    processed_at = NOW(),
                    result = ${sql2.json({
        type: "memory_archaeology",
        dig_id: result2.dig_id,
        finding_count: result2.findings.length,
        memories_analyzed: result2.memories_analyzed,
        target_agent: targetAgent
      })}::jsonb
                WHERE id = ${entry.id}
            `;
      return true;
    }
    const { llmGenerate: llmGenerate2 } = await Promise.resolve().then(() => (init_client(), client_exports));
    const { getVoice: getVoice2 } = await Promise.resolve().then(() => (init_voices(), voices_exports));
    const voice = getVoice2(entry.agent_id);
    const memories = entry.context?.memories ?? [];
    const systemPrompt = voice ? `${voice.systemDirective}

You are generating a mission proposal based on your accumulated knowledge and observations.` : `You are ${entry.agent_id}. Generate a mission proposal.`;
    let memoryContext = "";
    if (Array.isArray(memories) && memories.length > 0) {
      memoryContext = "\n\nYour recent memories:\n" + memories.slice(0, 10).map((m) => `- [${m.type}] ${m.content}`).join("\n");
    }
    const userPrompt = `Based on your role, personality, and accumulated experience, propose a mission.${memoryContext}

Respond with:
1. A clear mission title
2. A brief description of why this matters
3. 2-4 concrete steps to accomplish it

Valid step kinds (you MUST use only these exact strings):
- research_topic: Research a topic using web search
- scan_signals: Scan for signals and trends
- draft_essay: Write a long-form piece
- draft_thread: Write a short thread/post
- patch_code: Make code changes to the project
- audit_system: Run system checks and audits
- critique_content: Review and critique content
- distill_insight: Synthesize insights from recent work
- document_lesson: Document knowledge or lessons
- consolidate_memory: Consolidate and organize memories

Format as JSON: { "title": "...", "description": "...", "steps": [{ "kind": "<valid_step_kind>", "payload": { "topic": "..." } }] }`;
    const result = await llmGenerate2({
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt }
      ],
      temperature: 0.8,
      maxTokens: 1e3,
      trackingContext: {
        agentId: entry.agent_id,
        context: "initiative"
      }
    });
    let parsed;
    try {
      const jsonMatch = result.match(/\{[\s\S]*\}/);
      parsed = jsonMatch ? JSON.parse(jsonMatch[0]) : null;
    } catch {
      parsed = null;
    }
    if (parsed?.title) {
      const { createProposalAndMaybeAutoApprove: createProposalAndMaybeAutoApprove2 } = await Promise.resolve().then(() => (init_proposal_service(), proposal_service_exports));
      await createProposalAndMaybeAutoApprove2({
        agent_id: entry.agent_id,
        title: parsed.title,
        description: parsed.description ?? "",
        proposed_steps: parsed.steps ?? [],
        source: "initiative"
      });
    }
    await sql2`
            UPDATE ops_initiative_queue
            SET status = 'completed',
                processed_at = NOW(),
                result = ${sql2.json({ text: result, parsed })}::jsonb
            WHERE id = ${entry.id}
        `;
  } catch (err) {
    log30.error("Initiative processing failed", {
      error: err,
      entryId: entry.id
    });
    await sql2`
            UPDATE ops_initiative_queue
            SET status = 'failed',
                processed_at = NOW(),
                result = ${sql2.json({ error: err.message })}::jsonb
            WHERE id = ${entry.id}
        `;
  }
  return true;
}
async function finalizeMissionIfComplete(missionId) {
  const [counts] = await sql2`
        SELECT
            COUNT(*)::int as total,
            COUNT(*) FILTER (WHERE status = 'succeeded')::int as succeeded,
            COUNT(*) FILTER (WHERE status = 'failed')::int as failed
        FROM ops_mission_steps
        WHERE mission_id = ${missionId}
    `;
  if (!counts || counts.total === 0) return;
  const allDone = counts.succeeded + counts.failed === counts.total;
  if (!allDone) return;
  const finalStatus = counts.failed > 0 ? "failed" : "succeeded";
  const failReason = counts.failed > 0 ? `${counts.failed} of ${counts.total} steps failed` : null;
  await sql2`
        UPDATE ops_missions
        SET status = ${finalStatus},
            failure_reason = ${failReason},
            completed_at = NOW(),
            updated_at = NOW()
        WHERE id = ${missionId}
        AND status = 'running'
    `;
}
var running = true;
async function pollLoop() {
  while (running) {
    try {
      await pollRoundtables();
      const hadSession = await pollAgentSessions();
      if (hadSession) continue;
      await pollMissionSteps();
      await finalizeMissionSteps();
      await pollInitiatives();
    } catch (err) {
      log30.error("Poll loop error", { error: err });
    }
    await new Promise((resolve) => setTimeout(resolve, 15e3));
  }
}
function shutdown(signal) {
  log30.info(`Received ${signal}, shutting down...`);
  running = false;
  setTimeout(() => {
    log30.warn("Forced shutdown after 30s timeout");
    process.exit(1);
  }, 3e4);
}
process.on("SIGTERM", () => shutdown("SIGTERM"));
process.on("SIGINT", () => shutdown("SIGINT"));
log30.info("Unified worker started", {
  workerId: WORKER_ID,
  database: !!process.env.DATABASE_URL,
  openrouter: !!process.env.OPENROUTER_API_KEY,
  ollama: process.env.OLLAMA_BASE_URL || "disabled",
  braveSearch: !!process.env.BRAVE_API_KEY
});
pollLoop().then(() => {
  log30.info("Worker stopped");
  process.exit(0);
}).catch((err) => {
  log30.fatal("Fatal error", { error: err });
  process.exit(1);
});
//# sourceMappingURL=index.js.map
