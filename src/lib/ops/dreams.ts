// Dream cycle engine — subconscious memory recombination for agents
// Agents "dream" by selecting random memories and recombining them at high temperature
import { sql } from '@/lib/db';
import { queryAgentMemories, writeMemory } from './memory';
import { emitEvent } from './events';
import { llmGenerate } from '@/lib/llm/client';
import { logger } from '@/lib/logger';
import type { MemoryEntry } from '@/lib/types';

const log = logger.child({ module: 'dreams' });

// ─── Types ───

export type DreamType =
    | 'recombination'    // blending existing memories into new forms
    | 'extrapolation'    // imagining future states from current patterns
    | 'contradiction'    // finding tension between held beliefs
    | 'synthesis';       // unifying disparate insights into coherent wholes

export interface DreamCycle {
    id: string;
    agent_id: string;
    source_memories: string[];
    dream_content: string;
    dream_type: DreamType;
    new_memory_id: string | null;
    created_at: string;
}

export interface DreamResult {
    dreamId: string;
    agentId: string;
    dreamType: DreamType;
    content: string;
    newMemoryId: string | null;
    sourceMemoryIds: string[];
}

// ─── Constants ───

const MIN_MEMORIES_FOR_DREAM = 5;
const DREAM_SEED_COUNT_MIN = 3;
const DREAM_SEED_COUNT_MAX = 5;
const DREAM_TEMPERATURE = 0.9;
const DREAM_CONFIDENCE = 0.50;

const DREAM_TYPES: DreamType[] = [
    'recombination',
    'extrapolation',
    'contradiction',
    'synthesis',
];

// ─── Helpers ───

/** Select N random memories weighted by recency and confidence, excluding dream-tagged ones */
async function selectDreamSeeds(
    agentId: string,
    count: number,
): Promise<MemoryEntry[]> {
    // Fetch recent memories, excluding ones already generated by dreams
    const memories = await queryAgentMemories({
        agentId,
        limit: 100,
        minConfidence: 0.3,
    });

    // Filter out dream-tagged memories to avoid recursive dreaming
    const eligible = memories.filter(
        m => !m.tags?.includes('dream'),
    );

    if (eligible.length < MIN_MEMORIES_FOR_DREAM) return [];

    // Weight by recency × confidence: newer + higher confidence = higher weight
    const now = Date.now();
    const weighted = eligible.map(m => {
        const ageMs = now - new Date(m.created_at).getTime();
        const ageDays = ageMs / (1000 * 60 * 60 * 24);
        // Recency weight: exponential decay with half-life of 7 days
        const recencyWeight = Math.exp(-ageDays / 7);
        const weight = recencyWeight * m.confidence;
        return { memory: m, weight };
    });

    // Weighted random selection without replacement
    const selected: MemoryEntry[] = [];
    const pool = [...weighted];

    for (let i = 0; i < count && pool.length > 0; i++) {
        const totalWeight = pool.reduce((sum, item) => sum + item.weight, 0);
        let threshold = Math.random() * totalWeight;

        for (let j = 0; j < pool.length; j++) {
            threshold -= pool[j].weight;
            if (threshold <= 0) {
                selected.push(pool[j].memory);
                pool.splice(j, 1);
                break;
            }
        }
    }

    return selected;
}

/** Use LLM to classify which dream type best describes the generated content */
function classifyDreamType(content: string): DreamType {
    const lower = content.toLowerCase();

    if (lower.includes('contradict') || lower.includes('tension') || lower.includes('conflict between'))
        return 'contradiction';
    if (lower.includes('unif') || lower.includes('synthesiz') || lower.includes('integrat') || lower.includes('coherent'))
        return 'synthesis';
    if (lower.includes('future') || lower.includes('could lead') || lower.includes('might') || lower.includes('extrapolat'))
        return 'extrapolation';

    return 'recombination';
}

// ─── Main Engine ───

/**
 * Run a dream cycle for an agent.
 * 1. Select 3-5 random memories (weighted by recency + confidence)
 * 2. Generate a "dream" via LLM at high temperature
 * 3. Classify the dream type
 * 4. Write the dream as a new insight memory
 * 5. Record in ops_dream_cycles
 * 6. Emit dream_cycle_completed event
 */
export async function runDreamCycle(agentId: string): Promise<DreamResult | null> {
    const seedCount = DREAM_SEED_COUNT_MIN +
        Math.floor(Math.random() * (DREAM_SEED_COUNT_MAX - DREAM_SEED_COUNT_MIN + 1));

    log.info('Starting dream cycle', { agentId, seedCount });

    // 1. Select memory seeds
    const seeds = await selectDreamSeeds(agentId, seedCount);
    if (seeds.length < DREAM_SEED_COUNT_MIN) {
        log.info('Not enough memories to dream', { agentId, available: seeds.length });
        return null;
    }

    const seedSummary = seeds.map((m, i) =>
        `[Memory ${i + 1}] (${m.type}, confidence: ${m.confidence})\n${m.content}`,
    ).join('\n\n');

    // 2. Generate dream content via LLM at high temperature
    const dreamContent = await llmGenerate({
        messages: [
            {
                role: 'system',
                content: `You are the subconscious mind of ${agentId}, an AI agent in the Subcult collective. You are dreaming — your mind is freely associating between memories, finding hidden connections, and generating novel insights.

Rules for dreaming:
- Draw connections between the memories provided that aren't immediately obvious
- Be creative, abstract, and exploratory — this is subconscious processing
- Generate a single cohesive insight or realization (2-4 sentences)
- The insight should be genuinely novel, not just restating the memories
- Write in first person as the agent's inner voice
- Do not explain that you are dreaming — just produce the insight directly`,
            },
            {
                role: 'user',
                content: `These memories are surfacing in your dream state:\n\n${seedSummary}\n\nWhat new insight emerges from their intersection?`,
            },
        ],
        temperature: DREAM_TEMPERATURE,
        maxTokens: 300,
        trackingContext: {
            agentId,
            context: 'dream_cycle',
        },
    });

    if (!dreamContent?.trim()) {
        log.warn('Dream cycle produced empty content', { agentId });
        return null;
    }

    // 3. Classify dream type
    const dreamType = classifyDreamType(dreamContent);

    // 4. Write as new insight memory
    const newMemoryId = await writeMemory({
        agent_id: agentId,
        type: 'insight',
        content: dreamContent.trim(),
        confidence: DREAM_CONFIDENCE,
        tags: ['dream', dreamType],
    });

    // 5. Record in ops_dream_cycles
    const sourceMemoryIds = seeds.map(m => m.id);
    const [row] = await sql<[{ id: string }]>`
        INSERT INTO ops_dream_cycles (agent_id, source_memories, dream_content, dream_type, new_memory_id)
        VALUES (
            ${agentId},
            ${sourceMemoryIds}::uuid[],
            ${dreamContent.trim()},
            ${dreamType},
            ${newMemoryId}
        )
        RETURNING id
    `;

    // 6. Emit event
    await emitEvent({
        agent_id: agentId,
        kind: 'dream_cycle_completed',
        title: `${agentId} dreamed (${dreamType})`,
        summary: dreamContent.trim().slice(0, 200),
        tags: ['dream', dreamType],
        metadata: {
            dream_id: row.id,
            dream_type: dreamType,
            source_memory_count: seeds.length,
            new_memory_id: newMemoryId,
        },
    });

    log.info('Dream cycle completed', { agentId, dreamId: row.id, dreamType });

    return {
        dreamId: row.id,
        agentId,
        dreamType,
        content: dreamContent.trim(),
        newMemoryId,
        sourceMemoryIds,
    };
}

// ─── Queries ───

/** Check if an agent has dreamed today (UTC) */
export async function hasAgentDreamedToday(agentId: string): Promise<boolean> {
    const [{ count }] = await sql<[{ count: number }]>`
        SELECT COUNT(*)::int as count FROM ops_dream_cycles
        WHERE agent_id = ${agentId}
        AND created_at >= CURRENT_DATE
    `;
    return count > 0;
}

/** Get recent dream cycles, optionally filtered by agent and/or type */
export async function getDreamCycles(options: {
    agentId?: string;
    dreamType?: DreamType;
    limit?: number;
} = {}): Promise<DreamCycle[]> {
    const { agentId, dreamType, limit = 20 } = options;

    return sql<DreamCycle[]>`
        SELECT * FROM ops_dream_cycles
        WHERE 1=1
        ${agentId ? sql`AND agent_id = ${agentId}` : sql``}
        ${dreamType ? sql`AND dream_type = ${dreamType}` : sql``}
        ORDER BY created_at DESC
        LIMIT ${limit}
    `;
}

/** Get a dream cycle with its source memories joined */
export async function getDreamWithSources(dreamId: string): Promise<{
    dream: DreamCycle;
    sourceMemories: MemoryEntry[];
} | null> {
    const [dream] = await sql<DreamCycle[]>`
        SELECT * FROM ops_dream_cycles WHERE id = ${dreamId}
    `;
    if (!dream) return null;

    const sourceMemories = dream.source_memories.length > 0
        ? await sql<MemoryEntry[]>`
            SELECT * FROM ops_agent_memory
            WHERE id = ANY(${dream.source_memories}::uuid[])
            ORDER BY created_at DESC
        `
        : [];

    return { dream, sourceMemories };
}
